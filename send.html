delvee.ts:

// functions/src/delvee.ts (FULL FILE REPLACEMENT)
//
// Delvee: server-authoritative lobby + pulse game engine.
// Writes happen only via callable functions.
// Clients read realtime via Firestore rules (participant read-only).
//
// ✅ Update in this version:
// - ✅ Credits are charged when the session STARTS (delveeStartSession), not when lobby is created.
// - Subscriptions / entitlements (read from /users/{uid}) to provide:
//    • unlimited lobby sessions
//    • unlimited private sessions (enforced later when private sessions are implemented)
// - Starter credits remain: 2 credits via Google sign-in, one-time.
// - Sweeper remains (every 1 minute): LOBBY->CANCELLED, RUNNING->COOLDOWN, COOLDOWN->DONE (+summary).
// - ✅ Admin bypass: if custom claim { admin: true }, credits are not charged.
// - ⚠️ No refunds: if host starts session, the credit is spent even if nobody sends pulses.
//
// Note: Delivering the summary into Setfeed inbox is client-side (participants encrypt
// using their own Setfeed receive code). The server never sees those codes.

import { onCall, HttpsError } from "firebase-functions/v2/https";
import { onSchedule } from "firebase-functions/v2/scheduler";
import * as admin from "firebase-admin";
import { getStorage } from "firebase-admin/storage";

const db = admin.firestore();
const REGION = "europe-west2";

// ---------- Constants ----------
const SESSIONS = "delvee_sessions";

// Timings
const LOBBY_TTL_MS = 20 * 60_000;
const COOLDOWN_MS = 5 * 60_000;

// Pulse constraints
const MAX_PULSES_PER_USER = 250;
const MIN_PULSE_INTERVAL_MS = 900;
const MAX_TEXT_CHARS = 100;

// Chat constraints
const MAX_CHAT_CHARS = 300;
const MAX_CHAT_PER_MINUTE = 30;

// Image upload constraints
const MAX_IMAGE_BYTES = 5_000_000;

// Summary constraints
const MAX_SUMMARY_CHARS = 6000;
const MAX_PULSES_IN_SUMMARY = 140;

// ---------- Credits (Delvee) ----------
const USERS = "users";
const STARTER_CREDITS = 2;

// Charge credits per session (host only) unless subscription allows unlimited
const LOBBY_SESSION_CREDIT_COST = 1;

// If admin, return this as "balance" to keep UIs calm
const ADMIN_BALANCE_SENTINEL = 1_000_000_000;

type AnyMap = Record<string, unknown>;

function userRef(uid: string) {
  return db.collection(USERS).doc(uid);
}

function getCreditsFromDoc(d: AnyMap): number {
  const n = d?.delveeCreditsBalance;
  return typeof n === "number" && Number.isFinite(n) && n > 0 ? n : 0;
}

function requireGoogleProvider(request: any) {
  const provider = request.auth?.token?.firebase?.sign_in_provider;
  if (provider !== "google.com") {
    throw new HttpsError("failed-precondition", "Google sign-in required to claim starter credits.", {
      code: "GOOGLE_REQUIRED",
      provider: provider ?? null,
    });
  }
}

function isAdminRequest(request: any): boolean {
  return Boolean(request?.auth?.token?.admin);
}

// ---------- Subscriptions / entitlements ----------
//
// Stripe should write these fields onto /users/{uid} (server-trust only).
//
// users/{uid}:
//   delveeEntitlements: {
//     lobbyUnlimited: boolean,
//     privateUnlimited: boolean,
//     validUntilMillis?: number | null,
//     plan?: "lobby"|"private"|"both"|null
//   }
//
// If validUntilMillis is present and in the past, entitlements are treated as off.
//
type DelveeEntitlements = {
  lobbyUnlimited: boolean;
  privateUnlimited: boolean;
  validUntilMillis: number | null;
  plan: string | null;
};

function readEntitlementsFromUserDoc(d: AnyMap): DelveeEntitlements {
  const raw = (d?.delveeEntitlements ?? {}) as AnyMap;

  const lobbyUnlimited = Boolean(raw?.lobbyUnlimited);
  const privateUnlimited = Boolean(raw?.privateUnlimited);

  const validUntilMillis =
    typeof raw?.validUntilMillis === "number" && Number.isFinite(raw.validUntilMillis) ? raw.validUntilMillis : null;

  const plan = typeof raw?.plan === "string" && raw.plan.trim().length ? raw.plan.trim() : null;

  if (validUntilMillis != null && Date.now() > validUntilMillis) {
    return { lobbyUnlimited: false, privateUnlimited: false, validUntilMillis, plan };
  }

  return { lobbyUnlimited, privateUnlimited, validUntilMillis, plan };
}

// ---------- Helpers ----------
function requireAuth(request: any): string {
  const uid = request.auth?.uid;
  if (!uid) throw new HttpsError("unauthenticated", "Sign-in required.", { code: "AUTH_REQUIRED" });
  return uid;
}

function requireStringField(data: AnyMap, key: string, maxLen?: number): string {
  const v = data[key];
  if (typeof v !== "string") throw new HttpsError("invalid-argument", `Missing ${key}`, { code: "INVALID_SCHEMA" });
  const s = v.trim();
  if (!s) throw new HttpsError("invalid-argument", `Missing ${key}`, { code: "INVALID_SCHEMA" });
  if (typeof maxLen === "number" && s.length > maxLen) {
    throw new HttpsError("invalid-argument", `${key} too long`, { code: "FIELD_TOO_LONG", key, maxLen });
  }
  return s;
}

function requireNumberField(data: AnyMap, key: string): number {
  const v = data[key];
  if (typeof v !== "number" || !Number.isFinite(v)) {
    throw new HttpsError("invalid-argument", `Missing ${key}`, { code: "INVALID_SCHEMA" });
  }
  return v;
}

function asStringOrNull(v: unknown): string | null {
  return typeof v === "string" && v.trim().length ? v.trim() : null;
}

function nowIso(): string {
  return new Date().toISOString();
}

function lowerAlias(alias: string): string {
  return alias.trim().toLowerCase();
}

function normalizeSessionId(raw: string): string {
  const s = raw.trim().toUpperCase();
  if (!/^[A-Z0-9-]{4,24}$/.test(s)) {
    throw new HttpsError("invalid-argument", "Invalid sessionId format.", { code: "INVALID_SESSION_ID" });
  }
  return s;
}

const ALPHABET = "23456789ABCDEFGHJKLMNPQRSTUVWXYZ";
function randChar(): string {
  return ALPHABET[Math.floor(Math.random() * ALPHABET.length)];
}
function makeSessionId(): string {
  const g1 = Array.from({ length: 4 }, randChar).join("");
  const g2 = Array.from({ length: 4 }, randChar).join("");
  return `DV-${g1}-${g2}`;
}

function sessionRef(sessionId: string) {
  return db.collection(SESSIONS).doc(sessionId);
}
function participantsRef(sessionId: string) {
  return sessionRef(sessionId).collection("participants");
}
function pulsesRef(sessionId: string) {
  return sessionRef(sessionId).collection("pulses");
}
function chatRef(sessionId: string) {
  return sessionRef(sessionId).collection("chat");
}

type SessionState = "LOBBY" | "RUNNING" | "COOLDOWN" | "DONE" | "CANCELLED";
function assertStateAllowed(state: unknown): state is SessionState {
  return state === "LOBBY" || state === "RUNNING" || state === "COOLDOWN" || state === "DONE" || state === "CANCELLED";
}
function assertDurationMinutes(n: number): 4 | 5 {
  if (n !== 4 && n !== 5) {
    throw new HttpsError("invalid-argument", "durationMinutes must be 4 or 5.", { code: "INVALID_DURATION" });
  }
  return n;
}

function allowChatRate(part: AnyMap, nowMs: number): boolean {
  const lastWindowStart = typeof part.chatWindowStartMs === "number" ? part.chatWindowStartMs : 0;
  const chatCountInWindow = typeof part.chatCountInWindow === "number" ? part.chatCountInWindow : 0;
  if (!lastWindowStart || nowMs - lastWindowStart >= 60_000) return true;
  return chatCountInWindow < MAX_CHAT_PER_MINUTE;
}

async function assertParticipantOrThrow(sessionId: string, uid: string) {
  const pref = participantsRef(sessionId).doc(uid);
  const snap = await pref.get();
  if (!snap.exists) throw new HttpsError("permission-denied", "Join session first.", { code: "NOT_A_PARTICIPANT" });
}

// ---------- Summary generation ----------
type SummaryStats = {
  totalPulses: number;
  textPulses: number;
  imagePulses: number;
  participants: number;
  generatedAtUtc: string;
};

function clampText(s: string, maxChars: number): string {
  const t = (s || "").trim();
  if (t.length <= maxChars) return t;
  return t.slice(0, Math.max(0, maxChars - 1)) + "…";
}

function safeLine(s: unknown): string {
  const t = typeof s === "string" ? s : "";
  return t.replace(/\s+/g, " ").trim();
}

async function generateAndStoreSummaryIfMissing(sessionId: string): Promise<void> {
  const sref = sessionRef(sessionId);
  const ssnap = await sref.get();
  if (!ssnap.exists) return;

  const sdoc = (ssnap.data() ?? {}) as AnyMap;

  if (typeof sdoc.summaryText === "string" && sdoc.summaryText.trim().length > 0) return;
  if (sdoc.state !== "DONE") return;

  const pSnap = await participantsRef(sessionId).get();
  const parts = pSnap.docs.map((d) => (d.data() as AnyMap) ?? {});
  const participantCount = parts.length;

  const pulseSnap = await pulsesRef(sessionId).orderBy("createdAtMillis", "asc").limit(MAX_PULSES_PER_USER * 4).get();
  const pulses = pulseSnap.docs.map((d) => (d.data() as AnyMap) ?? {});

  let textCount = 0;
  let imageCount = 0;

  const lines: string[] = [];
  for (const p of pulses) {
    const kind = asStringOrNull(p.kind) || "text";
    if (kind === "image") imageCount++;
    else textCount++;

    if (lines.length >= MAX_PULSES_IN_SUMMARY) continue;

    if (kind === "image") lines.push("• [image]");
    else lines.push(`• ${clampText(safeLine(p.text) || "[empty]", 140)}`);
  }

  const startsAtUtc = asStringOrNull(sdoc.startsAtUtc);
  const endAtUtc = asStringOrNull(sdoc.endAtUtc);
  const durationMinutes = typeof sdoc.durationMinutes === "number" ? sdoc.durationMinutes : null;

  const header: string[] = [];
  header.push("Delvee — pulse summary");
  header.push(`Session ${sessionId}`);
  header.push(`Participants: ${participantCount}`);
  header.push(`Pulses: ${pulses.length} (text ${textCount} · images ${imageCount})`);
  if (durationMinutes) header.push(`Duration: ${durationMinutes} min`);
  if (startsAtUtc) header.push(`Started: ${startsAtUtc}`);
  if (endAtUtc) header.push(`Ended: ${endAtUtc}`);

  const body = [header.join("\n"), "", "Timeline (anonymous):", ...(lines.length ? lines : ["• (no pulses)"])].join("\n");
  const summaryText = clampText(body, MAX_SUMMARY_CHARS);

  const stats: SummaryStats = {
    totalPulses: pulses.length,
    textPulses: textCount,
    imagePulses: imageCount,
    participants: participantCount,
    generatedAtUtc: nowIso(),
  };

  await sref.set(
    {
      summaryText,
      summaryStats: stats,
      summaryReadyAtUtc: nowIso(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    },
    { merge: true }
  );
}

// ------------------------------------------------------
// ✅ Credits callables
// ------------------------------------------------------
export const getDelveeCreditsBalance = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);

  if (isAdminRequest(request)) {
    return { ok: true, balance: ADMIN_BALANCE_SENTINEL, isAdmin: true };
  }

  const snap = await userRef(uid).get();
  const d = (snap.data() ?? {}) as AnyMap;
  return { ok: true, balance: getCreditsFromDoc(d), isAdmin: false };
});

export const claimDelveeStarterCredits = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  requireGoogleProvider(request);

  const out = await db.runTransaction(async (tx) => {
    const ref = userRef(uid);
    const snap = await tx.get(ref);
    const d = (snap.data() ?? {}) as AnyMap;

    const already = Boolean(d.delveeClaimedStarterCredits);
    const current = getCreditsFromDoc(d);

    if (already) return { granted: false, balance: current };

    const next = current + STARTER_CREDITS;

    tx.set(
      ref,
      {
        delveeCreditsBalance: next,
        delveeClaimedStarterCredits: true,
        delveeStarterCreditsGrantedAtUtc: nowIso(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
        createdAt: snap.exists ? (d.createdAt ?? admin.firestore.FieldValue.serverTimestamp()) : admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );

    return { granted: true, balance: next };
  });

  return { ok: true, ...out };
});

// ------------------------------------------------------
// ✅ Manual summary generation callable
// ------------------------------------------------------
export const delveeGenerateSummaryOnDone = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  const data = (request.data ?? {}) as AnyMap;
  const sessionId = normalizeSessionId(requireStringField(data, "sessionId"));

  await assertParticipantOrThrow(sessionId, uid);

  await generateAndStoreSummaryIfMissing(sessionId);
  return { ok: true, sessionId };
});

// ---------- Callables ----------
export const delveeCreateSession = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  const data = (request.data ?? {}) as AnyMap;

  const alias = requireStringField(data, "alias", 18);
  const aliasLower = lowerAlias(alias);

  const adminBypass = isAdminRequest(request);

  for (let attempt = 0; attempt < 5; attempt++) {
    const sessionId = makeSessionId();
    const sref = sessionRef(sessionId);
    const pref = participantsRef(sessionId).doc(uid);
    const uref = userRef(uid);

    const created = await db.runTransaction(async (tx) => {
      const existing = await tx.get(sref);
      if (existing.exists) return { created: false as const };

      const uSnap = await tx.get(uref);
      const uDoc = (uSnap.data() ?? {}) as AnyMap;
      const ent = readEntitlementsFromUserDoc(uDoc);

      const nowMs = Date.now();

      // ✅ NO CHARGE HERE anymore (charge happens at delveeStartSession)
      tx.set(sref, {
        sessionId,
        state: "LOBBY" satisfies SessionState,
        hostUid: uid,

        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        createdAtUtc: nowIso(),
        reservationExpiresAtMillis: nowMs + LOBBY_TTL_MS,

        startsAtUtc: null,
        endAtUtc: null,
        endAtMillis: null,
        durationMinutes: null,

        cooldownEndsAtMillis: null,
        summaryReadyAtUtc: null,
        summaryText: null,
        summaryStats: null,

        // audit / gating metadata (charged at start)
        lobbySessionCreditCharged: 0,
        hostCreditsBalanceAfter: null,
        hostLobbyUnlimited: ent.lobbyUnlimited,
        hostAdminBypass: adminBypass,
        lobbyCreditChargeTiming: "START_SESSION",

        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      tx.set(pref, {
        uid,
        alias,
        aliasLower,
        joinedAt: admin.firestore.FieldValue.serverTimestamp(),
        ready: false,

        pulsesCount: 0,
        lastPulseAtMillis: 0,
        lastPulseClientId: null,

        chatWindowStartMs: 0,
        chatCountInWindow: 0,

        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });

      return { created: true as const };
    });

    if (created.created) {
      return { ok: true, sessionId, state: "LOBBY", adminBypass };
    }
  }

  throw new HttpsError("internal", "Failed to create session. Try again.", { code: "SESSION_CREATE_FAILED" });
});

export const delveeJoinSession = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizeSessionId(requireStringField(data, "sessionId"));
  const alias = requireStringField(data, "alias", 18);
  const aliasLower = lowerAlias(alias);

  const sref = sessionRef(sessionId);
  const pref = participantsRef(sessionId).doc(uid);

  const out = await db.runTransaction(async (tx) => {
    const ssnap = await tx.get(sref);
    if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

    const sdoc = (ssnap.data() ?? {}) as AnyMap;
    const state = sdoc.state;
    if (!assertStateAllowed(state)) throw new HttpsError("failed-precondition", "Invalid session state.", { code: "INVALID_STATE" });

    if (state !== "LOBBY") throw new HttpsError("failed-precondition", "Session already started.", { code: "SESSION_ALREADY_STARTED", state });

    const nowMs = Date.now();
    const exp = typeof sdoc.reservationExpiresAtMillis === "number" ? sdoc.reservationExpiresAtMillis : 0;
    if (exp > 0 && nowMs > exp) throw new HttpsError("failed-precondition", "Session lobby expired.", { code: "SESSION_EXPIRED" });

    const psnap = await tx.get(pref);
    if (!psnap.exists) {
      tx.set(pref, {
        uid,
        alias,
        aliasLower,
        joinedAt: admin.firestore.FieldValue.serverTimestamp(),
        ready: false,

        pulsesCount: 0,
        lastPulseAtMillis: 0,
        lastPulseClientId: null,

        chatWindowStartMs: 0,
        chatCountInWindow: 0,

        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      });
    } else {
      tx.set(pref, { alias, aliasLower, updatedAt: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });
    }

    tx.set(sref, { updatedAt: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });
    return { sessionId, state: sdoc.state, hostUid: sdoc.hostUid ?? null };
  });

  return { ok: true, ...out };
});

export const delveeSetReady = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizeSessionId(requireStringField(data, "sessionId"));
  const ready = Boolean(data.ready);

  const sref = sessionRef(sessionId);
  const pref = participantsRef(sessionId).doc(uid);

  await db.runTransaction(async (tx) => {
    const ssnap = await tx.get(sref);
    if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

    const sdoc = (ssnap.data() ?? {}) as AnyMap;
    if (sdoc.state !== "LOBBY") throw new HttpsError("failed-precondition", "Can only ready up in lobby.", { code: "NOT_IN_LOBBY" });

    const psnap = await tx.get(pref);
    if (!psnap.exists) throw new HttpsError("permission-denied", "Join session first.", { code: "NOT_A_PARTICIPANT" });

    tx.set(pref, { ready, updatedAt: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });
    tx.set(sref, { updatedAt: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });
  });

  return { ok: true, sessionId, ready };
});

export const delveeStartSession = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizeSessionId(requireStringField(data, "sessionId"));
  const durationMinutes = assertDurationMinutes(requireNumberField(data, "durationMinutes"));

  const adminBypass = isAdminRequest(request);

  const sref = sessionRef(sessionId);
  const uref = userRef(uid);

  const out = await db.runTransaction(async (tx) => {
    const ssnap = await tx.get(sref);
    if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

    const sdoc = (ssnap.data() ?? {}) as AnyMap;

    if (sdoc.hostUid !== uid) throw new HttpsError("permission-denied", "Only host can start.", { code: "HOST_ONLY" });
    if (sdoc.state !== "LOBBY") throw new HttpsError("failed-precondition", "Session already started.", { code: "ALREADY_STARTED", state: sdoc.state });

    const nowMs = Date.now();
    const exp = typeof sdoc.reservationExpiresAtMillis === "number" ? sdoc.reservationExpiresAtMillis : 0;
    if (exp > 0 && nowMs > exp) throw new HttpsError("failed-precondition", "Session lobby expired.", { code: "SESSION_EXPIRED" });

    const pColl = participantsRef(sessionId);
    const pSnap = await tx.get(pColl);
    const parts = pSnap.docs.map((d) => (d.data() as AnyMap) ?? {});
    if (parts.length < 1) throw new HttpsError("failed-precondition", "No participants.", { code: "NO_PARTICIPANTS" });

    const notReady = parts.filter((p) => !Boolean(p.ready));
    if (notReady.length > 0) {
      throw new HttpsError("failed-precondition", "Everyone must click ready.", { code: "NOT_ALL_READY", notReadyCount: notReady.length });
    }

    // ✅ Charge here (exactly once) unless unlimited or admin
    const alreadyCharged = typeof sdoc.lobbySessionCreditCharged === "number" ? sdoc.lobbySessionCreditCharged : 0;

    let charged = alreadyCharged;
    let nextBal: number | null = typeof sdoc.hostCreditsBalanceAfter === "number" ? (sdoc.hostCreditsBalanceAfter as number) : null;
    let ent: DelveeEntitlements | null = null;

    if (alreadyCharged <= 0) {
      const uSnap = await tx.get(uref);
      const uDoc = (uSnap.data() ?? {}) as AnyMap;

      ent = readEntitlementsFromUserDoc(uDoc);

      if (!adminBypass && !ent.lobbyUnlimited) {
        const bal = getCreditsFromDoc(uDoc);
        if (bal < LOBBY_SESSION_CREDIT_COST) {
          throw new HttpsError("resource-exhausted", "No Delvee credits remaining.", {
            code: "OUT_OF_CREDITS",
            balance: bal,
            required: LOBBY_SESSION_CREDIT_COST,
            entitlements: ent,
          });
        }

        nextBal = bal - LOBBY_SESSION_CREDIT_COST;
        charged = LOBBY_SESSION_CREDIT_COST;

        tx.set(
          uref,
          {
            delveeCreditsBalance: nextBal,
            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
          },
          { merge: true }
        );
      } else {
        // no charge
        charged = 0;
        nextBal = adminBypass ? ADMIN_BALANCE_SENTINEL : null;
      }
    }

    const startsAt = new Date(nowMs);
    const endAtMs = nowMs + durationMinutes * 60_000;
    const endAt = new Date(endAtMs);

    tx.set(
      sref,
      {
        state: "RUNNING" satisfies SessionState,
        startsAtUtc: startsAt.toISOString(),
        endAtUtc: endAt.toISOString(),
        endAtMillis: endAtMs,
        durationMinutes,

        // audit (write what happened at start)
        lobbySessionCreditCharged: charged,
        hostCreditsBalanceAfter: nextBal,
        hostLobbyUnlimited: ent ? ent.lobbyUnlimited : Boolean(sdoc.hostLobbyUnlimited),
        hostAdminBypass: adminBypass,

        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );

    return {
      startsAtUtc: startsAt.toISOString(),
      endAtUtc: endAt.toISOString(),
      endAtMillis: endAtMs,
      durationMinutes,
      lobbyCreditCharged: charged,
      creditsBalanceAfter: adminBypass ? ADMIN_BALANCE_SENTINEL : nextBal,
      adminBypass,
    };
  });

  return { ok: true, sessionId, ...out };
});

export const delveePulseText = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizeSessionId(requireStringField(data, "sessionId"));
  const clientPulseId = requireStringField(data, "clientPulseId", 64);
  const text = requireStringField(data, "text", MAX_TEXT_CHARS);

  const sref = sessionRef(sessionId);
  const pref = participantsRef(sessionId).doc(uid);

  const pulseId = `${uid}_${clientPulseId}`;
  const pulseRef = pulsesRef(sessionId).doc(pulseId);

  const out = await db.runTransaction(async (tx) => {
    const ssnap = await tx.get(sref);
    if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

    const sdoc = (ssnap.data() ?? {}) as AnyMap;
    if (sdoc.state !== "RUNNING") throw new HttpsError("failed-precondition", "Session is not running.", { code: "NOT_RUNNING", state: sdoc.state });

    const endAtMs = typeof sdoc.endAtMillis === "number" ? sdoc.endAtMillis : 0;
    const nowMs = Date.now();
    if (endAtMs > 0 && nowMs > endAtMs) throw new HttpsError("failed-precondition", "Session window ended.", { code: "ENDED" });

    const psnap = await tx.get(pref);
    if (!psnap.exists) throw new HttpsError("permission-denied", "Join session first.", { code: "NOT_A_PARTICIPANT" });

    const pdoc = (psnap.data() ?? {}) as AnyMap;
    const pulsesCount = typeof pdoc.pulsesCount === "number" ? pdoc.pulsesCount : 0;
    if (pulsesCount >= MAX_PULSES_PER_USER) throw new HttpsError("resource-exhausted", "Pulse limit reached.", { code: "PULSE_LIMIT" });

    const lastPulseAt = typeof pdoc.lastPulseAtMillis === "number" ? pdoc.lastPulseAtMillis : 0;
    if (lastPulseAt && nowMs - lastPulseAt < MIN_PULSE_INTERVAL_MS) throw new HttpsError("resource-exhausted", "Too fast. Slow down.", { code: "RATE_LIMIT" });

    const pulseSnap = await tx.get(pulseRef);
    if (pulseSnap.exists) return { pulseId, pulsesCount };

    tx.set(pulseRef, {
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      createdAtMillis: nowMs,
      senderUid: uid,
      kind: "text",
      text,
      clientPulseId,
    });

    const nextCount = pulsesCount + 1;
    tx.set(
      pref,
      { pulsesCount: nextCount, lastPulseAtMillis: nowMs, lastPulseClientId: clientPulseId, updatedAt: admin.firestore.FieldValue.serverTimestamp() },
      { merge: true }
    );

    tx.set(sref, { updatedAt: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });

    return { pulseId, pulsesCount: nextCount };
  });

  return { ok: true, sessionId, ...out };
});

export const delveeCreateImageUpload = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizeSessionId(requireStringField(data, "sessionId"));
  const attachmentId = requireStringField(data, "attachmentId", 64);
  const sizeBytes = requireNumberField(data, "sizeBytes");
  const contentType = requireStringField(data, "contentType", 80);

  if (!contentType.startsWith("image/")) throw new HttpsError("invalid-argument", "Only image uploads are supported.", { code: "UNSUPPORTED_TYPE" });
  if (sizeBytes <= 0 || sizeBytes > MAX_IMAGE_BYTES) throw new HttpsError("invalid-argument", "Image too large.", { code: "IMAGE_TOO_LARGE", max: MAX_IMAGE_BYTES });

  const sref = sessionRef(sessionId);
  const ssnap = await sref.get();
  if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

  await assertParticipantOrThrow(sessionId, uid);

  const storagePath = `delvee_attachments/${uid}/${sessionId}/${attachmentId}.bin`;

  const bucket = getStorage().bucket();
  const file = bucket.file(storagePath);

  const expiresAtMillis = Date.now() + 10 * 60_000;
  const [uploadUrl] = await file.getSignedUrl({
    version: "v4",
    action: "write",
    expires: expiresAtMillis,
    contentType: "application/octet-stream",
  });

  return { ok: true, storagePath, uploadUrl, expiresAtMillis };
});

export const delveePulseImageCommit = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizeSessionId(requireStringField(data, "sessionId"));
  const clientPulseId = requireStringField(data, "clientPulseId", 64);

  const a = (data.attachment ?? {}) as AnyMap;
  const storagePath = requireStringField(a, "storagePath", 512);
  const contentType = requireStringField(a, "contentType", 80);
  const sizeBytes = requireNumberField(a, "sizeBytes");
  const ivB64 = asStringOrNull(a["ivB64"]);
  const saltB64 = asStringOrNull(a["saltB64"]);

  if (!contentType.startsWith("image/")) throw new HttpsError("invalid-argument", "Only image pulses supported.", { code: "UNSUPPORTED_TYPE" });
  if (sizeBytes <= 0 || sizeBytes > MAX_IMAGE_BYTES) throw new HttpsError("invalid-argument", "Image too large.", { code: "IMAGE_TOO_LARGE", max: MAX_IMAGE_BYTES });

  const expectedPrefix = `delvee_attachments/${uid}/${sessionId}/`;
  if (!storagePath.startsWith(expectedPrefix)) throw new HttpsError("permission-denied", "Invalid storagePath for uploader.", { code: "BAD_STORAGE_PATH" });

  const sref = sessionRef(sessionId);
  const pref = participantsRef(sessionId).doc(uid);

  const pulseId = `${uid}_${clientPulseId}`;
  const pulseRef = pulsesRef(sessionId).doc(pulseId);

  const out = await db.runTransaction(async (tx) => {
    const ssnap = await tx.get(sref);
    if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

    const sdoc = (ssnap.data() ?? {}) as AnyMap;
    if (sdoc.state !== "RUNNING") throw new HttpsError("failed-precondition", "Session is not running.", { code: "NOT_RUNNING", state: sdoc.state });

    const endAtMs = typeof sdoc.endAtMillis === "number" ? sdoc.endAtMillis : 0;
    const nowMs = Date.now();
    if (endAtMs > 0 && nowMs > endAtMs) throw new HttpsError("failed-precondition", "Session window ended.", { code: "ENDED" });

    const psnap = await tx.get(pref);
    if (!psnap.exists) throw new HttpsError("permission-denied", "Join session first.", { code: "NOT_A_PARTICIPANT" });

    const pdoc = (psnap.data() ?? {}) as AnyMap;
    const pulsesCount = typeof pdoc.pulsesCount === "number" ? pdoc.pulsesCount : 0;
    if (pulsesCount >= MAX_PULSES_PER_USER) throw new HttpsError("resource-exhausted", "Pulse limit reached.", { code: "PULSE_LIMIT" });

    const lastPulseAt = typeof pdoc.lastPulseAtMillis === "number" ? pdoc.lastPulseAtMillis : 0;
    if (lastPulseAt && nowMs - lastPulseAt < MIN_PULSE_INTERVAL_MS) throw new HttpsError("resource-exhausted", "Too fast. Slow down.", { code: "RATE_LIMIT" });

    const pulseSnap = await tx.get(pulseRef);
    if (pulseSnap.exists) return { pulseId, pulsesCount };

    tx.set(pulseRef, {
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      createdAtMillis: nowMs,
      senderUid: uid,
      kind: "image",
      clientPulseId,
      attachment: { storagePath, contentType, sizeBytes, ivB64: ivB64 ?? null, saltB64: saltB64 ?? null },
    });

    const nextCount = pulsesCount + 1;
    tx.set(
      pref,
      { pulsesCount: nextCount, lastPulseAtMillis: nowMs, lastPulseClientId: clientPulseId, updatedAt: admin.firestore.FieldValue.serverTimestamp() },
      { merge: true }
    );

    tx.set(sref, { updatedAt: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });

    return { pulseId, pulsesCount: nextCount };
  });

  return { ok: true, sessionId, ...out };
});

export const delveeCreateImageDownloadUrl = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizeSessionId(requireStringField(data, "sessionId"));
  const storagePath = requireStringField(data, "storagePath", 512);

  await assertParticipantOrThrow(sessionId, uid);

  if (!storagePath.startsWith("delvee_attachments/") || !storagePath.includes(`/${sessionId}/`)) {
    throw new HttpsError("permission-denied", "Invalid storagePath.", { code: "BAD_STORAGE_PATH" });
  }

  const bucket = getStorage().bucket();
  const file = bucket.file(storagePath);

  const expiresAtMillis = Date.now() + 5 * 60_000;
  const [downloadUrl] = await file.getSignedUrl({ version: "v4", action: "read", expires: expiresAtMillis });

  return { ok: true, storagePath, downloadUrl, expiresAtMillis };
});

export const delveeChatSend = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizeSessionId(requireStringField(data, "sessionId"));
  const text = requireStringField(data, "text", MAX_CHAT_CHARS);

  const sref = sessionRef(sessionId);
  const pref = participantsRef(sessionId).doc(uid);

  const messageId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  const mref = chatRef(sessionId).doc(messageId);

  await db.runTransaction(async (tx) => {
    const ssnap = await tx.get(sref);
    if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

    const sdoc = (ssnap.data() ?? {}) as AnyMap;
    const st = sdoc.state;
    if (st !== "COOLDOWN" && st !== "DONE") {
      throw new HttpsError("failed-precondition", "Chat opens during cooldown.", { code: "CHAT_NOT_AVAILABLE", state: st });
    }

    const psnap = await tx.get(pref);
    if (!psnap.exists) throw new HttpsError("permission-denied", "Join session first.", { code: "NOT_A_PARTICIPANT" });

    const pdoc = (psnap.data() ?? {}) as AnyMap;
    const nowMs = Date.now();

    if (!allowChatRate(pdoc, nowMs)) throw new HttpsError("resource-exhausted", "Chat rate limit.", { code: "CHAT_RATE_LIMIT" });

    const lastWindowStart = typeof pdoc.chatWindowStartMs === "number" ? pdoc.chatWindowStartMs : 0;
    const chatCountInWindow = typeof pdoc.chatCountInWindow === "number" ? pdoc.chatCountInWindow : 0;

    const newWindowStart = !lastWindowStart || nowMs - lastWindowStart >= 60_000 ? nowMs : lastWindowStart;
    const newCount = newWindowStart !== lastWindowStart ? 1 : chatCountInWindow + 1;

    tx.set(mref, { createdAt: admin.firestore.FieldValue.serverTimestamp(), createdAtMillis: nowMs, senderUid: uid, text });

    tx.set(pref, { chatWindowStartMs: newWindowStart, chatCountInWindow: newCount, updatedAt: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });
    tx.set(sref, { updatedAt: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });
  });

  return { ok: true, sessionId, messageId };
});

export const delveeLeaveSession = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);
  const data = (request.data ?? {}) as AnyMap;
  const sessionId = normalizeSessionId(requireStringField(data, "sessionId"));
  await participantsRef(sessionId).doc(uid).delete().catch(() => null);
  return { ok: true, sessionId };
});

// ---------- Scheduled state machine ----------
export const delveeSweepSessions = onSchedule({ region: REGION, schedule: "every 1 minutes", timeZone: "UTC" }, async () => {
  const nowMs = Date.now();
  const nowIsoStr = nowIso();

  // LOBBY expired -> CANCELLED
  {
    const snap = await db.collection(SESSIONS).where("state", "==", "LOBBY").where("reservationExpiresAtMillis", "<=", nowMs).limit(200).get();
    if (!snap.empty) {
      const batch = db.batch();
      for (const d of snap.docs) {
        batch.set(
          d.ref,
          { state: "CANCELLED" satisfies SessionState, cancelledAtUtc: nowIsoStr, updatedAt: admin.firestore.FieldValue.serverTimestamp() },
          { merge: true }
        );
      }
      await batch.commit();
    }
  }

  // RUNNING ended -> COOLDOWN
  {
    const snap = await db.collection(SESSIONS).where("state", "==", "RUNNING").where("endAtUtc", "<=", nowIsoStr).limit(200).get();
    if (!snap.empty) {
      const batch = db.batch();
      for (const d of snap.docs) {
        batch.set(
          d.ref,
          {
            state: "COOLDOWN" satisfies SessionState,
            cooldownEndsAtMillis: nowMs + COOLDOWN_MS,
            cooldownStartedAtUtc: nowIsoStr,
            updatedAt: admin.firestore.FieldValue.serverTimestamp(),
          },
          { merge: true }
        );
      }
      await batch.commit();
    }
  }

  // COOLDOWN ended -> DONE + generate summary
  {
    const snap = await db.collection(SESSIONS).where("state", "==", "COOLDOWN").where("cooldownEndsAtMillis", "<=", nowMs).limit(200).get();
    if (!snap.empty) {
      const batch = db.batch();
      const sessionIds: string[] = [];

      for (const d of snap.docs) {
        sessionIds.push(d.id);
        batch.set(
          d.ref,
          { state: "DONE" satisfies SessionState, summaryReadyAtUtc: nowIsoStr, updatedAt: admin.firestore.FieldValue.serverTimestamp() },
          { merge: true }
        );
      }
      await batch.commit();

      for (const sid of sessionIds) {
        try {
          await generateAndStoreSummaryIfMissing(sid);
        } catch (e) {
          console.error("[delveeSweepSessions] summary generation failed for", sid, e);
        }
      }
    }
  }
});

index.ts:

// functions/src/index.ts (FULL FILE REPLACEMENT)
import * as admin from "firebase-admin";

admin.initializeApp();

// Rolling (unsigned)
export {
  provisionRollingEnvelope,
  fetchRollingEnvelope,
  fetchRollingEnvelopes,
  markRollingCodeConsumed,
  markEnvelopeConsumed,
  sendRollingCiphertext,
} from "./rolling";

// Signed
export {
  createSignedAttachmentUpload,
  createSignedAttachmentDownloadUrl,
  sendSignedCiphertext,
  fetchSignedEnvelopes,
  markSignedEnvelopeConsumed,

  // ✅ Private pulse-to-summary sessions (2 min, 1 credit)
  createSignedPrivatePulseSession,
  signedPrivatePulseText,
  signedPrivateCreateImageUpload,
  signedPrivatePulseImageCommit,
  finalizeSignedPrivatePulseSession,
  sweepSignedPrivatePulseSessions,
} from "./signed";

// Web receive codes
export { getReceiveCodes, refreshRollingReceiveCode } from "./codes";

// Delvee
export {
  delveeCreateSession,
  delveeJoinSession,
  delveeSetReady,
  delveeStartSession,
  delveePulseText,
  delveeCreateImageUpload,
  delveePulseImageCommit,
  delveeCreateImageDownloadUrl,
  delveeChatSend,
  delveeLeaveSession,
  delveeSweepSessions,
  delveeGenerateSummaryOnDone,

  // ✅ Credits
  getDelveeCreditsBalance,
  claimDelveeStarterCredits,
} from "./delvee";

// ✅ Admin tools (dev/testing)
export { setDelveeEntitlementsAdmin } from "./admin";

// ✅ Stripe (subscriptions)
export {
  createStripeCheckoutSession,
  createStripeBillingPortalSession,
  stripeWebhook,
} from "./stripe";

codes.ts:

// functions/src/codes.ts (NEW FILE)
import { onCall, HttpsError } from "firebase-functions/v2/https";
import * as admin from "firebase-admin";

const db = admin.firestore();
const REGION = "europe-west2";
const COLLECTION = "web_receive_codes";

// Avoid ambiguous characters (0/O, 1/I, etc.)
const ALPHABET = "23456789ABCDEFGHJKLMNPQRSTUVWXYZ";

type AnyMap = Record<string, unknown>;

function requireAuth(request: any): string {
  const uid = request.auth?.uid;
  if (!uid) {
    throw new HttpsError("unauthenticated", "Sign-in required.", { code: "AUTH_REQUIRED" });
  }
  return uid;
}

function randChar() {
  const i = Math.floor(Math.random() * ALPHABET.length);
  return ALPHABET[i];
}

function makeGroups(groupCount: number, groupLen: number) {
  const groups: string[] = [];
  for (let g = 0; g < groupCount; g++) {
    let s = "";
    for (let i = 0; i < groupLen; i++) s += randChar();
    groups.push(s);
  }
  return groups.join("-");
}

function makeCode(prefix: "SF" | "SFS" | "SFR") {
  // Personal: SF-XXXXXX-XXXXXX (12 chars)
  // Secure:   SFS-XXXXXX-XXXXXX-XXXXXX (18 chars)
  // Rolling:  SFR-XXXXXX-XXXXXX (12 chars)
  if (prefix === "SFS") return `SFS-${makeGroups(3, 6)}`;
  if (prefix === "SFR") return `SFR-${makeGroups(2, 6)}`;
  return `SF-${makeGroups(2, 6)}`;
}

function toPayload(doc: AnyMap) {
  return {
    personal: { code: typeof doc.personalCode === "string" ? doc.personalCode : "—" },
    secure: { code: typeof doc.secureCode === "string" ? doc.secureCode : "—" },
    rolling: {
      code: typeof doc.rollingCode === "string" ? doc.rollingCode : "—",
      expiresAtMillis: typeof doc.rollingExpiresAtMillis === "number" ? doc.rollingExpiresAtMillis : null,
    },
  };
}

/**
 * ✅ getReceiveCodes
 * Creates (or returns) the signed-in user's web receive codes.
 * Stored in Firestore so the user gets the same codes across devices.
 */
export const getReceiveCodes = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);

  const ref = db.collection(COLLECTION).doc(uid);

  const out = await db.runTransaction(async (tx) => {
    const snap = await tx.get(ref);

    if (!snap.exists) {
      const now = Date.now();
      const doc: AnyMap = {
        uid,
        personalCode: makeCode("SF"),
        secureCode: makeCode("SFS"),
        rollingCode: makeCode("SFR"),
        rollingExpiresAtMillis: now + 7 * 24 * 60 * 60 * 1000, // 7 days
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      };
      tx.set(ref, doc);
      return doc;
    }

    const doc = (snap.data() ?? {}) as AnyMap;

    // If any fields are missing, patch them deterministically.
    const patch: AnyMap = {
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    };

    if (typeof doc.personalCode !== "string" || doc.personalCode.trim().length < 6) {
      patch.personalCode = makeCode("SF");
    }
    if (typeof doc.secureCode !== "string" || doc.secureCode.trim().length < 6) {
      patch.secureCode = makeCode("SFS");
    }
    if (typeof doc.rollingCode !== "string" || doc.rollingCode.trim().length < 6) {
      patch.rollingCode = makeCode("SFR");
      patch.rollingExpiresAtMillis = Date.now() + 7 * 24 * 60 * 60 * 1000;
    }

    // If rolling expired, rotate it.
    const exp = typeof doc.rollingExpiresAtMillis === "number" ? doc.rollingExpiresAtMillis : 0;
    if (exp > 0 && Date.now() > exp) {
      patch.rollingCode = makeCode("SFR");
      patch.rollingExpiresAtMillis = Date.now() + 7 * 24 * 60 * 60 * 1000;
    }

    if (Object.keys(patch).length > 1) {
      tx.set(ref, patch, { merge: true });
      return { ...doc, ...patch };
    }

    return doc;
  });

  return toPayload(out as AnyMap);
});

/**
 * ✅ refreshRollingReceiveCode
 * Rotates only rolling.
 */
export const refreshRollingReceiveCode = onCall({ region: REGION }, async (request) => {
  const uid = requireAuth(request);

  const ref = db.collection(COLLECTION).doc(uid);

  const updated = await db.runTransaction(async (tx) => {
    const snap = await tx.get(ref);

    const now = Date.now();
    const nextRolling = makeCode("SFR");
    const nextExp = now + 7 * 24 * 60 * 60 * 1000;

    if (!snap.exists) {
      const doc: AnyMap = {
        uid,
        personalCode: makeCode("SF"),
        secureCode: makeCode("SFS"),
        rollingCode: nextRolling,
        rollingExpiresAtMillis: nextExp,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      };
      tx.set(ref, doc);
      return doc;
    }

    const doc = (snap.data() ?? {}) as AnyMap;

    tx.set(
      ref,
      {
        rollingCode: nextRolling,
        rollingExpiresAtMillis: nextExp,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );

    return { ...doc, rollingCode: nextRolling, rollingExpiresAtMillis: nextExp };
  });

  // Return either just rolling, or full payload — your receive.html supports both.
  return {
    code: typeof (updated as AnyMap).rollingCode === "string" ? (updated as AnyMap).rollingCode : null,
    expiresAtMillis: typeof (updated as AnyMap).rollingExpiresAtMillis === "number" ? (updated as AnyMap).rollingExpiresAtMillis : null,
  };
});


signed.ts:

// functions/src/signed.ts (FULL FILE REPLACEMENT)
import { onCall, HttpsError } from "firebase-functions/v2/https";
import { onSchedule } from "firebase-functions/v2/scheduler";
import * as admin from "firebase-admin";
import { getStorage } from "firebase-admin/storage";

const db = admin.firestore();

type AnyMap = Record<string, unknown>;

const REGION = "europe-west2";
const COLLECTION = "signed_envelopes";

// ✅ New: private pulse sessions (server generates summary; client encrypts + sends one envelope)
const PRIVATE_SESSIONS = "signed_private_sessions";
const PRIVATE_SESSION_WINDOW_MS = 2 * 60_000;

// Constraints (keep conservative; you can loosen later)
const MAX_TEXT_CHARS = 180;
const MAX_PULSES_PER_SESSION = 500;
const MIN_PULSE_INTERVAL_MS = 350; // lightweight spam protection
const MAX_IMAGE_BYTES = 5_000_000;
const MAX_IMAGES_PER_SESSION = 30;

// Credits are stored on the same user doc as Delvee credits (re-using your existing system)
const USERS = "users";
const PRIVATE_SESSION_CREDIT_COST = 1;

// If admin, return this as "balance" to keep UIs calm
const ADMIN_BALANCE_SENTINEL = 1_000_000_000;

type SignedAttachment = {
  attachmentId: string;
  storagePath: string;
  contentType: string;
  sizeBytes: number;
  ivB64: string;
  saltB64: string;
};

// ---------- Shared helpers ----------
function requireAuthUid(request: any): string {
  const uid = request.auth?.uid;
  if (!uid) throw new HttpsError("unauthenticated", "Sign-in required.", { code: "AUTH_REQUIRED" });
  return uid;
}

function isAdminRequest(request: any): boolean {
  return Boolean(request?.auth?.token?.admin);
}

function requireStringField(data: AnyMap, key: string, maxLen?: number): string {
  const v = data[key];
  if (typeof v !== "string") throw new HttpsError("invalid-argument", `Missing ${key}`, { code: "INVALID_SCHEMA" });
  const s = v.trim();
  if (!s) throw new HttpsError("invalid-argument", `Missing ${key}`, { code: "INVALID_SCHEMA" });
  if (typeof maxLen === "number" && s.length > maxLen) {
    throw new HttpsError("invalid-argument", `${key} too long`, { code: "FIELD_TOO_LONG", key, maxLen });
  }
  return s;
}

function requireNumberField(data: AnyMap, key: string): number {
  const v = data[key];
  if (typeof v !== "number" || !Number.isFinite(v)) {
    throw new HttpsError("invalid-argument", `Missing ${key}`, { code: "INVALID_SCHEMA" });
  }
  return v;
}

function asStringOrNull(v: unknown): string | null {
  return typeof v === "string" && v.trim().length > 0 ? v.trim() : null;
}

function asArray(v: unknown): unknown[] {
  return Array.isArray(v) ? v : [];
}

function nowIso(): string {
  return new Date().toISOString();
}

// ---------- Credits + entitlements helpers ----------
function userRef(uid: string) {
  return db.collection(USERS).doc(uid);
}

function getCreditsFromDoc(d: AnyMap): number {
  const n = d?.delveeCreditsBalance;
  return typeof n === "number" && Number.isFinite(n) && n > 0 ? n : 0;
}

type DelveeEntitlements = {
  lobbyUnlimited: boolean;
  privateUnlimited: boolean;
  validUntilMillis: number | null;
  plan: string | null;
};

function readEntitlementsFromUserDoc(d: AnyMap): DelveeEntitlements {
  const raw = (d?.delveeEntitlements ?? {}) as AnyMap;

  const lobbyUnlimited = Boolean(raw?.lobbyUnlimited);
  const privateUnlimited = Boolean(raw?.privateUnlimited);

  const validUntilMillis =
    typeof raw?.validUntilMillis === "number" && Number.isFinite(raw.validUntilMillis) ? raw.validUntilMillis : null;

  const plan = typeof raw?.plan === "string" && raw.plan.trim().length ? raw.plan.trim() : null;

  if (validUntilMillis != null && Date.now() > validUntilMillis) {
    return { lobbyUnlimited: false, privateUnlimited: false, validUntilMillis, plan };
  }

  return { lobbyUnlimited, privateUnlimited, validUntilMillis, plan };
}

async function chargeCreditsOrThrow(tx: FirebaseFirestore.Transaction, uid: string, cost: number, requestForAdmin?: any) {
  if (requestForAdmin && isAdminRequest(requestForAdmin)) {
    return { before: ADMIN_BALANCE_SENTINEL, after: ADMIN_BALANCE_SENTINEL, adminBypass: true };
  }

  const ref = userRef(uid);
  const snap = await tx.get(ref);
  const d = (snap.data() ?? {}) as AnyMap;

  const ent = readEntitlementsFromUserDoc(d);
  if (ent.privateUnlimited) {
    return { before: null, after: null, adminBypass: false, privateUnlimited: true };
  }

  const bal = getCreditsFromDoc(d);
  if (bal < cost) {
    throw new HttpsError("resource-exhausted", "No credits remaining.", { code: "OUT_OF_CREDITS", balance: bal });
  }

  const next = bal - cost;
  tx.set(
    ref,
    {
      delveeCreditsBalance: next,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      createdAt: snap.exists ? (d.createdAt ?? admin.firestore.FieldValue.serverTimestamp()) : admin.firestore.FieldValue.serverTimestamp(),
    },
    { merge: true }
  );

  return { before: bal, after: next, adminBypass: false, privateUnlimited: false };
}

// ---------- Existing signed helpers ----------
function assertValidTimeZone(timeZone: string) {
  try {
    // eslint-disable-next-line no-new
    new Intl.DateTimeFormat("en-US", { timeZone });
  } catch {
    throw new HttpsError("invalid-argument", "Invalid userTimezone.", { code: "INVALID_TIMEZONE" });
  }
}

function parseIsoWithOffset(iso: string): Date {
  const hasOffset = /([zZ]|[+\-]\d{2}:\d{2})$/.test(iso);
  if (!hasOffset) {
    throw new HttpsError("invalid-argument", "deliverAtLocalIso must include a timezone offset (e.g. +00:00).", {
      code: "INVALID_SCHEDULE_FORMAT",
    });
  }
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) {
    throw new HttpsError("invalid-argument", "Invalid deliverAtLocalIso.", { code: "INVALID_SCHEDULE_FORMAT" });
  }
  return d;
}

function validateSignedAttachments(raw: unknown, senderUid: string): SignedAttachment[] {
  const list = asArray(raw);
  if (list.length === 0) return [];

  const MAX_ATTACHMENTS = 6;
  const MAX_SIZE_BYTES = 5_000_000;

  if (list.length > MAX_ATTACHMENTS) {
    throw new HttpsError("invalid-argument", `Too many attachments (max ${MAX_ATTACHMENTS}).`, { code: "ATTACHMENT_LIMIT" });
  }

  const out: SignedAttachment[] = [];
  const prefix = `signed_attachments/${senderUid}/`;

  for (const item of list) {
    const a = (item ?? {}) as AnyMap;

    const attachmentId = requireStringField(a, "attachmentId", 64);
    const storagePath = requireStringField(a, "storagePath", 768);
    const contentType = requireStringField(a, "contentType", 80);
    const sizeBytes = requireNumberField(a, "sizeBytes");
    const ivB64 = requireStringField(a, "ivB64", 256);
    const saltB64 = requireStringField(a, "saltB64", 256);

    if (!storagePath.startsWith(prefix)) {
      throw new HttpsError("permission-denied", "Invalid storagePath for sender.", { code: "ATTACHMENT_PATH_FORBIDDEN" });
    }
    if (!storagePath.endsWith(".bin")) {
      throw new HttpsError("invalid-argument", "Encrypted attachments must end with .bin", { code: "ATTACHMENT_EXTENSION_REQUIRED" });
    }
    if (!contentType.startsWith("image/")) {
      throw new HttpsError("invalid-argument", "Only image attachments are supported.", { code: "ATTACHMENT_UNSUPPORTED_TYPE" });
    }
    if (sizeBytes <= 0 || sizeBytes > MAX_SIZE_BYTES) {
      throw new HttpsError("invalid-argument", `Attachment too large (max ${MAX_SIZE_BYTES} bytes).`, { code: "ATTACHMENT_TOO_LARGE" });
    }

    out.push({ attachmentId, storagePath, contentType, sizeBytes, ivB64, saltB64 });
  }

  return out;
}

function parseAttachmentsFromDoc(d: AnyMap): SignedAttachment[] {
  const rawAttachments = asArray(d["attachments"]);
  return rawAttachments
    .map((x) => (x ?? {}) as AnyMap)
    .map((a) => {
      const attachmentId = asStringOrNull(a["attachmentId"]);
      const storagePath = asStringOrNull(a["storagePath"]);
      const contentType = asStringOrNull(a["contentType"]);
      const sizeBytes = typeof a["sizeBytes"] === "number" ? a["sizeBytes"] : null;
      const ivB64 = asStringOrNull(a["ivB64"]);
      const saltB64 = asStringOrNull(a["saltB64"]);
      if (!attachmentId || !storagePath || !contentType || sizeBytes == null || !ivB64 || !saltB64) return null;

      return { attachmentId, storagePath, contentType, sizeBytes, ivB64, saltB64 };
    })
    .filter((x): x is SignedAttachment => x !== null);
}

function envelopeFromDoc(docId: string, d: AnyMap) {
  const ciphertext = asStringOrNull(d["ciphertext"]) ?? asStringOrNull(d["ciphertextB64"]);
  const iv = asStringOrNull(d["iv"]) ?? asStringOrNull(d["ivB64"]);
  const salt = asStringOrNull(d["salt"]) ?? asStringOrNull(d["saltB64"]);
  if (!ciphertext || !iv || !salt) return null;

  const attachments = parseAttachmentsFromDoc(d);

  return {
    signedEnvelopeId: docId,
    codeHash: asStringOrNull(d["codeHash"]),
    ciphertext,
    iv,
    salt,
    deliverAtUtc: asStringOrNull(d["deliverAtUtc"]),
    deliverAtLocalIso: asStringOrNull(d["deliverAtLocalIso"]),
    userTimezone: asStringOrNull(d["userTimezone"]),
    consumed: Boolean(d["consumed"]),
    senderUid: asStringOrNull(d["senderUid"]),
    attachments,
  };
}

// ======================================================
// ✅ Signed-only: mint an upload URL for encrypted bytes
// ======================================================
export const createSignedAttachmentUpload = onCall({ region: REGION }, async (request) => {
  const uid = requireAuthUid(request);
  const data = (request.data ?? {}) as AnyMap;

  const attachmentId = requireStringField(data, "attachmentId", 64);
  const contentType = requireStringField(data, "contentType", 80);
  const sizeBytes = requireNumberField(data, "sizeBytes");

  if (!contentType.startsWith("image/")) {
    throw new HttpsError("invalid-argument", "Only image uploads are supported.", { code: "UNSUPPORTED_TYPE" });
  }
  if (sizeBytes <= 0 || sizeBytes > MAX_IMAGE_BYTES) {
    throw new HttpsError("invalid-argument", `Attachment too large (max ${MAX_IMAGE_BYTES} bytes).`, { code: "ATTACHMENT_TOO_LARGE" });
  }

  const storagePath = `signed_attachments/${uid}/${attachmentId}.bin`;

  const bucket = getStorage().bucket();
  const file = bucket.file(storagePath);

  const expiresAtMillis = Date.now() + 10 * 60_000;
  const [uploadUrl] = await file.getSignedUrl({
    version: "v4",
    action: "write",
    expires: expiresAtMillis,
    contentType: "application/octet-stream",
  });

  return { ok: true, storagePath, uploadUrl, expiresAtMillis };
});

// ======================================================
// ✅ Signed: mint a short-lived download URL (recipient use)
// IMPORTANT: intentionally NOT auth-gated currently.
// ======================================================
export const createSignedAttachmentDownloadUrl = onCall({ region: REGION }, async (request) => {
  const data = (request.data ?? {}) as AnyMap;

  const signedEnvelopeId = requireStringField(data, "signedEnvelopeId", 256);
  const attachmentId = requireStringField(data, "attachmentId", 64);

  const ref = db.collection(COLLECTION).doc(signedEnvelopeId);
  const snap = await ref.get();

  if (!snap.exists) throw new HttpsError("not-found", "Signed envelope not found.", { code: "ENVELOPE_NOT_FOUND" });

  const doc = (snap.data() as AnyMap) ?? {};
  const attachments = parseAttachmentsFromDoc(doc);

  const match = attachments.find((a) => a.attachmentId === attachmentId);
  if (!match) throw new HttpsError("not-found", "Attachment not found on this envelope.", { code: "ATTACHMENT_NOT_FOUND" });

  if (!match.storagePath.startsWith("signed_attachments/") || !match.storagePath.endsWith(".bin")) {
    throw new HttpsError("permission-denied", "Invalid attachment storagePath.", { code: "ATTACHMENT_PATH_INVALID" });
  }

  const bucket = getStorage().bucket();
  const file = bucket.file(match.storagePath);

  const expiresAtMillis = Date.now() + 5 * 60_000;
  const [downloadUrl] = await file.getSignedUrl({
    version: "v4",
    action: "read",
    expires: expiresAtMillis,
  });

  return { ok: true, attachmentId, storagePath: match.storagePath, downloadUrl, expiresAtMillis };
});

// ======================================================
// ✅ Signed send entrypoint (ciphertext-only + attachments)
// ======================================================
export const sendSignedCiphertext = onCall({ region: REGION }, async (request) => {
  const senderUid = requireAuthUid(request);
  const data = (request.data ?? {}) as AnyMap;

  const codeHash = requireStringField(data, "codeHash", 256);
  const ciphertext = requireStringField(data, "ciphertext", 200_000);
  const iv = requireStringField(data, "iv", 4096);
  const salt = requireStringField(data, "salt", 4096);

  const deliverAtLocalIso = requireStringField(data, "deliverAtLocalIso", 64);
  const userTimezone = requireStringField(data, "userTimezone", 64);
  const clientRequestId = requireStringField(data, "clientRequestId", 128);

  assertValidTimeZone(userTimezone);
  const deliverAt = parseIsoWithOffset(deliverAtLocalIso);
  const deliverAtUtc = deliverAt.toISOString();

  const attachments = validateSignedAttachments(data["attachments"], senderUid);

  const docId = `${codeHash}_${clientRequestId}`;
  const ref = db.collection(COLLECTION).doc(docId);

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(ref);
    if (snap.exists) return;

    tx.set(ref, {
      codeHash,
      ciphertext,
      iv,
      salt,
      deliverAtUtc,
      deliverAtLocalIso,
      userTimezone,
      clientRequestId,
      attachments,
      consumed: false,
      senderUid,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    });
  });

  return { ok: true, codeHash, deliverAtUtc, signedEnvelopeId: docId, attachmentCount: attachments.length };
});

// ======================================================
// ✅ Fetch signed envelopes (includes attachments[])
// ======================================================
export const fetchSignedEnvelopes = onCall({ region: REGION }, async (request) => {
  const data = (request.data ?? {}) as AnyMap;
  const codeHash = requireStringField(data, "codeHash", 256);

  const snap = await db
    .collection(COLLECTION)
    .where("codeHash", "==", codeHash)
    .where("consumed", "==", false)
    .orderBy("createdAt", "asc")
    .limit(10)
    .get();

  const envelopes = snap.docs
    .map((d) => envelopeFromDoc(d.id, (d.data() as AnyMap) ?? {}))
    .filter((x): x is NonNullable<ReturnType<typeof envelopeFromDoc>> => x !== null);

  return { envelopes };
});

export const markSignedEnvelopeConsumed = onCall({ region: REGION }, async (request) => {
  const data = (request.data ?? {}) as AnyMap;
  const signedEnvelopeId = requireStringField(data, "signedEnvelopeId", 256);

  const ref = db.collection(COLLECTION).doc(signedEnvelopeId);

  await db.runTransaction(async (tx) => {
    const snap = await tx.get(ref);
    if (!snap.exists) throw new HttpsError("not-found", "Signed envelope not found.", { code: "ENVELOPE_NOT_FOUND" });

    const doc = (snap.data() as AnyMap) ?? {};
    if (Boolean(doc["consumed"])) return;

    tx.update(ref, {
      consumed: true,
      consumedAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    });
  });

  return { success: true };
});

// ======================================================
// ✅ Private pulse sessions (2 min / 1 credit / many pulses / one summary)
// ======================================================
function privateSessionRef(sessionId: string) {
  return db.collection(PRIVATE_SESSIONS).doc(sessionId);
}
function privatePulsesRef(sessionId: string) {
  return privateSessionRef(sessionId).collection("pulses");
}

function normalizePrivateSessionId(raw: string): string {
  const s = raw.trim();
  if (!/^[A-Za-z0-9_-]{10,220}$/.test(s)) {
    throw new HttpsError("invalid-argument", "Invalid sessionId.", { code: "INVALID_SESSION_ID" });
  }
  return s;
}

function clampText(s: string, maxChars: number): string {
  const t = (s || "").trim();
  if (t.length <= maxChars) return t;
  return t.slice(0, Math.max(0, maxChars - 1)) + "…";
}

function safeLine(s: unknown): string {
  const t = typeof s === "string" ? s : "";
  return t.replace(/\s+/g, " ").trim();
}

async function generatePrivateSessionSummary(sessionId: string): Promise<{ summaryText: string; attachments: SignedAttachment[] }> {
  const sref = privateSessionRef(sessionId);
  const ssnap = await sref.get();
  if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

  const sdoc = (ssnap.data() ?? {}) as AnyMap;

  const snap = await privatePulsesRef(sessionId).orderBy("createdAtMillis", "asc").limit(MAX_PULSES_PER_SESSION).get();
  const pulses = snap.docs.map((d) => (d.data() as AnyMap) ?? {});

  let textCount = 0;
  let imageCount = 0;

  const lines: string[] = [];
  const attachments: SignedAttachment[] = [];

  for (const p of pulses) {
    const kind = asStringOrNull(p.kind) === "image" ? "image" : "text";
    if (kind === "image") imageCount++;
    else textCount++;

    if (kind === "image") {
      lines.push("• [image]");
      const a = (p.attachment ?? {}) as AnyMap;

      const attachmentId = asStringOrNull(a.attachmentId);
      const storagePath = asStringOrNull(a.storagePath);
      const contentType = asStringOrNull(a.contentType);
      const ivB64 = asStringOrNull(a.ivB64);
      const saltB64 = asStringOrNull(a.saltB64);
      const sizeBytes = typeof a.sizeBytes === "number" ? a.sizeBytes : null;

      if (attachmentId && storagePath && contentType && ivB64 && saltB64 && sizeBytes != null) {
        attachments.push({ attachmentId, storagePath, contentType, sizeBytes, ivB64, saltB64 });
      }
    } else {
      const txt = safeLine(p.text);
      lines.push(`• ${clampText(txt || "[empty]", 160)}`);
    }
  }

  const createdAtUtc = asStringOrNull(sdoc.createdAtUtc) ?? null;

  const header: string[] = [];
  header.push("Setfeed — private pulse summary");
  if (createdAtUtc) header.push(`Created: ${createdAtUtc}`);
  header.push(`Pulses: ${pulses.length} (text ${textCount} · images ${imageCount})`);
  header.push("");

  const body = [...header, ...(lines.length ? lines : ["• (no pulses)"])].join("\n");
  const summaryText = clampText(body, 6000);

  return { summaryText, attachments };
}

/**
 * Start a 2-minute private pulse session.
 * ✅ Charges 1 credit (idempotent via clientRequestId) unless admin/privateUnlimited.
 * Input: { recipientCodeHash, clientRequestId }
 * Output: { sessionId, expiresAtMillis, creditsBalanceAfter, adminBypass?, privateUnlimited? }
 */
export const createSignedPrivatePulseSession = onCall({ region: REGION }, async (request) => {
  const uid = requireAuthUid(request);
  const data = (request.data ?? {}) as AnyMap;

  const recipientCodeHash = requireStringField(data, "recipientCodeHash", 256);
  const clientRequestId = requireStringField(data, "clientRequestId", 128);

  const sessionId = `PS_${uid}_${clientRequestId}`;
  const sref = privateSessionRef(sessionId);

  const out = await db.runTransaction(async (tx) => {
    const snap = await tx.get(sref);
    const nowMs = Date.now();

    if (snap.exists) {
      const d = (snap.data() ?? {}) as AnyMap;
      return {
        sessionId,
        expiresAtMillis: typeof d.expiresAtMillis === "number" ? d.expiresAtMillis : nowMs,
        creditsBalanceAfter: null as number | null,
        alreadyExisted: true,
        adminBypass: Boolean(d.adminBypass),
        privateUnlimited: Boolean(d.privateUnlimited),
      };
    }

    const charged = await chargeCreditsOrThrow(tx, uid, PRIVATE_SESSION_CREDIT_COST, request);

    tx.set(sref, {
      sessionId,
      ownerUid: uid,
      recipientCodeHash,
      state: "OPEN",
      createdAtUtc: nowIso(),
      createdAtMillis: nowMs,
      expiresAtMillis: nowMs + PRIVATE_SESSION_WINDOW_MS,
      lastPulseAtMillis: 0,
      pulsesCount: 0,
      imagesCount: 0,

      // audit
      creditCost: PRIVATE_SESSION_CREDIT_COST,
      adminBypass: Boolean((charged as any).adminBypass),
      privateUnlimited: Boolean((charged as any).privateUnlimited),

      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    });

    return {
      sessionId,
      expiresAtMillis: nowMs + PRIVATE_SESSION_WINDOW_MS,
      creditsBalanceAfter: isAdminRequest(request) ? ADMIN_BALANCE_SENTINEL : ((charged as any).after ?? null),
      alreadyExisted: false,
      adminBypass: isAdminRequest(request),
      privateUnlimited: Boolean((charged as any).privateUnlimited),
    };
  });

  return { ok: true, ...out };
});

export const signedPrivatePulseText = onCall({ region: REGION }, async (request) => {
  const uid = requireAuthUid(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizePrivateSessionId(requireStringField(data, "sessionId", 240));
  const clientPulseId = requireStringField(data, "clientPulseId", 64);
  const text = requireStringField(data, "text", MAX_TEXT_CHARS);

  const sref = privateSessionRef(sessionId);
  const pref = privatePulsesRef(sessionId).doc(`${uid}_${clientPulseId}`);

  const out = await db.runTransaction(async (tx) => {
    const ssnap = await tx.get(sref);
    if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

    const sdoc = (ssnap.data() ?? {}) as AnyMap;
    if (sdoc.ownerUid !== uid) throw new HttpsError("permission-denied", "Owner only.", { code: "OWNER_ONLY" });

    const state = asStringOrNull(sdoc.state);
    if (state !== "OPEN") throw new HttpsError("failed-precondition", "Session not open.", { code: "NOT_OPEN", state });

    const nowMs = Date.now();
    const exp = typeof sdoc.expiresAtMillis === "number" ? sdoc.expiresAtMillis : 0;
    if (exp && nowMs > exp) throw new HttpsError("failed-precondition", "Session expired.", { code: "SESSION_EXPIRED" });

    const count = typeof sdoc.pulsesCount === "number" ? sdoc.pulsesCount : 0;
    if (count >= MAX_PULSES_PER_SESSION) throw new HttpsError("resource-exhausted", "Pulse limit reached.", { code: "PULSE_LIMIT" });

    const lastPulseAt = typeof sdoc.lastPulseAtMillis === "number" ? sdoc.lastPulseAtMillis : 0;
    if (lastPulseAt && nowMs - lastPulseAt < MIN_PULSE_INTERVAL_MS) {
      throw new HttpsError("resource-exhausted", "Too fast. Slow down.", { code: "RATE_LIMIT" });
    }

    const psnap = await tx.get(pref);
    if (psnap.exists) return { pulseId: pref.id, pulsesCount: count, idempotent: true };

    tx.set(pref, {
      kind: "text",
      text,
      clientPulseId,
      createdAtMillis: nowMs,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
    });

    tx.set(
      sref,
      {
        pulsesCount: count + 1,
        lastPulseAtMillis: nowMs,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );

    return { pulseId: pref.id, pulsesCount: count + 1, idempotent: false };
  });

  return { ok: true, sessionId, ...out };
});

export const signedPrivateCreateImageUpload = onCall({ region: REGION }, async (request) => {
  const uid = requireAuthUid(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizePrivateSessionId(requireStringField(data, "sessionId", 240));
  const attachmentId = requireStringField(data, "attachmentId", 64);
  const contentType = requireStringField(data, "contentType", 80);
  const sizeBytes = requireNumberField(data, "sizeBytes");

  if (!contentType.startsWith("image/")) throw new HttpsError("invalid-argument", "Only image uploads are supported.", { code: "UNSUPPORTED_TYPE" });
  if (sizeBytes <= 0 || sizeBytes > MAX_IMAGE_BYTES) {
    throw new HttpsError("invalid-argument", "Image too large.", { code: "IMAGE_TOO_LARGE", max: MAX_IMAGE_BYTES });
  }

  const sref = privateSessionRef(sessionId);
  const ssnap = await sref.get();
  if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

  const sdoc = (ssnap.data() ?? {}) as AnyMap;
  if (sdoc.ownerUid !== uid) throw new HttpsError("permission-denied", "Owner only.", { code: "OWNER_ONLY" });

  const state = asStringOrNull(sdoc.state);
  if (state !== "OPEN") throw new HttpsError("failed-precondition", "Session not open.", { code: "NOT_OPEN", state });

  const nowMs = Date.now();
  const exp = typeof sdoc.expiresAtMillis === "number" ? sdoc.expiresAtMillis : 0;
  if (exp && nowMs > exp) throw new HttpsError("failed-precondition", "Session expired.", { code: "SESSION_EXPIRED" });

  const imagesCount = typeof sdoc.imagesCount === "number" ? sdoc.imagesCount : 0;
  if (imagesCount >= MAX_IMAGES_PER_SESSION) throw new HttpsError("resource-exhausted", "Image limit reached.", { code: "IMAGE_LIMIT" });

  const storagePath = `signed_attachments/${uid}/private/${sessionId}/${attachmentId}.bin`;

  const bucket = getStorage().bucket();
  const file = bucket.file(storagePath);

  const expiresAtMillis = Date.now() + 10 * 60_000;
  const [uploadUrl] = await file.getSignedUrl({
    version: "v4",
    action: "write",
    expires: expiresAtMillis,
    contentType: "application/octet-stream",
  });

  return { ok: true, storagePath, uploadUrl, expiresAtMillis };
});

export const signedPrivatePulseImageCommit = onCall({ region: REGION }, async (request) => {
  const uid = requireAuthUid(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizePrivateSessionId(requireStringField(data, "sessionId", 240));
  const clientPulseId = requireStringField(data, "clientPulseId", 64);

  const a = (data.attachment ?? {}) as AnyMap;
  const attachmentId = requireStringField(a, "attachmentId", 64);
  const storagePath = requireStringField(a, "storagePath", 768);
  const contentType = requireStringField(a, "contentType", 80);
  const sizeBytes = requireNumberField(a, "sizeBytes");
  const ivB64 = requireStringField(a, "ivB64", 256);
  const saltB64 = requireStringField(a, "saltB64", 256);

  if (!contentType.startsWith("image/")) throw new HttpsError("invalid-argument", "Only image pulses supported.", { code: "UNSUPPORTED_TYPE" });
  if (sizeBytes <= 0 || sizeBytes > MAX_IMAGE_BYTES) {
    throw new HttpsError("invalid-argument", "Image too large.", { code: "IMAGE_TOO_LARGE", max: MAX_IMAGE_BYTES });
  }

  const expectedPrefix = `signed_attachments/${uid}/private/${sessionId}/`;
  if (!storagePath.startsWith(expectedPrefix) || !storagePath.endsWith(".bin")) {
    throw new HttpsError("permission-denied", "Invalid storagePath.", { code: "BAD_STORAGE_PATH" });
  }

  const sref = privateSessionRef(sessionId);
  const pref = privatePulsesRef(sessionId).doc(`${uid}_${clientPulseId}`);

  const out = await db.runTransaction(async (tx) => {
    const ssnap = await tx.get(sref);
    if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

    const sdoc = (ssnap.data() ?? {}) as AnyMap;
    if (sdoc.ownerUid !== uid) throw new HttpsError("permission-denied", "Owner only.", { code: "OWNER_ONLY" });

    const state = asStringOrNull(sdoc.state);
    if (state !== "OPEN") throw new HttpsError("failed-precondition", "Session not open.", { code: "NOT_OPEN", state });

    const nowMs = Date.now();
    const exp = typeof sdoc.expiresAtMillis === "number" ? sdoc.expiresAtMillis : 0;
    if (exp && nowMs > exp) throw new HttpsError("failed-precondition", "Session expired.", { code: "SESSION_EXPIRED" });

    const pulsesCount = typeof sdoc.pulsesCount === "number" ? sdoc.pulsesCount : 0;
    if (pulsesCount >= MAX_PULSES_PER_SESSION) throw new HttpsError("resource-exhausted", "Pulse limit reached.", { code: "PULSE_LIMIT" });

    const imagesCount = typeof sdoc.imagesCount === "number" ? sdoc.imagesCount : 0;
    if (imagesCount >= MAX_IMAGES_PER_SESSION) throw new HttpsError("resource-exhausted", "Image limit reached.", { code: "IMAGE_LIMIT" });

    const lastPulseAt = typeof sdoc.lastPulseAtMillis === "number" ? sdoc.lastPulseAtMillis : 0;
    if (lastPulseAt && nowMs - lastPulseAt < MIN_PULSE_INTERVAL_MS) {
      throw new HttpsError("resource-exhausted", "Too fast. Slow down.", { code: "RATE_LIMIT" });
    }

    const psnap = await tx.get(pref);
    if (psnap.exists) return { pulseId: pref.id, pulsesCount, imagesCount, idempotent: true };

    tx.set(pref, {
      kind: "image",
      clientPulseId,
      createdAtMillis: nowMs,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      attachment: { attachmentId, storagePath, contentType, sizeBytes, ivB64, saltB64 },
    });

    tx.set(
      sref,
      {
        pulsesCount: pulsesCount + 1,
        imagesCount: imagesCount + 1,
        lastPulseAtMillis: nowMs,
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );

    return { pulseId: pref.id, pulsesCount: pulsesCount + 1, imagesCount: imagesCount + 1, idempotent: false };
  });

  return { ok: true, sessionId, ...out };
});

export const finalizeSignedPrivatePulseSession = onCall({ region: REGION }, async (request) => {
  const uid = requireAuthUid(request);
  const data = (request.data ?? {}) as AnyMap;

  const sessionId = normalizePrivateSessionId(requireStringField(data, "sessionId", 240));
  const sref = privateSessionRef(sessionId);

  const out = await db.runTransaction(async (tx) => {
    const ssnap = await tx.get(sref);
    if (!ssnap.exists) throw new HttpsError("not-found", "Session not found.", { code: "SESSION_NOT_FOUND" });

    const sdoc = (ssnap.data() ?? {}) as AnyMap;
    if (sdoc.ownerUid !== uid) throw new HttpsError("permission-denied", "Owner only.", { code: "OWNER_ONLY" });

    const state = asStringOrNull(sdoc.state);
    if (state === "FINALIZED") {
      const summaryText = asStringOrNull(sdoc.summaryText);
      const recipientCodeHash = asStringOrNull(sdoc.recipientCodeHash);
      return {
        alreadyFinalized: true,
        recipientCodeHash,
        summaryText,
      };
    }

    tx.set(
      sref,
      {
        state: "FINALIZED",
        finalizedAtUtc: nowIso(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );

    return { alreadyFinalized: false };
  });

  const ssnap2 = await sref.get();
  const sdoc2 = (ssnap2.data() ?? {}) as AnyMap;

  if (asStringOrNull(sdoc2.summaryText)) {
    return {
      ok: true,
      sessionId,
      alreadyFinalized: true,
      recipientCodeHash: asStringOrNull(sdoc2.recipientCodeHash),
      summaryText: asStringOrNull(sdoc2.summaryText),
      attachments: (asArray(sdoc2.summaryAttachments) as AnyMap[]).map((a) => a as any),
    };
  }

  const { summaryText, attachments } = await generatePrivateSessionSummary(sessionId);

  await sref.set(
    {
      summaryText,
      summaryReadyAtUtc: nowIso(),
      summaryAttachments: attachments,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
    },
    { merge: true }
  );

  return {
    ok: true,
    sessionId,
    alreadyFinalized: out.alreadyFinalized,
    recipientCodeHash: asStringOrNull(sdoc2.recipientCodeHash),
    summaryText,
    attachments,
  };
});

// ======================================================
// ✅ Scheduled sweeper: expire OPEN sessions after window
// ======================================================
export const sweepSignedPrivatePulseSessions = onSchedule({ region: REGION, schedule: "every 1 minutes", timeZone: "UTC" }, async () => {
  const nowMs = Date.now();

  const snap = await db
    .collection(PRIVATE_SESSIONS)
    .where("state", "==", "OPEN")
    .where("expiresAtMillis", "<=", nowMs)
    .limit(200)
    .get();

  if (snap.empty) return;

  const batch = db.batch();
  for (const d of snap.docs) {
    batch.set(
      d.ref,
      {
        state: "EXPIRED",
        expiredAtUtc: nowIso(),
        updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      },
      { merge: true }
    );
  }
  await batch.commit();
});

