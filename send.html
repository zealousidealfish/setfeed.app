<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Send ‚Äî Setfeed</title>
  <meta name="description" content="Send an end-to-end encrypted message to Setfeed." />
  <meta name="theme-color" content="#0F1114" />

  <link rel="icon" href="./favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="./favicon-32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="./favicon-16.png" sizes="16x16">
  <link rel="apple-touch-icon" href="./apple-touch-icon.png" sizes="180x180">

  <link rel="stylesheet" href="./styles.css" />

  <!-- =========================
       FIREBASE + APP CHECK
       ========================= -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-check-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>

  <script>
    // =========================
    // üîê PLACEHOLDERS (fill these)
    // =========================
    const firebaseConfig = {
      // apiKey: "‚Ä¶",
      // authDomain: "‚Ä¶",
      // projectId: "‚Ä¶",
      // appId: "‚Ä¶",
      // etc
    };

    // Your App Check reCAPTCHA v3 site key (Firebase Console ‚Üí App Check ‚Üí Web app)
    const RECAPTCHA_SITE_KEY = "PASTE_YOUR_RECAPTCHA_V3_SITE_KEY_HERE";
    // =========================

    firebase.initializeApp(firebaseConfig);

    // Pin region deterministically
    const functions = firebase.app().functions("europe-west2");

    function startAppCheck() {
      try {
        firebase.appCheck().activate(RECAPTCHA_SITE_KEY, true);
        console.log("[AppCheck] activated");
      } catch (e) {
        console.error("[AppCheck] init failed:", e);
      }
    }

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", startAppCheck, { once: true });
    } else {
      startAppCheck();
    }
  </script>

  <!-- =========================
       THEME + AUTH EARLY LOGIC
       ========================= -->
  <script>
    (function(){
      const THEME_KEY = "sf_theme_mode";
      const AUTH_KEY = "sf_signed_authed";
      const root = document.documentElement;

      function readThemeMode(){
        try { return localStorage.getItem(THEME_KEY) || "system"; }
        catch(e){ return "system"; }
      }

      function applyThemeAttr(){
        const stored = readThemeMode();
        if (stored === "light" || stored === "dark") root.setAttribute("data-theme", stored);
        else root.removeAttribute("data-theme");
      }

      applyThemeAttr();

      function isSystemDark(){
        return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
      }

      function setThemeColor(){
        const meta = document.querySelector('meta[name="theme-color"]');
        if (!meta) return;

        const mode = readThemeMode();
        const effectiveDark = (mode === "dark") ? true : (mode === "light") ? false : isSystemDark();
        meta.setAttribute("content", effectiveDark ? "#0F1114" : "#FFFBFE");
      }

      setThemeColor();

      function applyAuthVisibility(){
        const authed = (localStorage.getItem(AUTH_KEY) === "true");
        document.querySelectorAll(".auth-only").forEach(el => {
          el.classList.toggle("hidden", !authed);
        });
      }

      applyAuthVisibility();
      document.addEventListener("DOMContentLoaded", applyAuthVisibility);

      window.addEventListener("storage", (e) => {
        if (!e) return;
        if (e.key === AUTH_KEY) applyAuthVisibility();
        if (e.key === THEME_KEY){
          applyThemeAttr();
          setThemeColor();
        }
      });
    })();
  </script>

  <!-- Minimal modal styles (self-contained) -->
  <style>
    .sf-modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 9999;
    }
    .sf-modal-backdrop.show{ display: flex; }
    .sf-modal{
      width: min(520px, 100%);
      border-radius: 16px;
      background: var(--card, #14171c);
      color: var(--text, #e9eef6);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.08);
      overflow: hidden;
    }
    .sf-modal-header{
      padding: 16px 16px 10px 16px;
      font-weight: 650;
      font-size: 16px;
    }
    .sf-modal-body{
      padding: 0 16px 16px 16px;
      color: rgba(233,238,246,0.85);
      line-height: 1.35;
      font-size: 14px;
      word-break: break-word;
    }
    .sf-modal-actions{
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      padding: 12px 16px 16px 16px;
    }
    .sf-modal-btn{
      border: 0;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
    }
    .sf-modal-btn-primary{
      background: #3b82f6;
      color: #fff;
    }
    .sf-modal-btn-quiet{
      background: rgba(255,255,255,0.08);
      color: rgba(233,238,246,0.9);
    }
  </style>
</head>

<body class="page-bg">
  <header class="site-header">
    <div class="header-inner">
      <a class="brand-mark" href="./" aria-label="Setfeed home">
        <img class="logo" src="./logo.png" alt="" aria-hidden="true" />
      </a>

      <a class="brand-title" href="./">Setfeed</a>

      <nav class="nav" aria-label="Primary">
        <a href="./">Home</a>
        <a href="./send.html" aria-current="page">Send</a>
        <a href="./receive.html">Receive</a>
        <a class="auth-only hidden" href="./inbox.html">Inbox</a>
        <a href="./security.html">Security</a>
        <a href="./privacy.html">Privacy</a>
        <a class="nav-cta" href="#" aria-label="Download Setfeed app">Download app</a>
      </nav>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <h1>Send a scheduled message</h1>
      <p class="lead">
        Messages are encrypted in your browser before they reach Setfeed servers.
        The server stores ciphertext only.
      </p>

      <div class="pills" aria-label="Send highlights">
        <div class="pill"><span class="dot good"></span> End-to-end encrypted</div>
        <div class="pill"><span class="dot good"></span> Ciphertext-only storage</div>
        <div class="pill"><span class="dot warn"></span> Rolling is constrained</div>
      </div>

      <h2>Choose a send type</h2>
      <div class="tabs" role="tablist" aria-label="Send type">
        <button class="tab" id="tab-signed" role="tab" aria-selected="true" aria-controls="panel-signed" type="button">
          Signed (Secure / Personal)
        </button>
        <button class="tab" id="tab-rolling" role="tab" aria-selected="false" aria-controls="panel-rolling" type="button">
          Rolling (no sign-in)
        </button>
      </div>

      <!-- Signed panel -->
      <div id="panel-signed" role="tabpanel" aria-labelledby="tab-signed">
        <div class="row">
          <div class="col" id="signin">
            <div class="field">
              <label for="signed-email">Email</label>
              <input id="signed-email" type="email" autocomplete="email" placeholder="you@example.com" />
            </div>

            <div class="actions">
              <button class="btn btn-lg" id="btn-send-link" type="button">Send sign-in link</button>
              <button class="btn btn-lg btn-quiet" id="btn-sign-out" type="button" disabled>Sign out</button>
            </div>

            <div class="note">
              <p style="margin:0;">
                Signed send requires email-link sign-in. It is required for Secure and Personal codes.
              </p>
            </div>

            <div class="video-card" id="video-signed" aria-label="Walkthrough">
              <h2 style="margin-top:0;">Walkthrough</h2>
              <p class="lead" style="margin-bottom: 0;">
                A short demonstration of the web send flow. No autoplay. Controls only.
              </p>

              <div class="video-frame">
                <video controls preload="metadata" playsinline poster="./poster.png">
                  <source src="./walkthrough.mp4" type="video/mp4" />
                  Sorry ‚Äî your browser can‚Äôt play this video.
                </video>
              </div>

              <small class="help">
                Demonstration supports clarity. UI stays calm and predictable.
              </small>
            </div>
          </div>

          <div class="col">
            <div class="field">
              <label for="signed-code">Secure or Personal code</label>
              <input id="signed-code" type="text" inputmode="text" placeholder="Paste a Secure (SFS-‚Ä¶) or Personal (SF-‚Ä¶) code" />
            </div>

            <div class="field">
              <label for="signed-body">Message</label>
              <textarea id="signed-body" maxlength="1200" placeholder="Write your message‚Ä¶"></textarea>
            </div>

            <div class="actions">
              <button class="btn btn-lg btn-primary" id="btn-signed-send" type="button" disabled>Encrypt &amp; send</button>
              <button class="btn btn-lg btn-quiet" id="btn-signed-clear" type="button">Clear</button>
            </div>

            <small class="help">
              Only the recipient device can decrypt. If a code is invalid, you‚Äôll be told explicitly.
            </small>

            <h2>Delivery</h2>
            <div class="panel">
              <p class="panel-sub" id="signed-delivery-sub" style="margin-bottom: var(--s-3);">
                Sign in to unlock advanced scheduling. Otherwise, signed sends are constrained to tomorrow with preset times.
              </p>
              <div class="chips" aria-label="Default times">
                <button class="chip" type="button" aria-pressed="false" data-time="08:00">8am</button>
                <button class="chip" type="button" aria-pressed="true" data-time="13:00">1pm</button>
                <button class="chip" type="button" aria-pressed="false" data-time="18:00">6pm</button>
              </div>
              <small class="help" id="signed-delivery-help" style="margin-top: 10px;">
                Advanced scheduling becomes available after sign-in.
              </small>
            </div>
          </div>
        </div>
      </div>

      <!-- Rolling panel -->
      <div id="panel-rolling" role="tabpanel" aria-labelledby="tab-rolling" class="hidden">
        <div class="row">
          <div class="col">
            <div class="field">
              <label for="rolling-code">Rolling code</label>
              <input id="rolling-code" type="text" inputmode="text" placeholder="Paste a Rolling code (SFR-‚Ä¶)" />
            </div>

            <div class="video-card" id="video-rolling" aria-label="Walkthrough">
              <h2 style="margin-top:0;">Walkthrough</h2>
              <p class="lead" style="margin-bottom: 0;">
                A short demonstration of the rolling send flow. No autoplay. Controls only.
              </p>

              <div class="video-frame">
                <video controls preload="metadata" playsinline poster="./poster.png">
                  <source src="./walkthrough.mp4" type="video/mp4" />
                  Sorry ‚Äî your browser can‚Äôt play this video.
                </video>
              </div>

              <small class="help">
                Rolling is constrained. Expect explicit errors if expired or over limits.
              </small>
            </div>
          </div>

          <div class="col">
            <div class="field">
              <label for="rolling-body">Message</label>
              <textarea id="rolling-body" maxlength="1200" placeholder="Write your message‚Ä¶"></textarea>
            </div>

            <div class="actions">
              <button class="btn btn-lg btn-primary" id="btn-rolling-send" type="button" disabled>Encrypt &amp; send</button>
              <button class="btn btn-lg btn-quiet" id="btn-rolling-clear" type="button">Clear</button>
            </div>

            <small class="help">
              Rolling is meant for temporary sharing. It may expire or become invalid after use.
            </small>

            <h2 style="margin-top: var(--s-6);">What to expect</h2>
            <ul>
              <li>No sign-in required.</li>
              <li>Strict guardrails (validity, usage limits, rate limiting).</li>
              <li>Clear errors when something can‚Äôt be sent.</li>
            </ul>

            <div class="note">
              <p style="margin:0;">
                If you want a stable link, use Secure (signed) for yourself.
              </p>
            </div>
          </div>
        </div>
      </div>

      <h2>Status</h2>
      <div class="status" role="status" aria-live="polite">
        <div class="status-title">
          <span class="dot" id="status-dot"></span>
          <span id="status-title">Not connected</span>
        </div>
        <p class="status-line" id="status-line">
          Ready.
        </p>
      </div>

      <footer>
        <div>¬© <span id="y"></span> Setfeed</div>
        <div>
          <a href="./security.html">Security</a>
          <span class="sep">¬∑</span>
          <a href="./privacy.html">Privacy</a>
          <span class="sep">¬∑</span>
          <a href="mailto:security@setfeed.app">security@setfeed.app</a>
        </div>
      </footer>
    </div>
  </div>

  <!-- ‚úÖ Message scheduled dialog -->
  <div class="sf-modal-backdrop" id="sf-modal" role="dialog" aria-modal="true" aria-labelledby="sf-modal-title" aria-describedby="sf-modal-body">
    <div class="sf-modal">
      <div class="sf-modal-header" id="sf-modal-title">Message scheduled</div>
      <div class="sf-modal-body" id="sf-modal-body">
        Your message is scheduled. You can close this tab ‚Äî Setfeed will deliver it at the selected time.
      </div>
      <div class="sf-modal-actions">
        <button class="sf-modal-btn sf-modal-btn-quiet" id="sf-modal-close" type="button">Close</button>
        <button class="sf-modal-btn sf-modal-btn-primary" id="sf-modal-ok" type="button">OK</button>
      </div>
    </div>
  </div>

  <script>
    document.getElementById("y").textContent = new Date().getFullYear();

    // Tabs
    const tabSigned = document.getElementById("tab-signed");
    const tabRolling = document.getElementById("tab-rolling");
    const panelSigned = document.getElementById("panel-signed");
    const panelRolling = document.getElementById("panel-rolling");

    function setTab(which) {
      const signed = which === "signed";
      tabSigned.setAttribute("aria-selected", signed ? "true" : "false");
      tabRolling.setAttribute("aria-selected", signed ? "false" : "true");
      panelSigned.classList.toggle("hidden", !signed);
      panelRolling.classList.toggle("hidden", signed);
    }

    tabSigned.addEventListener("click", () => setTab("signed"));
    tabRolling.addEventListener("click", () => setTab("rolling"));

    // Status helper
    const statusDot = document.getElementById("status-dot");
    const statusTitle = document.getElementById("status-title");
    const statusLine = document.getElementById("status-line");

    function setStatus(kind, title, line) {
      statusDot.className = "dot";
      if (kind === "good") statusDot.classList.add("good");
      if (kind === "warn") statusDot.classList.add("warn");
      statusTitle.textContent = title;
      statusLine.textContent = line;
    }

    // ‚úÖ Modal helpers
    const modal = document.getElementById("sf-modal");
    const modalTitle = document.getElementById("sf-modal-title");
    const modalBody = document.getElementById("sf-modal-body");
    const modalClose = document.getElementById("sf-modal-close");
    const modalOk = document.getElementById("sf-modal-ok");

    function showScheduledDialog(message) {
      modalTitle.textContent = "Message scheduled";
      modalBody.textContent = message || "Your message is scheduled. You can close this tab ‚Äî Setfeed will deliver it at the selected time.";
      modal.classList.add("show");
    }
    function hideScheduledDialog() { modal.classList.remove("show"); }

    modalClose.addEventListener("click", hideScheduledDialog);
    modalOk.addEventListener("click", hideScheduledDialog);
    modal.addEventListener("click", (e) => { if (e.target === modal) hideScheduledDialog(); });
    window.addEventListener("keydown", (e) => { if (e.key === "Escape") hideScheduledDialog(); });

    // Elements
    const signedEmail = document.getElementById("signed-email");
    const signedCode = document.getElementById("signed-code");
    const signedBody = document.getElementById("signed-body");
    const btnSendLink = document.getElementById("btn-send-link");
    const btnSignOut = document.getElementById("btn-sign-out");
    const btnSignedSend = document.getElementById("btn-signed-send");
    const btnSignedClear = document.getElementById("btn-signed-clear");
    const videoSigned = document.getElementById("video-signed");
    const signedDeliverySub = document.getElementById("signed-delivery-sub");
    const signedDeliveryHelp = document.getElementById("signed-delivery-help");

    const rollingCodeInput = document.getElementById("rolling-code");
    const rollingBodyInput = document.getElementById("rolling-body");
    const btnRollingSend = document.getElementById("btn-rolling-send");
    const btnRollingClear = document.getElementById("btn-rolling-clear");
    const videoRolling = document.getElementById("video-rolling");

    let signedAuthed = (localStorage.getItem("sf_signed_authed") === "true");

    function refreshNavAuthOnly() {
      document.querySelectorAll(".auth-only").forEach(el => {
        el.classList.toggle("hidden", !signedAuthed);
      });
    }

    function refreshSignedSendEnabled() {
      const canSend = signedAuthed
        && signedCode.value.trim().length > 0
        && signedBody.value.trim().length > 0;
      btnSignedSend.disabled = !canSend;
    }

    function refreshRollingSendEnabled() {
      const canSend = rollingCodeInput.value.trim().length > 0
        && rollingBodyInput.value.trim().length > 0;
      btnRollingSend.disabled = !canSend;
    }

    function applySignedAuthUI() {
      btnSignOut.disabled = !signedAuthed;

      // When signed in, do NOT show walkthrough video in either tab.
      if (videoSigned) videoSigned.classList.toggle("hidden", signedAuthed);
      if (videoRolling) videoRolling.classList.toggle("hidden", signedAuthed);

      if (signedDeliverySub && signedDeliveryHelp) {
        if (signedAuthed) {
          signedDeliverySub.textContent = "Signed in: advanced scheduling becomes available in the next step (Phase 1 stub).";
          signedDeliveryHelp.textContent = "For now, default is still tomorrow with preset times until scheduling UI is expanded.";
        } else {
          signedDeliverySub.textContent = "Not signed in: signed sends are constrained to tomorrow with preset times. Sign in to unlock advanced scheduling.";
          signedDeliveryHelp.textContent = "Advanced scheduling becomes available after sign-in.";
        }
      }

      refreshNavAuthOnly();
      refreshSignedSendEnabled();
    }

    window.addEventListener("storage", (e) => {
      if (!e || e.key !== "sf_signed_authed") return;
      signedAuthed = (localStorage.getItem("sf_signed_authed") === "true");
      applySignedAuthUI();
    });

    signedCode.addEventListener("input", refreshSignedSendEnabled);
    signedBody.addEventListener("input", refreshSignedSendEnabled);
    rollingCodeInput.addEventListener("input", refreshRollingSendEnabled);
    rollingBodyInput.addEventListener("input", refreshRollingSendEnabled);

    btnSendLink.addEventListener("click", () => {
      const email = signedEmail.value.trim();
      if (!email) {
        setStatus("warn", "Email needed", "Enter your email to request a sign-in link.");
        return;
      }
      setStatus("good", "Sign-in link requested", "Sign-in flow is stubbed for now; local auth flag enabled.");
      signedAuthed = true;
      localStorage.setItem("sf_signed_authed", "true");
      applySignedAuthUI();
    });

    btnSignOut.addEventListener("click", () => {
      signedAuthed = false;
      localStorage.setItem("sf_signed_authed", "false");
      applySignedAuthUI();
      setStatus("warn", "Signed out", "Signed sending is unavailable until you sign in again.");
    });

    // -------------------------
    // ‚úÖ Crypto helpers (WebCrypto)
    // Must match Android:
    // - passphrase normalization for PBKDF2 + hashing
    // - PBKDF2WithHmacSHA256, iter=100_000, keylen=256
    // - AES/GCM/NoPadding, iv=12 bytes
    // -------------------------

    // EXACTLY match Android ReceiveCodeService.normalizeCode():
    // trim, UPPERCASE, remove spaces and hyphens
    function normalizeCodeAndroid(raw) {
      return raw.trim()
        .toUpperCase()
        .replace(/ /g, "")
        .replace(/-/g, "");
    }

    function bytesToB64(bytes) {
      let bin = "";
      for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
      return btoa(bin);
    }

    function abToB64(ab) {
      return bytesToB64(new Uint8Array(ab));
    }

    async function sha256Hex(str) {
      const data = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function deriveAesKeyFromPassphrase(passphrase, saltBytes) {
      const passBytes = new TextEncoder().encode(passphrase);

      const baseKey = await crypto.subtle.importKey(
        "raw",
        passBytes,
        { name: "PBKDF2" },
        false,
        ["deriveKey"]
      );

      return await crypto.subtle.deriveKey(
        {
          name: "PBKDF2",
          salt: saltBytes,
          iterations: 100000,
          hash: "SHA-256"
        },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }

    async function encryptBodyForCode(rawCode, plaintext) {
      const passphrase = normalizeCodeAndroid(rawCode); // IMPORTANT (matches Android)
      const salt = crypto.getRandomValues(new Uint8Array(16)); // 16 bytes
      const iv = crypto.getRandomValues(new Uint8Array(12));   // 12 bytes for GCM

      const key = await deriveAesKeyFromPassphrase(passphrase, salt);

      const ptBytes = new TextEncoder().encode(plaintext);
      const ct = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        ptBytes
      );

      return {
        // base64 strings for Firestore + Android
        ciphertextB64: abToB64(ct),
        ivB64: bytesToB64(iv),
        saltB64: bytesToB64(salt),

        // for docId addressing
        normalizedPassphrase: passphrase
      };
    }

    function getUserTimezone() {
      return Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC";
    }

    // Backend requires: TOMORROW (local) at 08:00 / 13:00 / 18:00.
    // Default: 13:00.
    function deliverAtLocalIsoTomorrow(presetHHMM) {
      const tz = getUserTimezone();
      const now = new Date();

      // compute "tomorrow" date parts in local device time (good enough for browser tests)
      const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 12, 0, 0, 0);

      const [hh, mm] = (presetHHMM || "13:00").split(":").map(n => parseInt(n, 10));
      tomorrow.setHours(hh, mm, 0, 0);

      // include offset (required)
      const pad2 = (n) => String(n).padStart(2, "0");
      const offMin = -tomorrow.getTimezoneOffset(); // minutes east of UTC
      const sign = offMin >= 0 ? "+" : "-";
      const abs = Math.abs(offMin);
      const offH = pad2(Math.floor(abs / 60));
      const offM = pad2(abs % 60);

      const yyyy = tomorrow.getFullYear();
      const mon = pad2(tomorrow.getMonth() + 1);
      const day = pad2(tomorrow.getDate());
      const hour = pad2(tomorrow.getHours());
      const minute = pad2(tomorrow.getMinutes());

      // "local ISO with offset"
      return `${yyyy}-${mon}-${day}T${hour}:${minute}:00${sign}${offH}:${offM}`;
    }

    function randomClientRequestId(prefix) {
      return `${prefix}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
    }

    // Delivery chip selection (Signed panel only for now; rolling always uses 13:00)
    let signedPresetTime = "13:00";
    document.querySelectorAll('#panel-signed .chip[data-time]').forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll('#panel-signed .chip[data-time]').forEach(b => b.setAttribute("aria-pressed", "false"));
        btn.setAttribute("aria-pressed", "true");
        signedPresetTime = btn.getAttribute("data-time") || "13:00";
      });
    });

    // -------------------------
    // ‚úÖ "Send" handlers
    // Rolling: REAL encryption + REAL callable: sendRollingCiphertext
    // Signed: REAL encryption + callable name placeholder (you can change it)
    // Both: show ‚ÄúMessage scheduled‚Äù dialog on success
    // -------------------------

    btnSignedSend.addEventListener("click", async () => {
      const code = signedCode.value.trim();
      const body = signedBody.value.trim();

      if (!signedAuthed) {
        setStatus("warn", "Sign-in required", "Secure and Personal sending require email-link sign-in.");
        return;
      }
      if (!code || !body) {
        setStatus("warn", "Missing details", "Add a code and a message, then try again.");
        return;
      }

      try {
        setStatus("good", "Sending‚Ä¶", "Encrypting in your browser and scheduling delivery‚Ä¶");

        const enc = await encryptBodyForCode(code, body);
        const codeHash = await sha256Hex(enc.normalizedPassphrase);

        const deliverAtLocalIso = deliverAtLocalIsoTomorrow(signedPresetTime);
        const userTimezone = getUserTimezone();
        const clientRequestId = randomClientRequestId("signed");

        // ‚úÖ Change this to your real signed callable when it exists.
        // If you already have one, replace "sendSignedCiphertext" with your deployed name.
        const callableName = "sendSignedCiphertext";

        const callable = functions.httpsCallable(callableName);
        await callable({
          codeHash,
          ciphertext: enc.ciphertextB64,
          iv: enc.ivB64,
          salt: enc.saltB64,
          deliverAtLocalIso,
          userTimezone,
          clientRequestId
        });

        setStatus("good", "Scheduled", "Message scheduled.");
        showScheduledDialog("Your signed message is scheduled. You can close this tab ‚Äî Setfeed will deliver it on time.");
      } catch (e) {
        console.error(e);
        const msg = (e && e.message) ? e.message : "Something went wrong while scheduling the message. Try again.";
        setStatus("warn", "Couldn‚Äôt send", msg);
      }
    });

    btnRollingSend.addEventListener("click", async () => {
      const code = rollingCodeInput.value.trim();
      const body = rollingBodyInput.value.trim();

      if (!code || !body) {
        setStatus("warn", "Missing details", "Add a rolling code and a message, then try again.");
        return;
      }

      try {
        setStatus("good", "Sending‚Ä¶", "Encrypting in your browser and scheduling delivery‚Ä¶");

        const enc = await encryptBodyForCode(code, body);

        // ‚úÖ docId = codeHash, must match Android
        const codeHash = await sha256Hex(enc.normalizedPassphrase);

        // ‚úÖ Backend guardrails (tomorrow + preset); default 13:00
        const deliverAtLocalIso = deliverAtLocalIsoTomorrow("13:00");
        const userTimezone = getUserTimezone();
        const clientRequestId = randomClientRequestId("rolling");

        const callable = functions.httpsCallable("sendRollingCiphertext");
        const res = await callable({
          codeHash,
          ciphertext: enc.ciphertextB64,
          iv: enc.ivB64,
          salt: enc.saltB64,
          deliverAtLocalIso,
          userTimezone,
          clientRequestId
        });

        // Optional: show where it landed (helps debugging)
        try {
          console.log("[Rolling] send ok:", res && res.data ? res.data : res);
          console.log("[Rolling] codeHash(docId):", codeHash);
        } catch (_) {}

        setStatus("good", "Scheduled", "Message scheduled.");
        showScheduledDialog("Your rolling message is scheduled. You can close this tab ‚Äî Setfeed will deliver it on time.");
      } catch (e) {
        console.error(e);
        const code = e && e.code ? e.code : "";
        const msg = (e && e.message) ? e.message : "Something went wrong while scheduling the message. Try again.";
        setStatus("warn", "Couldn‚Äôt send", (code ? `${code}: ` : "") + msg);
      }
    });

    btnSignedClear.addEventListener("click", () => {
      signedCode.value = "";
      signedBody.value = "";
      refreshSignedSendEnabled();
      setStatus("warn", "Cleared", "Signed send fields cleared.");
    });

    btnRollingClear.addEventListener("click", () => {
      rollingCodeInput.value = "";
      rollingBodyInput.value = "";
      refreshRollingSendEnabled();
      setStatus("warn", "Cleared", "Rolling send fields cleared.");
    });

    // Init
    applySignedAuthUI();
    refreshRollingSendEnabled();
    setStatus("good", "Ready", "App Check is active. Encryption + rolling send are wired.");
  </script>
</body>
</html>
