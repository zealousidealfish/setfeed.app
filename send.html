<!-- setfeed/send.html (FULL FILE REPLACEMENT) -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Send — Setfeed</title>
  <meta name="description" content="Send an end-to-end encrypted message to Setfeed." />
  <meta name="theme-color" content="#0F1114" id="meta-theme-color" />

  <link rel="icon" href="./favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="./favicon-32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="./favicon-16.png" sizes="16x16">
  <link rel="apple-touch-icon" href="./apple-touch-icon.png" sizes="180x180">

  <link rel="stylesheet" href="./styles.css" />

  <!-- FIREBASE -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-check-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCECKG-00tijJrt5qvRy3L27ZzE7bocNrU",
      authDomain: "setfeed-fcd7a.firebaseapp.com",
      projectId: "setfeed-fcd7a",
      storageBucket: "setfeed-fcd7a.firebasestorage.app",
      messagingSenderId: "553573263069",
      appId: "1:553573263069:web:e5c9884101ca38eaee1d34"
    };

    const RECAPTCHA_SITE_KEY = "6LfgvG0sAAAAANQjlRbdsWx6GMQw1kP2kuOPjeJI";
    const SITE_ORIGIN = window.location.origin;

    if (!firebase.apps || firebase.apps.length === 0) firebase.initializeApp(firebaseConfig);

    window.sfAuth = firebase.auth();
    window.sfFunctions = firebase.app().functions("europe-west2");

    // ✅ IMPORTANT: Set persistence as early as possible (before any sign-in attempt).
    window.sfAuth.setPersistence(firebase.auth.Auth.Persistence.LOCAL).catch(() => {});

    function startAppCheck() {
      try {
        firebase.appCheck().activate(RECAPTCHA_SITE_KEY, true);
        console.log("[AppCheck] activated");
      } catch (e) {
        console.warn("[AppCheck] init failed:", e);
      }
    }
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", startAppCheck, { once: true });
    } else {
      startAppCheck();
    }
  </script>

  <!-- THEME -->
  <script>
    (function(){
      const THEME_KEY = "sf_theme_mode";
      const root = document.documentElement;

      function applyTheme(){
        let stored = "system";
        try { stored = localStorage.getItem(THEME_KEY) || "system"; } catch (_) {}

        if (stored === "light" || stored === "dark") root.setAttribute("data-theme", stored);
        else root.removeAttribute("data-theme");

        const effective =
          root.getAttribute("data-theme") ||
          (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");

        const meta = document.getElementById("meta-theme-color");
        if (meta) meta.content = (effective === "dark") ? "#0F1114" : "#FFFBFE";
      }

      applyTheme();
      window.addEventListener("storage", (e) => { if (e && e.key === THEME_KEY) applyTheme(); });
    })();
  </script>

  <style>
    .hidden{ display:none !important; }
    .sf-status-slot{ margin-top: 10px; }

    .chip, .sf-adv-btn{
      min-height: 42px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      padding-top: 0;
      padding-bottom: 0;
    }

    .sf-adv-row{
      display:flex;
      flex-wrap:wrap;
      gap: var(--s-2, 10px);
      margin-top: var(--s-3, 12px);
    }
    .sf-adv-row .sf-adv-btn{
      font: inherit;
      letter-spacing: inherit;
    }
    .sf-adv-row .sf-adv-btn:active{
      transform: none;
      filter: none;
      opacity: 1;
    }

    html[data-theme="dark"] #signed-body,
    html[data-theme="dark"] #rolling-body{
      background: #ffffff !important;
      color: #0b0c0f !important;
      border-color: rgba(0,0,0,0.18) !important;
    }
    html[data-theme="light"] #signed-body,
    html[data-theme="light"] #rolling-body{
      background: #0b0c0f !important;
      color: #ffffff !important;
      border-color: rgba(255,255,255,0.18) !important;
    }

    .sf-credits-row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content: space-between;
      margin-top: 10px;
    }
    .sf-credits-pill{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 10%, transparent);
      color: var(--text);
      font-weight: var(--fw-medium);
      font-size: 13.2px;
      white-space: nowrap;
    }

    .sf-subhead{
      cursor: pointer;
      user-select: none;
      text-align: center;
    }
    .sf-subhead:hover{ text-decoration: underline; }

    .sf-file-input{ display:none !important; }

    .sf-file-chip{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 12%, transparent);
      color: var(--text);
      font: inherit;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .sf-file-chip:active{
      transform: translateY(1px);
      opacity: 0.95;
    }
    .sf-file-dot{
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--text) 55%, transparent);
      flex: 0 0 auto;
    }
    .sf-file-name{
      max-width: 260px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .sf-file-clear{
      border: 0;
      background: transparent;
      color: color-mix(in srgb, var(--text) 75%, transparent);
      padding: 0;
      margin-left: 2px;
      cursor: pointer;
      font: inherit;
      line-height: 1;
    }
    .sf-file-clear:hover{ color: var(--text); }

    /* Pulse session UI */
    .sf-pulse-panel{
      margin-top: 12px;
      padding: 12px;
      border-radius: 16px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 8%, transparent);
    }
    .sf-pulse-row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      align-items:center;
      justify-content: space-between;
      margin-top: 10px;
    }
    .sf-pulse-timer{
      font-weight: 600;
      color: var(--text);
      font-size: 14px;
      white-space: nowrap;
    }
    .sf-pulse-note{
      font-size: 12.5px;
      opacity: 0.9;
      color: var(--muted);
      margin-top: 8px;
      line-height: 1.35;
    }
  </style>
</head>

<body class="page-bg">
  <header class="site-header">
    <div class="header-inner">
      <a class="brand-mark" href="./" aria-label="Setfeed home">
        <img class="logo" src="./logo.png" alt="" aria-hidden="true" />
      </a>
      <a class="brand-title" href="./">Setfeed</a>

      <nav class="nav" aria-label="Primary">
        <a href="./">Home</a>
        <a href="./send.html" aria-current="page">Send</a>
        <a href="./receive.html">Receive</a>
        <a class="auth-only hidden" href="./inbox.html">Inbox</a>
        <a href="./security.html">Security</a>
        <a href="./privacy.html">Privacy</a>

        <a class="nav-cta" href="https://delvee.app" rel="noreferrer" aria-label="Open Delvee">Open Delvee</a>
      </nav>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <h1>Schedule a message</h1>
      <p class="lead">
        Messages are encrypted in your browser before they reach Setfeed servers.
        Delvee sessions may use credits depending on your plan.
      </p>

      <h2>Choose a send type</h2>
      <div class="tabs" role="tablist" aria-label="Send type">
        <button class="tab" id="tab-signed" role="tab" aria-selected="false" aria-controls="panel-signed" type="button">
          Signed (Secure / Personal)
        </button>
        <button class="tab" id="tab-rolling" role="tab" aria-selected="true" aria-controls="panel-rolling" type="button">
          Rolling (no sign-in)
        </button>
      </div>

      <!-- Signed panel -->
      <div id="panel-signed" role="tabpanel" aria-labelledby="tab-signed" class="hidden">
        <div class="row">
          <div class="col" id="signin">

            <div class="sf-pulse-image-card hidden" id="sf-pulse-image-card">
              <div class="sf-pulse-image-head">
                <div>
                  <div class="panel-title" style="margin:0;">Image preview</div>
                  <div class="panel-sub" style="margin:6px 0 0 0;">
                    Pulse image sends encrypted image pulses to the recipient code directly (no Delvee redirect).
                  </div>
                </div>
              </div>

              <div class="sf-preview" id="sf-preview">
                <div class="sf-preview-empty" id="sf-preview-empty">No image selected.</div>
                <img id="sf-preview-img" class="sf-preview-img hidden" alt="Selected image preview" />
              </div>

              <div class="actions" style="margin-top: 12px;">
                <input id="sf-image-file" class="sf-file-input" type="file" accept="image/*" />

                <button class="sf-file-chip" id="sf-btn-choose-image" type="button" aria-label="Choose image">
                  <span class="sf-file-dot" aria-hidden="true"></span>
                  <span id="sf-file-chip-label">Choose image</span>
                </button>

                <button class="btn btn-lg btn-primary" id="btn-pulse-image" type="button" disabled>Pulse image</button>
              </div>

              <div class="sf-credits-row">
                <small class="help" id="sf-image-help" style="margin-top:0;">
                  Sign in + choose Pulse to enable.
                </small>
                <span class="sf-credits-pill" id="sf-credits-pill">Credits: —</span>
              </div>

              <div class="actions" style="margin-top: 10px;">
                <a class="btn btn-secondary" href="https://delvee.app" rel="noreferrer">Open Delvee (lobbies)</a>
              </div>
            </div>

            <div class="field no-auth-only">
              <label for="signed-email">Email</label>
              <input id="signed-email" type="email" autocomplete="email" placeholder="you@example.com" />
            </div>

            <div class="actions no-auth-only" style="flex-direction: column; align-items: stretch;">
              <!-- ✅ Popup-first, redirect fallback -->
              <button class="btn btn-lg btn-primary" id="btn-google" type="button" aria-label="Continue with Google">
                <span>Continue with Google</span>
              </button>

              <button class="btn btn-lg" id="btn-send-link" type="button">Send sign-in link</button>
            </div>

            <div class="sf-auth-banner hidden auth-only" id="sf-auth-banner">
              <div class="sf-auth-left">
                <span class="sf-auth-email" id="sf-auth-label">Signed in</span>
              </div>

              <div class="sf-auth-actions">
                <button class="btn btn-secondary" id="btn-go-inbox" type="button">Go to Inbox</button>
                <button class="btn btn-quiet" id="btn-sign-out" type="button" disabled>Sign out</button>
              </div>
            </div>

            <div class="note">
              <p style="margin:0;">
                Signed send requires sign-in (Email link or Google). It is required for Secure and Personal codes.
              </p>
            </div>

            <div id="status-slot-top" class="sf-status-slot hidden"></div>

            <div class="video-card" id="video-signed" aria-label="Walkthrough">
              <h2 style="margin-top:0;">Walkthrough</h2>
              <p class="lead" style="margin-bottom: 0;">
                A short demonstration of the web send flow. No autoplay. Controls only.
              </p>

              <div class="video-frame">
                <video controls preload="metadata" playsinline poster="./poster.png">
                  <source src="./walkthrough.mp4" type="video/mp4" />
                  Sorry — your browser can’t play this video.
                </video>
              </div>

              <small class="help">
                Demonstration supports clarity. UI stays calm and predictable.
              </small>
            </div>
          </div>

          <div class="col">
            <div class="sf-subhead" id="sf-delvee-cta" role="link" tabindex="0" aria-label="Create pulse lobby with Delvee">
              Create pulse lobby with Delvee
            </div>

            <div class="field" style="margin-top: 10px;">
              <label for="signed-code">Secure or Personal code</label>
              <input id="signed-code" type="text" inputmode="text" placeholder="Paste a Secure (SFS-…) or Personal (SF-…) code" />
            </div>

            <div class="field">
              <label for="signed-body">Add a message</label>
              <textarea id="signed-body" maxlength="1200" placeholder="Add a message… (optional for Pulse)"></textarea>
            </div>

            <div class="actions">
              <button class="btn btn-lg btn-primary" id="btn-signed-send" type="button" disabled>Encrypt and send</button>
              <button class="btn btn-lg btn-quiet" id="btn-signed-clear" type="button">Clear</button>
            </div>

            <small class="help">
              Only the recipient device can decrypt. If a code is invalid, you’ll be told explicitly.
            </small>

            <h2>Delivery</h2>
            <div class="panel">
              <p class="panel-sub" id="signed-delivery-sub" style="margin-bottom: var(--s-3);">
                Sign in (Email link or Google) to send Signed (Secure / Personal).
              </p>

              <!-- Preset times (only for Tomorrow / In 1 day / In a week modes) -->
              <div class="chips" aria-label="Preset times (signed)" id="signed-time-chips">
                <button class="chip" type="button" aria-pressed="false" data-time="08:00">8am</button>
                <button class="chip" type="button" aria-pressed="true"  data-time="13:00">1pm</button>
                <button class="chip" type="button" aria-pressed="false" data-time="18:00">6pm</button>
              </div>

              <!-- Pulse controls (only for Pulse mode) -->
              <div class="chips hidden" aria-label="Pulse durations (signed)" id="signed-pulse-minutes">
                <button class="chip" type="button" aria-pressed="true" data-min="2">2 minutes</button>
              </div>

              <div class="chips hidden" aria-label="Pulse type (signed)" id="signed-pulse-type">
                <button class="chip" type="button" aria-pressed="true"  data-type="single">Single-message (free)</button>
                <button class="chip" type="button" aria-pressed="false" data-type="multi">Multi-message summary (1 credit)</button>
              </div>

              <div class="sf-adv-row hidden" id="signed-advanced-row" aria-label="Signed delivery modes">
                <button class="chip sf-adv-btn" type="button" aria-pressed="true"  data-mode="pulse">Pulse</button>
                <button class="chip sf-adv-btn" type="button" aria-pressed="false" data-mode="tomorrow">Tomorrow</button>
                <button class="chip sf-adv-btn" type="button" aria-pressed="false" data-mode="in1day">In 1 day</button>
                <button class="chip sf-adv-btn" type="button" aria-pressed="false" data-mode="week">In a week</button>
                <button class="chip sf-adv-btn" type="button" aria-pressed="false" data-mode="10m">In 10 minutes</button>
                <button class="chip sf-adv-btn" type="button" aria-pressed="false" data-mode="1h">In 1 hour</button>
              </div>

              <!-- Pulse session timer/controls (only visible in Pulse mode) -->
              <div class="sf-pulse-panel hidden" id="sf-pulse-session-panel" aria-label="Pulse session">
                <div class="sf-pulse-row">
                  <div class="sf-pulse-timer" id="sf-pulse-timer">Not running.</div>
                  <div class="actions" style="margin:0;">
                    <button class="btn btn-quiet hidden" id="sf-pulse-stop" type="button">Stop</button>
                  </div>
                </div>
                <div class="sf-pulse-note" id="sf-pulse-note">
                  Single-message pulse is free and sends immediately. Multi-message pulse runs for 2 minutes and produces one summary (1 credit).
                </div>
              </div>

              <small class="help" id="signed-delivery-help" style="margin-top: 10px;">
                Pulse sends to the recipient code directly. Delvee is only for lobby sessions.
              </small>
            </div>

            <div class="panel" style="margin-top: var(--s-6);">
              <p class="panel-title" style="margin-top:0;">Delvee credits</p>
              <p class="panel-sub">
                You get <b>2 free credits</b> with Setfeed when you sign in with Google (one per user). More credits unlock more sessions.
              </p>

              <div class="actions" style="margin-top: 10px;">
                <a class="btn btn-primary" href="https://delvee.app" rel="noreferrer">Open Delvee</a>
                <button class="btn btn-secondary" id="btn-claim-credits" type="button">Claim free credits</button>
              </div>

              <small class="help" id="sf-credits-help">
                Packages: 10 credits = £2 · 20 credits = £3 · unlimited session = £3.50
              </small>
            </div>
          </div>
        </div>
      </div>

      <!-- Rolling panel -->
      <div id="panel-rolling" role="tabpanel" aria-labelledby="tab-rolling">
        <div class="row">
          <div class="col">
            <div class="field">
              <label for="rolling-code">Rolling code</label>
              <input id="rolling-code" type="text" inputmode="text" placeholder="Paste a Rolling code (SFR-…)" />
            </div>

            <div class="video-card" id="video-rolling" aria-label="Walkthrough">
              <h2 style="margin-top:0;">Walkthrough</h2>
              <p class="lead" style="margin-bottom: 0;">
                A short demonstration of the rolling send flow. No autoplay. Controls only.
              </p>

              <div class="video-frame">
                <video controls preload="metadata" playsinline poster="./poster.png">
                  <source src="./walkthrough.mp4" type="video/mp4" />
                  Sorry — your browser can’t play this video.
                </video>
              </div>

              <small class="help">
                Rolling is constrained. Expect explicit errors if expired or over limits.
              </small>
            </div>
          </div>

          <div class="col">
            <div class="field">
              <label for="rolling-body">Add a message</label>
              <textarea id="rolling-body" maxlength="1200" placeholder="Add a message…"></textarea>
            </div>

            <div class="actions">
              <button class="btn btn-lg btn-primary" id="btn-rolling-send" type="button" disabled>Encrypt and send</button>
              <button class="btn btn-lg btn-quiet" id="btn-rolling-clear" type="button">Clear</button>
            </div>

            <small class="help">
              Rolling is meant for temporary sharing. It may expire or become invalid after use.
            </small>

            <h2>Delivery (rolling)</h2>
            <div class="panel">
              <p class="panel-sub" style="margin-bottom: var(--s-3);">
                Rolling is constrained to tomorrow at 08:00, 13:00, or 18:00 (your local time).
              </p>
              <div class="chips" aria-label="Tomorrow preset times (rolling)" id="rolling-chips">
                <button class="chip" type="button" aria-pressed="false" data-time="08:00">8am</button>
                <button class="chip" type="button" aria-pressed="true"  data-time="13:00">1pm</button>
                <button class="chip" type="button" aria-pressed="false" data-time="18:00">6pm</button>
              </div>
            </div>

            <h2 style="margin-top: var(--s-6);">What to expect</h2>
            <ul>
              <li>No sign-in required.</li>
              <li>Strict guardrails (validity, usage limits, rate limiting).</li>
              <li>Clear errors when something can’t be sent.</li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Status container -->
      <div id="status-slot-bottom">
        <h2>Status</h2>
        <div class="status" id="status-box" role="status" aria-live="polite">
          <div class="status-title">
            <span class="dot" id="status-dot"></span>
            <span id="status-title">Not connected</span>
          </div>
          <p class="status-line" id="status-line">Ready.</p>
        </div>
      </div>

      <footer>
        <div>© <span id="y"></span> Setfeed</div>
        <div>
          <a href="./security.html">Security</a>
          <span class="sep">·</span>
          <a href="./privacy.html">Privacy</a>
          <span class="sep">·</span>
          <a href="mailto:security@setfeed.app">security@setfeed.app</a>
        </div>
      </footer>
    </div>
  </div>

  <script>
    document.getElementById("y").textContent = new Date().getFullYear();

    const auth = window.sfAuth;
    const functions = window.sfFunctions;

    // Tabs
    const tabSigned = document.getElementById("tab-signed");
    const tabRolling = document.getElementById("tab-rolling");
    const panelSigned = document.getElementById("panel-signed");
    const panelRolling = document.getElementById("panel-rolling");

    let userChoseTab = false;

    function setTab(which) {
      const signed = which === "signed";
      tabSigned.setAttribute("aria-selected", signed ? "true" : "false");
      tabRolling.setAttribute("aria-selected", signed ? "false" : "true");
      panelSigned.classList.toggle("hidden", !signed);
      panelRolling.classList.toggle("hidden", signed);
    }
    tabSigned.addEventListener("click", () => { userChoseTab = true; setTab("signed"); });
    tabRolling.addEventListener("click", () => { userChoseTab = true; setTab("rolling"); });

    // Status helper
    const statusDot = document.getElementById("status-dot");
    const statusTitle = document.getElementById("status-title");
    const statusLine = document.getElementById("status-line");
    function setStatus(kind, title, line) {
      statusDot.className = "dot";
      if (kind === "good") statusDot.classList.add("good");
      if (kind === "warn") statusDot.classList.add("warn");
      statusTitle.textContent = title;
      statusLine.textContent = line;
    }

    // Elements
    const signedEmail = document.getElementById("signed-email");
    const signedCode = document.getElementById("signed-code");
    const signedBody = document.getElementById("signed-body");
    const btnSendLink = document.getElementById("btn-send-link");
    const btnGoogle = document.getElementById("btn-google");
    const btnSignOut = document.getElementById("btn-sign-out");
    const btnGoInbox = document.getElementById("btn-go-inbox");
    const btnSignedSend = document.getElementById("btn-signed-send");
    const btnSignedClear = document.getElementById("btn-signed-clear");
    const videoSigned = document.getElementById("video-signed");
    const signedDeliverySub = document.getElementById("signed-delivery-sub");
    const signedDeliveryHelp = document.getElementById("signed-delivery-help");
    const signedAdvancedRow = document.getElementById("signed-advanced-row");
    const authBanner = document.getElementById("sf-auth-banner");
    const authLabel = document.getElementById("sf-auth-label");

    const rollingCodeInput = document.getElementById("rolling-code");
    const rollingBodyInput = document.getElementById("rolling-body");
    const btnRollingSend = document.getElementById("btn-rolling-send");
    const btnRollingClear = document.getElementById("btn-rolling-clear");
    const videoRolling = document.getElementById("video-rolling");

    // Image preview (signed, pulse mode only)
    const pulseImageCard = document.getElementById("sf-pulse-image-card");
    const sfImageFile = document.getElementById("sf-image-file");
    const btnPulseImage = document.getElementById("btn-pulse-image");
    const previewEmpty = document.getElementById("sf-preview-empty");
    const previewImg = document.getElementById("sf-preview-img");
    const sfImageHelp = document.getElementById("sf-image-help");
    const creditsPill = document.getElementById("sf-credits-pill");
    const btnClaimCredits = document.getElementById("btn-claim-credits");

    const sfBtnChooseImage = document.getElementById("sf-btn-choose-image");
    const sfFileChipLabel = document.getElementById("sf-file-chip-label");

    // Delivery chips
    const signedTimeChipsEl = document.getElementById("signed-time-chips");
    const signedPulseMinutesEl = document.getElementById("signed-pulse-minutes");
    const signedPulseTypeEl = document.getElementById("signed-pulse-type");

    // Pulse session UI
    const pulseSessionPanel = document.getElementById("sf-pulse-session-panel");
    const pulseTimerEl = document.getElementById("sf-pulse-timer");
    const btnPulseStop = document.getElementById("sf-pulse-stop");
    const pulseNoteEl = document.getElementById("sf-pulse-note");

    function setSignedAuthedFlag(isAuthed) {
      document.querySelectorAll(".auth-only").forEach(el => el.classList.toggle("hidden", !isAuthed));
      document.querySelectorAll(".no-auth-only").forEach(el => el.classList.toggle("hidden", isAuthed));
    }

    // ✅ Finalize redirect-based sign-in if fallback was used anywhere
    auth.getRedirectResult().catch((e) => {
      console.error(e);
      const code = (e && e.code) ? String(e.code) : "";
      if (code === "auth/unauthorized-domain") {
        setStatus("warn", "Auth domain not authorized", "Add setfeed.app in Firebase Auth → Authorized domains.");
      } else if (code) {
        setStatus("warn", "Sign-in failed", code);
      }
    });

    // ✅ Popup-first sign-in (fallback to redirect if blocked)
    async function signInGooglePopupFirst() {
      setStatus("good", "Signing in…", "Opening Google sign-in…");

      try { await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL); } catch (_) {}

      const provider = new firebase.auth.GoogleAuthProvider();
      provider.setCustomParameters({ prompt: "select_account" });

      try {
        await auth.signInWithPopup(provider);
        setStatus("good", "Signed in", "Signed sending is available.");
      } catch (e) {
        console.warn("[popup] failed, falling back to redirect:", e);

        const code = (e && e.code) ? String(e.code) : "";
        const popupLikelyBlocked =
          code === "auth/popup-blocked" ||
          code === "auth/popup-closed-by-user" ||
          code === "auth/cancelled-popup-request" ||
          code === "auth/operation-not-supported-in-this-environment";

        if (!popupLikelyBlocked && code === "auth/unauthorized-domain") {
          setStatus("warn", "Domain not authorized", "Add setfeed.app in Firebase Auth → Authorized domains.");
          return;
        }

        try {
          await auth.signInWithRedirect(provider);
        } catch (err) {
          console.error(err);
          setStatus("warn", "Couldn’t sign in", (err && err.code) ? String(err.code) : "Sign-in failed.");
        }
      }
    }

    btnGoogle.addEventListener("click", (e) => {
      e.preventDefault();
      signInGooglePopupFirst();
    });

    // Email link sign-in
    const EMAIL_FOR_SIGNIN_KEY = "sf_email_for_signin";

    btnSendLink.addEventListener("click", async () => {
      const email = (signedEmail && signedEmail.value ? signedEmail.value.trim() : "");
      if (!email) {
        setStatus("warn", "Email needed", "Enter your email to request a sign-in link.");
        return;
      }
      try {
        setStatus("good", "Sending link…", "Check your inbox for the sign-in link.");
        const actionCodeSettings = { url: `${SITE_ORIGIN}/send.html#finishSignIn`, handleCodeInApp: true };
        await auth.sendSignInLinkToEmail(email, actionCodeSettings);
        try { localStorage.setItem(EMAIL_FOR_SIGNIN_KEY, email); } catch (_) {}
        setStatus("good", "Link sent", "Open the link from your email on this device to finish signing in.");
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t send link", "Email-link sign-in failed. Verify Auth is enabled and your domain is authorized.");
      }
    });

    (async function finishEmailLinkIfPresent(){
      try {
        const href = window.location.href;
        if (!auth.isSignInWithEmailLink(href)) return;

        let email = "";
        try { email = localStorage.getItem(EMAIL_FOR_SIGNIN_KEY) || ""; } catch (_) {}
        if (!email) {
          email = window.prompt("Confirm your email to finish sign-in:");
          if (!email) {
            setStatus("warn", "Sign-in not finished", "Email is required to finish sign-in.");
            return;
          }
        }
        setStatus("good", "Signing in…", "Finishing email-link sign-in…");
        await auth.signInWithEmailLink(email, href);
        try { localStorage.removeItem(EMAIL_FOR_SIGNIN_KEY); } catch (_) {}
        setStatus("good", "Signed in", "Signed sending is available.");
        history.replaceState(null, "", "./send.html#signin");
      } catch (e) {
        console.error(e);
        setStatus("warn", "Sign-in failed", "Couldn’t finish email-link sign-in. Try sending a new link.");
      }
    })();

    btnSignOut.addEventListener("click", async () => {
      try {
        await auth.signOut();
        setStatus("warn", "Signed out", "Signed sending is unavailable until you sign in again.");
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t sign out", "Try again.");
      }
    });

    btnGoInbox.addEventListener("click", () => { window.location.href = "./inbox.html"; });

    // Clickable subhead -> Delvee
    const delveeCta = document.getElementById("sf-delvee-cta");
    if (delveeCta) {
      const go = () => { window.location.href = "https://delvee.app"; };
      delveeCta.addEventListener("click", go);
      delveeCta.addEventListener("keydown", (e) => { if (e.key === "Enter" || e.key === " ") go(); });
    }

    // Status movement slots
    const statusBox = document.getElementById("status-box");
    const statusSlotTop = document.getElementById("status-slot-top");
    const statusSlotBottom = document.getElementById("status-slot-bottom");

    function moveStatusToTop(isAuthed) {
      if (!statusBox || !statusSlotTop || !statusSlotBottom) return;
      if (isAuthed) {
        statusSlotTop.classList.remove("hidden");
        statusSlotBottom.classList.add("hidden");
        statusSlotTop.appendChild(statusBox);
      } else {
        statusSlotTop.classList.add("hidden");
        statusSlotBottom.classList.remove("hidden");
        statusSlotBottom.appendChild(statusBox);
      }
    }

    // Credits (Delvee)
    let creditsBalance = null;

    function setCreditsUI(n) {
      if (creditsPill) creditsPill.textContent = (typeof n === "number" && Number.isFinite(n)) ? `Credits: ${n}` : "Credits: —";
      creditsBalance = (typeof n === "number" && Number.isFinite(n)) ? n : null;
      refreshPulseImageEnabled();
    }

    async function loadCredits() {
      if (!auth.currentUser) { setCreditsUI(null); return; }
      try {
        const call = functions.httpsCallable("getDelveeCreditsBalance");
        const res = await call({});
        const data = (res && res.data) ? res.data : {};
        const bal = (typeof data.balance === "number") ? data.balance : (typeof data.credits === "number" ? data.credits : null);
        setCreditsUI((typeof bal === "number") ? bal : null);
      } catch (e) {
        setCreditsUI(null);
      }
    }

    btnClaimCredits.addEventListener("click", async () => {
      if (!auth.currentUser) { setStatus("warn", "Sign-in required", "Sign in with Google to claim free credits."); return; }
      try {
        btnClaimCredits.disabled = true;
        setStatus("good", "Claiming…", "Requesting starter credits…");
        const call = functions.httpsCallable("claimDelveeStarterCredits");
        await call({});
        await loadCredits();
        setStatus("good", "Credits updated", "Starter credits claimed (if eligible).");
      } catch (e) {
        console.warn("[claimDelveeStarterCredits] failed:", e);
        setStatus("warn", "Couldn’t claim", "If you already claimed, this is expected. Otherwise deploy the credits function.");
      } finally {
        btnClaimCredits.disabled = false;
      }
    });

    // ---------------------------
    // Scheduling UI (Signed)
    // ---------------------------
    // Modes:
    // - pulse: Setfeed direct pulse (single = instant, multi = 2-min private pulse session -> summary)
    // - tomorrow / in1day / week: scheduled message at preset time
    // - 10m / 1h: scheduled message relative (no preset times shown)
    let signedMode = "pulse"; // pulse | tomorrow | in1day | week | 10m | 1h
    let signedPresetTime = "13:00";

    let signedPulseMinutes = 2; // fixed for Setfeed private pulse
    let signedPulseType = "single"; // single | multi

    const signedTimeChips = Array.from(document.querySelectorAll('#signed-time-chips .chip[data-time]'));
    const signedPulseMinuteChips = Array.from(document.querySelectorAll('#signed-pulse-minutes .chip[data-min]'));
    const signedPulseTypeChips = Array.from(document.querySelectorAll('#signed-pulse-type .chip[data-type]'));
    const signedAdvBtns = Array.from(document.querySelectorAll('#signed-advanced-row .sf-adv-btn[data-mode]'));

    // Multi-message private pulse session state
    let pulseRunning = false;
    let pulseEndsAtMs = 0;
    let pulseTick = null;
    let privatePulseSessionId = null;
    let privatePulseClientRequestId = null;

    function fmtMmSs(ms) {
      const s = Math.max(0, Math.ceil(ms / 1000));
      const mm = String(Math.floor(s / 60)).padStart(2, "0");
      const ss = String(s % 60).padStart(2, "0");
      return `${mm}:${ss}`;
    }

    function setPulseNote() {
      if (!pulseNoteEl) return;
      if (signedPulseType === "multi") {
        pulseNoteEl.innerHTML =
          'Multi-message pulse runs for <b>2 minutes</b> and produces one summary (<b>1 credit</b>).';
      } else {
        pulseNoteEl.innerHTML =
          'Single-message pulse is <b>free</b> and sends immediately (no session).';
      }
    }

    function stopPulseTimerUI(opts = { silent: false }) {
      pulseRunning = false;
      pulseEndsAtMs = 0;
      privatePulseSessionId = null;
      privatePulseClientRequestId = null;

      if (pulseTick) { clearInterval(pulseTick); pulseTick = null; }

      if (pulseTimerEl) pulseTimerEl.textContent = "Not running.";
      if (btnPulseStop) btnPulseStop.classList.add("hidden");

      btnSignedSend.disabled = true; // re-evaluated by applyBodyGuardrails()
      if (!opts.silent) {
        setStatus("warn", "Pulse stopped", "Multi-message session stopped.");
      }

      applyBodyGuardrails();
      refreshPulseImageEnabled();
      updateSignedSendLabel();
    }

    function startPulseTimerUI(minutes) {
      pulseRunning = true;
      pulseEndsAtMs = Date.now() + (minutes * 60 * 1000);

      if (btnPulseStop) btnPulseStop.classList.remove("hidden");

      btnSignedSend.disabled = true; // disabled while running
      updateSignedSendLabel();

      if (pulseTick) clearInterval(pulseTick);
      pulseTick = setInterval(() => {
        const remaining = pulseEndsAtMs - Date.now();
        if (pulseTimerEl) pulseTimerEl.textContent = `Summary in ${fmtMmSs(remaining)}`;
        if (remaining <= 0) {
          clearInterval(pulseTick);
          pulseTick = null;
          pulseRunning = false;
          if (pulseTimerEl) pulseTimerEl.textContent = "Finalizing summary…";
          setStatus("good", "Pulse window ended", "Finalize to send the summary.");
          applyBodyGuardrails();
          updateSignedSendLabel();
        }
      }, 250);

      if (pulseTimerEl) pulseTimerEl.textContent = `Summary in ${fmtMmSs(pulseEndsAtMs - Date.now())}`;
    }

    function updateSignedSendLabel() {
      if (signedMode === "pulse") {
        if (signedPulseType === "single") {
          btnSignedSend.textContent = "Pulse is instant (use Pulse image / send)";
        } else {
          btnSignedSend.textContent = pulseRunning ? "Pulse running…" : (privatePulseSessionId ? "Finalize + send summary" : "Start 2-min pulse session");
        }
      } else {
        btnSignedSend.textContent = "Encrypt and send";
      }
    }

    function setSignedTimeHighlight() {
      signedTimeChips.forEach(b => {
        const t = b.getAttribute("data-time") || "";
        b.setAttribute("aria-pressed", (t === signedPresetTime) ? "true" : "false");
      });
    }

    function setPulseMinutesHighlight() {
      signedPulseMinuteChips.forEach(b => {
        const m = parseInt(b.getAttribute("data-min") || "2", 10);
        b.setAttribute("aria-pressed", (m === signedPulseMinutes) ? "true" : "false");
      });
    }

    function setPulseTypeHighlight() {
      signedPulseTypeChips.forEach(b => {
        const t = b.getAttribute("data-type") || "single";
        b.setAttribute("aria-pressed", (t === signedPulseType) ? "true" : "false");
      });
    }

    function applySignedModeUI() {
      const isPulse = (signedMode === "pulse");
      const isPresetDay = (signedMode === "tomorrow" || signedMode === "in1day" || signedMode === "week");

      if (signedTimeChipsEl) signedTimeChipsEl.classList.toggle("hidden", !isPresetDay);
      if (signedPulseMinutesEl) signedPulseMinutesEl.classList.toggle("hidden", !isPulse);
      if (signedPulseTypeEl) signedPulseTypeEl.classList.toggle("hidden", !isPulse);

      if (pulseImageCard) pulseImageCard.classList.toggle("hidden", !isPulse);
      if (pulseSessionPanel) pulseSessionPanel.classList.toggle("hidden", !isPulse);

      setPulseNote();
      updateSignedSendLabel();
      refreshPulseImageEnabled();
    }

    function setSignedMode(nextMode) {
      signedMode = nextMode || "tomorrow";

      signedAdvBtns.forEach(b => b.setAttribute("aria-pressed", "false"));
      const btn = signedAdvBtns.find(b => (b.getAttribute("data-mode") || "") === signedMode);
      if (btn) btn.setAttribute("aria-pressed", "true");

      // Leaving pulse mode should stop any multi pulse state UI
      if (signedMode !== "pulse" && (pulseRunning || privatePulseSessionId)) stopPulseTimerUI({ silent: true });

      applySignedModeUI();
      applyBodyGuardrails();
    }

    signedAdvBtns.forEach(btn => btn.addEventListener("click", (e) => { e.preventDefault();
      const mode = btn.getAttribute("data-mode") || "tomorrow";
      const y = window.scrollY; setSignedMode(mode); window.scrollTo(0, y);
    }));

    signedTimeChips.forEach(btn => btn.addEventListener("click", () => {
      signedPresetTime = btn.getAttribute("data-time") || "13:00";
      setSignedTimeHighlight();
      setSignedMode(signedMode); // keep current mode
    }));

    signedPulseMinuteChips.forEach(btn => btn.addEventListener("click", () => {
      signedPulseMinutes = 2; // fixed
      setPulseMinutesHighlight();
      setSignedMode("pulse");
    }));

    signedPulseTypeChips.forEach(btn => btn.addEventListener("click", () => {
      signedPulseType = (btn.getAttribute("data-type") || "single");
      setPulseTypeHighlight();
      setPulseNote();
      // Switching type stops any running multi session
      if (signedPulseType !== "multi" && (pulseRunning || privatePulseSessionId)) stopPulseTimerUI({ silent: true });
      setSignedMode("pulse");
    }));

    // Rolling chips
    let rollingPresetTime = "13:00";
    document.querySelectorAll('#rolling-chips .chip[data-time]').forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll('#rolling-chips .chip[data-time]').forEach(b => b.setAttribute("aria-pressed", "false"));
        btn.setAttribute("aria-pressed", "true");
        rollingPresetTime = btn.getAttribute("data-time") || "13:00";
      });
    });

    // Image preview helpers
    function setPreviewFile(file) {
      if (!file) {
        previewImg.src = "";
        previewImg.classList.add("hidden");
        previewEmpty.classList.remove("hidden");
        return;
      }
      const url = URL.createObjectURL(file);
      previewImg.src = url;
      previewImg.classList.remove("hidden");
      previewEmpty.classList.add("hidden");
    }

    function renderChosenImageName() {
      const f = (sfImageFile && sfImageFile.files && sfImageFile.files[0]) ? sfImageFile.files[0] : null;
      if (!sfFileChipLabel) return;

      if (!f) { sfFileChipLabel.textContent = "Choose image"; return; }

      sfFileChipLabel.innerHTML = "";
      const name = document.createElement("span");
      name.className = "sf-file-name";
      name.textContent = f.name;

      const clear = document.createElement("button");
      clear.className = "sf-file-clear";
      clear.type = "button";
      clear.textContent = "×";
      clear.setAttribute("aria-label", "Clear selected image");
      clear.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        sfImageFile.value = "";
        setPreviewFile(null);
        renderChosenImageName();
        refreshPulseImageEnabled();
      });

      sfFileChipLabel.appendChild(name);
      sfFileChipLabel.appendChild(clear);
    }

    if (sfBtnChooseImage && sfImageFile) {
      sfBtnChooseImage.addEventListener("click", () => sfImageFile.click());
      sfImageFile.addEventListener("change", () => {
        const f = sfImageFile.files && sfImageFile.files[0] ? sfImageFile.files[0] : null;
        setPreviewFile(f);
        renderChosenImageName();
        refreshPulseImageEnabled();
      });
      renderChosenImageName();
    }

    function refreshPulseImageEnabled() {
      const isAuthed = !!auth.currentUser;
      const fileOk = !!(sfImageFile && sfImageFile.files && sfImageFile.files[0]);
      const isPulseMode = (signedMode === "pulse");
      const codeOk = !!(signedCode && signedCode.value && signedCode.value.trim().length > 0);

      // single: can send immediately; multi: can send only when session exists (or user can still press and we auto-start)
      const can =
        isAuthed && fileOk && isPulseMode && codeOk && (signedPulseType === "single" || true);

      btnPulseImage.disabled = !can;

      if (sfImageHelp) {
        if (!isAuthed) sfImageHelp.textContent = "Sign in to send pulse images.";
        else if (!isPulseMode) sfImageHelp.textContent = "Select “Pulse” to enable pulse image.";
        else if (!codeOk) sfImageHelp.textContent = "Paste the recipient Secure/Personal code to enable pulse image.";
        else if (!fileOk) sfImageHelp.textContent = "Choose an image to continue.";
        else if (signedPulseType === "single") sfImageHelp.textContent = "Single-message: sends immediately to the recipient code (free).";
        else sfImageHelp.textContent = pulseRunning ? "Multi-message: image added to the running session." : "Multi-message: starts a 2-min session then adds the image.";
      }
    }

    // Guardrail: prevent receive codes in message body
    function messageContainsSetfeedReceiveCode(text) {
      const s = String(text || "");
      const hasPrefixed =
        /\bSF\s*-\s*[A-Z0-9]{4}\s*-\s*[A-Z0-9]{4}\b/i.test(s) ||
        /\bSFS\s*-\s*[A-Z0-9]{10,}\b/i.test(s) ||
        /\bSFR\s*-\s*[A-Z0-9]{10,}\b/i.test(s);
      if (hasPrefixed) return true;
      const tokens = s.match(/[A-Za-z0-9]{4,}(?:\s*-\s*[A-Za-z0-9]{4,}){1,}/g) || [];
      return tokens.some(t => {
        const tok = t.replace(/\s+/g, "");
        return /^(?:[A-Z0-9]{4,}-){1,}[A-Z0-9]{4,}$/i.test(tok) && tok.length >= 12;
      });
    }

    function applyBodyGuardrails() {
      const isAuthed = !!auth.currentUser;
      const signedHas = messageContainsSetfeedReceiveCode(signedBody.value);
      const rollingHas = messageContainsSetfeedReceiveCode(rollingBodyInput.value);

      if (signedHas || rollingHas) {
        setStatus("warn", "Not allowed in Setfeed", "That looks like a Setfeed receive code inside the message. Remove the code.");
      }

      // Signed:
      // - pulse mode: require auth + recipient code; multi: allow start/finalize; single: send via buttons
      // - other modes: require code + message
      let signedBase = false;
      if (signedMode === "pulse") {
        signedBase = isAuthed && signedCode.value.trim().length > 0 && !(pulseRunning); // allow start/finalize
      } else {
        signedBase = isAuthed && signedCode.value.trim().length > 0 && signedBody.value.trim().length > 0;
      }

      btnSignedSend.disabled = !(signedBase && !signedHas);

      // Rolling:
      const rollingBase = rollingCodeInput.value.trim().length > 0 && rollingBodyInput.value.trim().length > 0;
      btnRollingSend.disabled = !(rollingBase && !rollingHas);

      updateSignedSendLabel();
      return { signedOk: !signedHas, rollingOk: !rollingHas };
    }

    // Crypto helpers (WebCrypto)
    function normalizeCodeAndroid(raw) { return raw.trim().toUpperCase().replace(/[\s-]/g, ""); }
    function bytesToB64(bytes) {
      let binary = "";
      const chunk = 0x8000;
      for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode(...bytes.subarray(i, i + chunk));
      }
      return btoa(binary);
    }
    function abToB64(ab) { return bytesToB64(new Uint8Array(ab)); }
    function b64ToBytes(b64) {
      const bin = atob(b64);
      const out = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
      return out;
    }
    async function sha256Hex(str) {
      const data = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
    }
    async function deriveAesKeyFromPassphrase(passphrase, saltBytes) {
      const passBytes = new TextEncoder().encode(passphrase);
      const baseKey = await crypto.subtle.importKey("raw", passBytes, { name: "PBKDF2" }, false, ["deriveKey"]);
      return await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: saltBytes, iterations: 100000, hash: "SHA-256" },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }
    async function encryptBodyForCode(rawCode, plaintext) {
      const passphrase = normalizeCodeAndroid(rawCode);
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveAesKeyFromPassphrase(passphrase, salt);
      const ptBytes = new TextEncoder().encode(plaintext);
      const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, ptBytes);
      return {
        ciphertextB64: abToB64(ct),
        ivB64: bytesToB64(iv),
        saltB64: bytesToB64(salt),
        normalizedPassphrase: passphrase
      };
    }
    async function encryptBytesForCode(rawCode, bytesUint8) {
      const passphrase = normalizeCodeAndroid(rawCode);
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveAesKeyFromPassphrase(passphrase, salt);
      const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, bytesUint8);
      return {
        ciphertextBytes: new Uint8Array(ct),
        ivB64: bytesToB64(iv),
        saltB64: bytesToB64(salt),
        normalizedPassphrase: passphrase
      };
    }

    function getUserTimezone() { return Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC"; }
    function pad2(n) { return String(n).padStart(2, "0"); }
    function toLocalIsoWithOffset(date) {
      const d = new Date(date.getTime());
      d.setSeconds(0, 0);
      const offMin = -d.getTimezoneOffset();
      const sign = offMin >= 0 ? "+" : "-";
      const abs = Math.abs(offMin);
      const offH = pad2(Math.floor(abs / 60));
      const offM = pad2(abs % 60);
      const yyyy = d.getFullYear();
      const mon = pad2(d.getMonth() + 1);
      const day = pad2(d.getDate());
      const hour = pad2(d.getHours());
      const minute = pad2(d.getMinutes());
      return `${yyyy}-${mon}-${day}T${hour}:${minute}:00${sign}${offH}:${offM}`;
    }

    function deliverAtLocalIsoInDaysAtPresetTime(daysFromToday, presetHHMM) {
      const now = new Date();
      const d = new Date(now.getFullYear(), now.getMonth(), now.getDate() + (daysFromToday || 1), 12, 0, 0, 0);
      const parts = (presetHHMM || "13:00").split(":");
      const hh = parseInt(parts[0] || "13", 10);
      const mm = parseInt(parts[1] || "00", 10);
      d.setHours(hh, mm, 0, 0);
      return toLocalIsoWithOffset(d);
    }

    function deliverAtLocalIsoInMinutes(minutes) {
      const d = new Date(Date.now() + minutes * 60 * 1000);
      d.setSeconds(0, 0);
      return toLocalIsoWithOffset(d);
    }

    function randomClientRequestId(prefix) { return `${prefix}-${Date.now()}-${Math.random().toString(16).slice(2)}`; }
    function randomId(prefix) { return `${prefix}_${Date.now()}_${Math.random().toString(16).slice(2)}`; }

    signedCode.addEventListener("input", () => { applyBodyGuardrails(); refreshPulseImageEnabled(); });
    signedBody.addEventListener("input", () => { applyBodyGuardrails(); refreshPulseImageEnabled(); });
    rollingCodeInput.addEventListener("input", () => { applyBodyGuardrails(); });
    rollingBodyInput.addEventListener("input", () => { applyBodyGuardrails(); });

    function renderAuthUI(user) {
      const isAuthed = !!user;

      if (!userChoseTab) setTab(isAuthed ? "signed" : "rolling");

      setSignedAuthedFlag(isAuthed);

      if (btnSignOut) btnSignOut.disabled = !isAuthed;

      if (videoSigned) videoSigned.classList.toggle("hidden", isAuthed);
      if (videoRolling) videoRolling.classList.toggle("hidden", isAuthed);

      if (signedAdvancedRow) signedAdvancedRow.classList.toggle("hidden", !isAuthed);

      if (authBanner && authLabel) {
        authBanner.classList.toggle("hidden", !isAuthed);
        if (isAuthed) authLabel.textContent = user.email || "Signed in";
      }

      moveStatusToTop(isAuthed);

      if (signedDeliverySub && signedDeliveryHelp) {
        if (isAuthed) {
          signedDeliverySub.textContent = "Signed in: Pulse and advanced delivery available.";
          signedDeliveryHelp.textContent = "Pulse sends directly to the recipient code. Delvee is only for lobby sessions.";
        } else {
          signedDeliverySub.textContent = "Sign in (Email link or Google) to use Signed (Secure / Personal).";
          signedDeliveryHelp.textContent = "Rolling is always available without signing in.";
        }
      }

      // Default: Pulse first when authed
      if (isAuthed) {
        if (signedMode !== "pulse") setSignedMode("pulse");
      } else {
        if (signedMode === "pulse") setSignedMode("tomorrow");
        if (pulseRunning || privatePulseSessionId) stopPulseTimerUI({ silent: true });
      }

      loadCredits().catch(() => {});
      setSignedTimeHighlight();
      setPulseMinutesHighlight();
      setPulseTypeHighlight();
      applySignedModeUI();
      applyBodyGuardrails();
      refreshPulseImageEnabled();
      updateSignedSendLabel();
    }

    auth.onAuthStateChanged((user) => renderAuthUI(user));

    // Pulse stop (multi)
    if (btnPulseStop) {
      btnPulseStop.addEventListener("click", async () => {
        if (!pulseRunning && !privatePulseSessionId) return;
        stopPulseTimerUI({ silent: false });
      });
    }

    // ---------------------------
    // ✅ Pulse image routing
    // ---------------------------
    async function putBytesToSignedUrl(uploadUrl, bytesUint8) {
      const res = await fetch(uploadUrl, {
        method: "PUT",
        headers: { "Content-Type": "application/octet-stream" },
        body: bytesUint8
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Upload failed (${res.status}) ${txt}`.trim());
      }
    }

    async function pulseImageSingleToSetfeed({ code, file }) {
      // 1) Encrypt image bytes for recipient code
      const ab = await file.arrayBuffer();
      const enc = await encryptBytesForCode(code, new Uint8Array(ab));

      // 2) Mint upload URL (signed attachment)
      const attachmentId = randomId("img");
      const callUpload = functions.httpsCallable("createSignedAttachmentUpload");
      const up = await callUpload({ attachmentId, contentType: file.type || "image/*", sizeBytes: enc.ciphertextBytes.length });
      const upData = up && up.data ? up.data : {};
      const uploadUrl = upData.uploadUrl;
      const storagePath = upData.storagePath;
      if (!uploadUrl || !storagePath) throw new Error("Upload URL missing (createSignedAttachmentUpload).");

      // 3) Upload encrypted bytes
      await putBytesToSignedUrl(uploadUrl, enc.ciphertextBytes);

      // 4) Send one signed envelope with attachments[]
      const body = (signedBody.value || "").trim() || "📷 Image";
      const encMsg = await encryptBodyForCode(code, body);
      const codeHash = await sha256Hex(encMsg.normalizedPassphrase);

      const deliverAtLocalIso = deliverAtLocalIsoInMinutes(0);
      const userTimezone = getUserTimezone();
      const clientRequestId = randomClientRequestId("signed");

      const callable = functions.httpsCallable("sendSignedCiphertext");
      await callable({
        codeHash,
        ciphertext: encMsg.ciphertextB64,
        iv: encMsg.ivB64,
        salt: encMsg.saltB64,
        deliverAtLocalIso,
        userTimezone,
        clientRequestId,
        attachments: [{
          attachmentId,
          storagePath,
          contentType: file.type || "image/*",
          sizeBytes: enc.ciphertextBytes.length,
          ivB64: enc.ivB64,
          saltB64: enc.saltB64
        }]
      });
    }

    async function ensurePrivatePulseSession({ code }) {
      if (privatePulseSessionId) return privatePulseSessionId;

      // This is the 1-credit multi-message summary session
      const passphrase = normalizeCodeAndroid(code);
      const recipientCodeHash = await sha256Hex(passphrase);

      privatePulseClientRequestId = privatePulseClientRequestId || randomClientRequestId("ps");
      const create = functions.httpsCallable("createSignedPrivatePulseSession");

      const res = await create({
        recipientCodeHash,
        clientRequestId: privatePulseClientRequestId
      });
      const data = res && res.data ? res.data : {};
      if (!data.sessionId) throw new Error("Missing sessionId (createSignedPrivatePulseSession).");

      privatePulseSessionId = data.sessionId;

      // Start UI timer (2 min)
      startPulseTimerUI(2);

      // Optional: refresh credits pill (best-effort)
      loadCredits().catch(() => {});
      return privatePulseSessionId;
    }

    async function pulseImageMultiAddToSession({ code, file }) {
      const sid = await ensurePrivatePulseSession({ code });

      // 1) Encrypt image bytes for recipient code
      const ab = await file.arrayBuffer();
      const enc = await encryptBytesForCode(code, new Uint8Array(ab));

      // 2) Mint upload URL (private session path, but still under signed_attachments/{uid}/...)
      const attachmentId = randomId("pimg");
      const callUpload = functions.httpsCallable("signedPrivateCreateImageUpload");
      const up = await callUpload({
        sessionId: sid,
        attachmentId,
        contentType: file.type || "image/*",
        sizeBytes: enc.ciphertextBytes.length
      });
      const upData = up && up.data ? up.data : {};
      const uploadUrl = upData.uploadUrl;
      const storagePath = upData.storagePath;
      if (!uploadUrl || !storagePath) throw new Error("Upload URL missing (signedPrivateCreateImageUpload).");

      // 3) Upload encrypted bytes
      await putBytesToSignedUrl(uploadUrl, enc.ciphertextBytes);

      // 4) Commit image pulse
      const commit = functions.httpsCallable("signedPrivatePulseImageCommit");
      await commit({
        sessionId: sid,
        clientPulseId: randomId("pulse"),
        attachment: {
          attachmentId,
          storagePath,
          contentType: file.type || "image/*",
          sizeBytes: enc.ciphertextBytes.length,
          ivB64: enc.ivB64,
          saltB64: enc.saltB64
        }
      });
    }

    async function finalizePrivatePulseAndSend({ code }) {
      if (!privatePulseSessionId) throw new Error("No private pulse session to finalize.");

      const sid = privatePulseSessionId;

      // 1) Finalize session -> get summaryText + attachments
      const fin = functions.httpsCallable("finalizeSignedPrivatePulseSession");
      const res = await fin({ sessionId: sid });
      const data = res && res.data ? res.data : {};

      const summaryText = (typeof data.summaryText === "string") ? data.summaryText : null;
      const attachments = Array.isArray(data.attachments) ? data.attachments : [];

      if (!summaryText) throw new Error("No summaryText returned (finalizeSignedPrivatePulseSession).");

      // 2) Encrypt summary text and send envelope to recipient code
      const encMsg = await encryptBodyForCode(code, summaryText);
      const codeHash = await sha256Hex(encMsg.normalizedPassphrase);

      const deliverAtLocalIso = deliverAtLocalIsoInMinutes(0);
      const userTimezone = getUserTimezone();
      const clientRequestId = randomClientRequestId("signed");

      const callable = functions.httpsCallable("sendSignedCiphertext");
      await callable({
        codeHash,
        ciphertext: encMsg.ciphertextB64,
        iv: encMsg.ivB64,
        salt: encMsg.saltB64,
        deliverAtLocalIso,
        userTimezone,
        clientRequestId,
        attachments
      });

      // clear session state
      stopPulseTimerUI({ silent: true });
    }

    btnPulseImage.addEventListener("click", async () => {
      const user = auth.currentUser;
      const file = sfImageFile.files && sfImageFile.files[0] ? sfImageFile.files[0] : null;
      const code = (signedCode.value || "").trim();

      if (!user) { setStatus("warn", "Sign-in required", "Sign in to send pulse images."); return; }
      if (signedMode !== "pulse") { setStatus("warn", "Choose Pulse", "Select Pulse to send pulse images."); return; }
      if (!code) { setStatus("warn", "Recipient code needed", "Paste a Secure/Personal code first."); return; }
      if (!file) { setStatus("warn", "No image", "Choose an image first."); return; }

      try {
        btnPulseImage.disabled = true;

        if (signedPulseType === "single") {
          setStatus("good", "Sending image…", "Encrypting + uploading…");
          await pulseImageSingleToSetfeed({ code, file });
          setStatus("good", "Sent", "Image sent to the recipient code.");
        } else {
          // multi: add image pulse into the running/created session
          setStatus("good", "Adding to session…", "Encrypting + uploading…");
          await pulseImageMultiAddToSession({ code, file });
          setStatus("good", "Added", "Image added. Finalize to send summary.");
        }
      } catch (e) {
        console.error(e);
        setStatus("warn", "Pulse image failed", (e && e.message) ? String(e.message) : "Try again.");
      } finally {
        btnPulseImage.disabled = false;
        refreshPulseImageEnabled();
      }
    });

    // Send handlers
    function refreshRollingSendEnabled() {
      const canSend = rollingCodeInput.value.trim().length > 0 && rollingBodyInput.value.trim().length > 0;
      btnRollingSend.disabled = !canSend;
    }

    btnSignedSend.addEventListener("click", async () => {
      const user = auth.currentUser;
      const ok = applyBodyGuardrails().signedOk;
      if (!ok) return;

      if (!user) { setStatus("warn", "Sign-in required", "Sign in (Email link or Google) to use Signed."); return; }

      // Pulse mode:
      if (signedMode === "pulse") {
        const code = (signedCode.value || "").trim();
        if (!code) { setStatus("warn", "Recipient code needed", "Paste a Secure/Personal code first."); return; }

        if (signedPulseType === "single") {
          setStatus("warn", "Single is instant", "Use “Pulse image” (for images) or “Encrypt and send” (for text) outside Pulse.");
          return;
        }

        // multi: if session exists and not running -> finalize; if no session -> start; if running -> do nothing
        try {
          btnSignedSend.disabled = true;

          if (!privatePulseSessionId) {
            setStatus("good", "Starting pulse…", "Creating a 2-minute summary session…");
            await ensurePrivatePulseSession({ code });
            setStatus("good", "Running", "Add pulses (text via message box + send later, images via Pulse image).");
            return;
          }

          if (pulseRunning) {
            setStatus("warn", "Pulse running", "Wait for the timer to end, then finalize.");
            return;
          }

          setStatus("good", "Finalizing…", "Generating summary and sending…");
          await finalizePrivatePulseAndSend({ code });
          setStatus("good", "Sent", "Summary delivered to the recipient code.");
        } catch (e) {
          console.error(e);
          setStatus("warn", "Pulse failed", (e && e.message) ? String(e.message) : "Try again.");
        } finally {
          applyBodyGuardrails();
          refreshPulseImageEnabled();
          updateSignedSendLabel();
        }

        return;
      }

      // Non-pulse: encrypted message scheduling
      const code = signedCode.value.trim();
      const body = signedBody.value.trim();
      if (!code || !body) { setStatus("warn", "Missing details", "Add a code and a message, then try again."); return; }

      try {
        setStatus("good", "Sending…", "Encrypting in your browser and scheduling delivery…");

        const enc = await encryptBodyForCode(code, body);
        const codeHash = await sha256Hex(enc.normalizedPassphrase);

        let deliverAtLocalIso;

        if (signedMode === "10m") deliverAtLocalIso = deliverAtLocalIsoInMinutes(10);
        else if (signedMode === "1h") deliverAtLocalIso = deliverAtLocalIsoInMinutes(60);
        else {
          // tomorrow / in1day / week (preset time)
          let days = 1;
          if (signedMode === "in1day") days = 2;  // distinct from “tomorrow”
          if (signedMode === "week") days = 7;
          deliverAtLocalIso = deliverAtLocalIsoInDaysAtPresetTime(days, signedPresetTime);
        }

        const userTimezone = getUserTimezone();
        const clientRequestId = randomClientRequestId("signed");

        const callable = functions.httpsCallable("sendSignedCiphertext");
        await callable({
          codeHash,
          ciphertext: enc.ciphertextB64,
          iv: enc.ivB64,
          salt: enc.saltB64,
          deliverAtLocalIso,
          userTimezone,
          clientRequestId
        });

        setStatus("good", "Scheduled", "Redirecting to Inbox…");
        window.location.href = "./inbox.html";
      } catch (e) {
        console.error(e);
        const msg = (e && e.message) ? e.message : "Something went wrong while scheduling. Try again.";
        setStatus("warn", "Couldn’t send", msg);
      }
    });

    btnRollingSend.addEventListener("click", async () => {
      const code = rollingCodeInput.value.trim();
      const body = rollingBodyInput.value.trim();
      const ok = applyBodyGuardrails().rollingOk;
      if (!ok) return;

      if (!code || !body) { setStatus("warn", "Missing details", "Add a rolling code and a message, then try again."); return; }

      try {
        setStatus("good", "Sending…", "Encrypting in your browser and scheduling delivery…");

        const enc = await encryptBodyForCode(code, body);
        const codeHash = await sha256Hex(enc.normalizedPassphrase);

        const deliverAtLocalIso = deliverAtLocalIsoInDaysAtPresetTime(1, rollingPresetTime);
        const userTimezone = getUserTimezone();
        const clientRequestId = randomClientRequestId("rolling");

        try {
          const provision = functions.httpsCallable("provisionRollingEnvelope");
          await provision({ codeHash });
        } catch (e) { console.warn("[Rolling] provision failed (continuing):", e); }

        const callable = functions.httpsCallable("sendRollingCiphertext");
        await callable({
          codeHash,
          ciphertext: enc.ciphertextB64,
          iv: enc.ivB64,
          salt: enc.saltB64,
          deliverAtLocalIso,
          userTimezone,
          clientRequestId
        });

        setStatus("good", "Scheduled", "Redirecting to Inbox…");
        window.location.href = "./inbox.html";
      } catch (e) {
        console.error(e);
        const c = e && e.code ? e.code : "";
        const msg = (e && e.message) ? e.message : "Something went wrong while scheduling. Try again.";
        setStatus("warn", "Couldn’t send", (c ? `${c}: ` : "") + msg);
      }
    });

    btnSignedClear.addEventListener("click", () => {
      signedCode.value = ""; signedBody.value = "";
      stopPulseTimerUI({ silent: true });
      applyBodyGuardrails();
      refreshPulseImageEnabled();
      setStatus("warn", "Cleared", "Signed fields cleared.");
    });
    btnRollingClear.addEventListener("click", () => {
      rollingCodeInput.value = ""; rollingBodyInput.value = "";
      refreshRollingSendEnabled();
      applyBodyGuardrails();
      setStatus("warn", "Cleared", "Rolling fields cleared.");
    });

    // Init
    refreshRollingSendEnabled();

    // Default pulse settings
    setSignedTimeHighlight();
    setPulseMinutesHighlight();
    setPulseTypeHighlight();
    setPulseNote();

    // Not authed yet -> keep UI calm and predictable
    setSignedMode("tomorrow");

    applyBodyGuardrails();
    refreshPulseImageEnabled();
    updateSignedSendLabel();
    setStatus("good", "Ready", "App Check is active. Encryption + sending are wired.");

    if (window.location.hash && window.location.hash.toLowerCase().includes("signin")) {
      userChoseTab = true;
      setTab("signed");
    }
  </script>
</body>
</html>
