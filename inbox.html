<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Inbox — Setfeed</title>
  <meta name="description" content="Your Setfeed inbox feed (signed-in view)." />

  <meta name="theme-color" content="#FFFBFE" id="meta-theme-color" />

  <link rel="icon" href="./favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="./favicon-32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="./favicon-16.png" sizes="16x16">
  <link rel="apple-touch-icon" href="./apple-touch-icon.png" sizes="180x180">

  <link rel="stylesheet" href="./styles.css" />

  <!-- FIREBASE (AUTH + FUNCTIONS + FIRESTORE) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCECKG-00tijJrt5qvRy3L27ZzE7bocNrU",
      authDomain: "setfeed-fcd7a.firebaseapp.com",
      projectId: "setfeed-fcd7a",
      storageBucket: "setfeed-fcd7a.firebasestorage.app",
      messagingSenderId: "553573263069",
      appId: "1:553573263069:web:e5c9884101ca38eaee1d34"
    };

    if (!firebase.apps || firebase.apps.length === 0) firebase.initializeApp(firebaseConfig);

    // Shared instances (consistent across pages)
    window.sfFunctions = firebase.app().functions("europe-west2");
    window.sfAuth = firebase.auth();
    window.sfDb = firebase.firestore();
    window.sfAuth.setPersistence(firebase.auth.Auth.Persistence.LOCAL).catch(() => {});
  </script>

  <!-- THEME -->
  <script>
    (function(){
      const THEME_KEY = "sf_theme_mode";
      const root = document.documentElement;

      function applyTheme(){
        let stored = "system";
        try { stored = localStorage.getItem(THEME_KEY) || "system"; } catch (_) {}

        if (stored === "light" || stored === "dark") root.setAttribute("data-theme", stored);
        else root.removeAttribute("data-theme");

        const effective =
          root.getAttribute("data-theme") ||
          (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");

        const meta = document.getElementById("meta-theme-color");
        if (meta) meta.content = (effective === "dark") ? "#0F1114" : "#FFFBFE";
      }

      applyTheme();
      window.addEventListener("storage", (e) => { if (e && e.key === THEME_KEY) applyTheme(); });
    })();
  </script>

  <style>
    .hidden{ display:none !important; }
    body{ overflow-x:hidden; }

    /* Route container */
    .sf-route { display:none; }
    .sf-route.show { display:block; }

    /* ✅ Inbox tip banner (what Consume means) */
    .sf-tipbar{
      margin-top: 12px;
      border-radius: 16px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 12%, transparent);
      padding: 10px 12px;
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 10px;
    }
    .sf-tipbar strong{ color: var(--text); }
    .sf-tipbar p{
      margin: 0;
      color: var(--muted);
      font-size: 13.6px;
      line-height: 1.45;
    }
    .sf-tipbar .btn{
      flex: 0 0 auto;
      padding: 9px 12px;
      font-size: 13.2px;
    }

    /* ✅ Codebar alignment: input + buttons in one row */
    .sf-codebar{
      display:flex;
      gap: 10px;
      align-items: flex-end;
      flex-wrap: wrap;
      margin-top: var(--s-4);
    }
    .sf-codebar .sf-codecol{
      flex: 1 1 360px;
      min-width: 240px;
    }
    .sf-codebar .sf-btncol{
      display:flex;
      gap: 10px;
      flex: 0 0 auto;
      flex-wrap: wrap;
      align-items:center;
      justify-content:flex-start;
    }
    .sf-codebar .btn{
      min-height: 42px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      line-height: 1;
      padding-top: 0;
      padding-bottom: 0;
    }

    .sf-mini-row{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content: space-between;
      margin-top: 10px;
    }

    .sf-toggle{
      appearance: none;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 10%, transparent);
      color: var(--text);
      border-radius: 14px;
      padding: 8px 10px;
      font-weight: 650;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:10px;
      min-height: 40px;
    }
    .sf-toggle:hover{ background: color-mix(in srgb, var(--surface-variant) 16%, transparent); }
    .sf-toggle:active{ transform: translateY(0.5px); }

    /* ✅ Top-right toggle placement */
    .sf-inbox-topbar{
      display:flex;
      align-items:center;
      justify-content: flex-end;
      margin-top: 10px;
      margin-bottom: -6px;
    }

    /* Section header */
    .sf-section-head{
      display:flex;
      align-items:baseline;
      justify-content: space-between;
      gap: 10px;
      margin-top: var(--s-5);
      margin-bottom: var(--s-3);
    }
    .sf-section-head h2{ margin:0; color: var(--text); }
    .sf-pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      border-radius: 999px;
      padding: 6px 10px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 10%, transparent);
      color: var(--text);
      font-weight: 650;
      font-size: 12px;
      white-space: nowrap;
    }

    /* Cards (theme-variable based — fixes light mode invisibility) */
    .sf-msg-card{
      border-radius: 18px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 9%, transparent);
      padding: 12px;
      margin-bottom: 10px;
      position: relative;
      overflow:hidden;
      touch-action: pan-y;
      user-select:none;
    }
    .sf-msg-top{
      display:flex;
      justify-content: space-between;
      gap:10px;
      align-items:flex-start;
    }
    .sf-msg-title{
      font-weight: 750;
      letter-spacing: -0.01em;
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      min-width: 0;
      color: var(--text);
    }
    .sf-msg-title-text{
      min-width: 0;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 44ch;
    }
    .sf-msg-meta{
      display:flex;
      flex-direction: column;
      gap: 2px;
      text-align:right;
      font-size: 12px;
      color: var(--soft);
    }
    .sf-msg-body{
      margin-top: 8px;
      color: var(--muted);
      line-height: 1.35;
      font-size: 14px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .sf-msg-actions{
      margin-top: 10px;
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items:center;
    }

    /* ✅ Surprise rule: NO thumbnails in the list */
    .sf-attach-count{
      margin-top: 10px;
      display:flex;
      align-items:center;
      gap: 10px;
      color: var(--soft);
      font-size: 12.5px;
    }
    .sf-attach-count .dot{
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--primary) 55%, var(--soft));
    }

    /* Swipe affordance */
    .sf-swipe-bg{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content: space-between;
      padding: 0 14px;
      pointer-events:none;
      opacity: 0;
      transition: opacity 120ms ease;
    }
    .sf-swipe-bg.show{ opacity: 1; }
    .sf-swipe-left, .sf-swipe-right{
      font-weight: 800;
      font-size: 12px;
      letter-spacing: 0.02em;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 14%, transparent);
      color: var(--text);
    }
    .sf-swipe-right{
      border-color: color-mix(in srgb, var(--primary) 30%, var(--line));
      box-shadow: 0 0 0 4px color-mix(in srgb, var(--primary) 12%, transparent);
    }
    .sf-drag{
      position: relative;
      transform: translateX(0);
      transition: transform 140ms ease;
      will-change: transform;
    }

    /* Kind pill */
    .sf-kind{
      display:inline-flex;
      align-items:center;
      gap:6px;
      border-radius: 999px;
      padding: 4px 8px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 12%, transparent);
      color: var(--text);
      font-weight: 800;
      font-size: 11px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    .sf-kind.delvee{
      border-color: color-mix(in srgb, var(--primary) 30%, var(--line));
      box-shadow: 0 0 0 4px color-mix(in srgb, var(--primary) 10%, transparent);
    }

    /* ✅ Modals hidden by default */
    .delvee-backdrop,
    .sf-modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 9999;
    }
    .delvee-backdrop.show,
    .sf-modal-backdrop.show{ display:flex; }

    .delvee-modal{
      width: min(560px, 100%);
      border-radius: 18px;
      background: color-mix(in srgb, var(--surface-2) 92%, transparent);
      color: var(--text);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      border: 1px solid var(--line);
      overflow: hidden;
      max-height: calc(100vh - 32px);
      display:flex;
      flex-direction: column;
    }
    .delvee-head{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      padding: 14px 14px 10px 14px;
      flex: 0 0 auto;
    }
    .delvee-title{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight: 800;
      letter-spacing: -0.01em;
      color: var(--text);
    }
    .delvee-badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius: 999px;
      padding: 4px 8px;
      border: 1px solid color-mix(in srgb, var(--primary) 30%, var(--line));
      box-shadow: 0 0 0 4px color-mix(in srgb, var(--primary) 10%, transparent);
      background: color-mix(in srgb, var(--primary) 10%, transparent);
      font-size: 12px;
      font-weight: 850;
      color: var(--text);
    }

    /* ✅ Make modal body scrollable */
    .delvee-body{
      padding: 0 14px 12px 14px;
      flex: 1 1 auto;
      overflow: auto;
    }

    .delvee-stage{
      border-radius: 16px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 10%, transparent);
      padding: 14px;
      position: relative;
      overflow:hidden;
      min-height: 160px;
    }

    /* ✅ Inline images inside summary text */
    .sf-inline-img{
      width: 100%;
      max-height: 520px;
      border-radius: 16px;
      border: 1px solid var(--line);
      object-fit: contain;
      display:block;
      margin: 10px 0;
      background: color-mix(in srgb, var(--surface-variant) 10%, transparent);
    }

    /* ✅ Opening animation (blue lightning sweep) */
    .sf-vault-overlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity: 0;
      transition: opacity 180ms ease;
    }
    .delvee-stage.is-playing .sf-vault-overlay{ opacity: 1; }

    .sf-vault-bolt{
      position:absolute;
      top: -30%;
      left: -60%;
      width: 70%;
      height: 160%;
      transform: rotate(12deg);
      background: linear-gradient(90deg,
        transparent 0%,
        color-mix(in srgb, var(--primary) 0%, transparent) 35%,
        color-mix(in srgb, var(--primary) 95%, white) 50%,
        color-mix(in srgb, var(--primary) 0%, transparent) 65%,
        transparent 100%);
      filter: blur(1px);
      opacity: 0.95;
      animation: sfBoltSweep 920ms ease-in-out infinite;
      mix-blend-mode: screen;
    }
    .sf-vault-noise{
      position:absolute;
      inset:0;
      background:
        radial-gradient(900px 420px at 30% 10%,
          color-mix(in srgb, var(--primary) 10%, transparent) 0%,
          transparent 60%),
        radial-gradient(700px 420px at 80% 30%,
          rgba(255,255,255,0.06) 0%,
          transparent 62%),
        linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));
      opacity: 0.8;
    }
    @keyframes sfBoltSweep{
      0%   { transform: translateX(0) rotate(12deg); opacity: 0.0; }
      10%  { opacity: 0.95; }
      50%  { transform: translateX(220%) rotate(12deg); opacity: 0.95; }
      100% { transform: translateX(260%) rotate(12deg); opacity: 0.0; }
    }

    .delvee-reveal{ display:none; }
    .delvee-stage.is-revealed .delvee-reveal{ display:block; }
    .delvee-stage.is-revealed .sf-vault-overlay{ opacity: 0; }

    /* Attachments in modal (OK after opening — surprise preserved) */
    .delvee-attachments{
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--line);
    }
    .delvee-attachments h4{
      margin: 0 0 10px 0;
      font-size: 13px;
      color: var(--text);
      letter-spacing: -0.01em;
    }
    .delvee-thumb-grid{
      display:flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items:center;
    }
    .sf-thumb{
      width: 84px;
      height: 84px;
      border-radius: 16px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 10%, transparent);
      object-fit: cover;
      cursor: pointer;
      box-shadow: 0 10px 24px rgba(0,0,0,0.18);
    }
    .sf-thumb:active{ transform: translateY(0.5px); }
    .sf-thumb-skel{
      width: 84px;
      height: 84px;
      border-radius: 16px;
      border: 1px solid var(--line);
      background: color-mix(in srgb, var(--surface-variant) 10%, transparent);
      display:flex;
      align-items:center;
      justify-content:center;
      color: var(--soft);
      font-size: 12px;
    }

    .delvee-actions{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      padding: 12px 14px 14px 14px;
      border-top: 1px solid var(--line);
      flex: 0 0 auto;
    }

    /* Actions modal */
    .sf-modal{
      width: min(520px, 100%);
      border-radius: 16px;
      background: color-mix(in srgb, var(--surface-2) 92%, transparent);
      color: var(--text);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      border: 1px solid var(--line);
      overflow: hidden;
    }
    .sf-modal-header{
      padding: 16px 16px 10px 16px;
      font-weight: 800;
      font-size: 16px;
      color: var(--text);
    }
    .sf-modal-body{
      padding: 0 16px 16px 16px;
      color: var(--muted);
      line-height: 1.35;
      font-size: 14px;
      word-break: break-word;
    }
    .sf-modal-actions{
      display:flex;
      flex-wrap: wrap;
      justify-content: flex-end;
      gap: 10px;
      padding: 12px 16px 16px 16px;
      border-top: 1px solid var(--line);
    }
    .sf-modal-btn{
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 750;
      cursor:pointer;
      background: color-mix(in srgb, var(--surface-variant) 10%, transparent);
      color: var(--text);
    }
    .sf-modal-btn-primary{ background: var(--primary); color: var(--on-primary); border-color: color-mix(in srgb, var(--primary) 58%, var(--line)); }
    .sf-modal-btn-danger{ background: color-mix(in srgb, #ff5555 16%, transparent); color: color-mix(in srgb, var(--text) 92%, #ffcccc); border-color: color-mix(in srgb, #ff5555 28%, var(--line)); }
    .sf-modal-btn-quiet{ background: color-mix(in srgb, var(--surface-variant) 8%, transparent); color: var(--text); }

    /* ✅ Make empty Upcoming/Awaiting vertically smaller (so Released shows without scroll when empty) */
    #list-upcoming .panel,
    #list-awaiting .panel{
      padding: 14px;
    }
    #list-upcoming .panel-sub,
    #list-awaiting .panel-sub{
      margin-bottom: 10px;
    }
    #list-upcoming small.help,
    #list-awaiting small.help{
      margin-top: 6px;
      font-size: 12.8px;
    }
    /* Also reduce section head spacing a touch */
    #pill-upcoming, #pill-awaiting { transform: translateY(-1px); }
  </style>
</head>

<body class="page-bg">
  <header class="site-header">
    <div class="header-inner">
      <a class="brand-mark" href="./" aria-label="Setfeed home">
        <img class="logo" src="./logo.png" alt="" aria-hidden="true" />
      </a>

      <a class="brand-title" href="./">Setfeed</a>

      <nav class="nav" aria-label="Primary">
        <a href="./">Home</a>
        <a href="./send.html">Send</a>
        <a href="./receive.html">Receive</a>
        <a class="auth-only hidden" href="./inbox.html" aria-current="page">Inbox</a>
        <a class="auth-only hidden" id="nav-hidden" href="./inbox.html#hidden">Hidden</a>
        <a href="./security.html">Security</a>
        <a href="./privacy.html">Privacy</a>
        <a class="nav-cta" href="https://delvee.app" rel="noreferrer" aria-label="Open Delvee">Open Delvee</a>
      </nav>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <h1>Inbox</h1>

      <div class="status" role="status" aria-live="polite" id="status-bar">
        <div class="status-title">
          <span class="dot" id="status-dot"></span>
          <span id="status-title">Ready</span>
        </div>
        <p class="status-line" id="status-line">Sign in to fetch signed inbox messages.</p>
      </div>

      <!-- ✅ Tip about Consume -->
      <div class="sf-tipbar hidden" id="consume-tip" role="note" aria-live="polite">
        <p>
          <strong>Consume</strong> permanently marks a message as used on the server — it will stop appearing on future fetches
          (and is removed from this device’s lists too).
        </p>
        <button class="btn btn-quiet" id="consume-tip-dismiss" type="button">Got it</button>
      </div>

      <!-- ROUTES -->
      <div id="route-inbox" class="sf-route show">
        <div id="inbox-ui" class="hidden">

          <div class="sf-inbox-topbar">
            <button class="sf-toggle" id="btn-show-blocked" type="button">
              <span id="blocked-label">Hidden senders: Hidden</span>
            </button>
          </div>

          <div class="sf-codebar" aria-label="Inbox code and actions">
            <div class="sf-codecol">
              <div class="field" style="margin:0;">
                <label for="code-input">Secure or Personal code</label>
                <input id="code-input" type="text" inputmode="text" placeholder="Paste SF-… or SFS-…" />
              </div>
            </div>

            <div class="sf-btncol" role="group" aria-label="Fetch actions">
              <button class="btn btn-primary" id="btn-fetch" type="button">Fetch</button>
              <button class="btn btn-secondary" id="btn-fetch-summaries" type="button">Fetch summaries</button>
              <button class="btn btn-quiet" id="btn-clear" type="button">Clear</button>
              <span class="kbd" id="count-pill">0 messages</span>
            </div>
          </div>

          <div class="sf-mini-row">
            <button class="sf-toggle" id="btn-auto" type="button">
              <span id="auto-label">Auto polling: Off</span>
            </button>

            <button class="sf-toggle" id="btn-summaries-only" type="button">
              <span id="summaries-label">Show: All</span>
            </button>
          </div>

          <!-- PINNED -->
          <div class="sf-section-head" id="head-pinned" style="display:none;">
            <h2>Pinned</h2>
            <span class="sf-pill" id="pill-pinned">0</span>
          </div>
          <div id="list-pinned"></div>

          <!-- UPCOMING -->
          <div class="sf-section-head">
            <h2>Upcoming</h2>
            <span class="sf-pill" id="pill-upcoming">0</span>
          </div>
          <div id="list-upcoming"></div>

          <!-- AWAITING -->
          <div class="sf-section-head">
            <h2>Awaiting</h2>
            <span class="sf-pill" id="pill-awaiting">0</span>
          </div>
          <div id="list-awaiting"></div>

          <!-- RELEASED -->
          <div class="sf-section-head">
            <h2>Released</h2>
            <span class="sf-pill" id="pill-released">0</span>
          </div>
          <div id="list-released"></div>

          <div class="panel" style="margin-top: var(--s-6);">
            <p class="panel-title">How it works</p>
            <p class="panel-sub">
              Swipe right on <strong>Upcoming</strong> → mark <strong>Awaiting</strong> (best-effort browser notifications).<br/>
              Swipe left on <strong>Upcoming</strong> → hide it until release.<br/>
              Long-press a <strong>Released</strong> message → pin / hide sender / hide message.
            </p>
            <small class="help">
              Hidden senders filter applies everywhere (Pinned/Upcoming/Awaiting/Released).<br/>
              <strong>Delvee summaries:</strong> Open will load images from your Delvee docs (prefers account inbox; falls back to delivery job).<br/>
              <strong>Important:</strong> If Delvee images were uploaded without iv/salt metadata, this inbox will still show them (treated as plaintext bytes).
            </small>
          </div>
        </div>
      </div>

      <div id="route-hidden" class="sf-route">
        <div id="hidden-ui" class="hidden">
          <h2 style="margin-top: var(--s-4);">Hidden messages</h2>
          <p class="lead">Hidden messages don’t show in Inbox. You can restore them here.</p>

          <div class="actions" style="justify-content: space-between; flex-wrap: wrap;">
            <div style="display:flex; gap:10px; flex-wrap: wrap;">
              <button class="btn btn-quiet" id="btn-hidden-back" type="button">Back to Inbox</button>
              <button class="btn btn-secondary" id="btn-hidden-clearall" type="button">Clear hidden</button>
            </div>
            <span class="kbd" id="pill-hidden">0 hidden</span>
          </div>

          <div id="list-hidden" style="margin-top: 10px;"></div>

          <small class="help" style="margin-top: 10px;">Hidden items are stored locally in this browser only.</small>
        </div>
      </div>

      <div class="panel" style="margin-top: var(--s-6);">
        <p class="panel-title">Sign in</p>
        <p class="panel-sub">Signed inbox requires sign-in.</p>

        <div class="actions">
          <button class="btn btn-lg btn-primary" id="btn-google" type="button">Continue with Google</button>
          <button class="btn btn-lg btn-quiet" id="btn-sign-out" type="button" disabled>Sign out</button>
          <span class="kbd" id="auth-pill">Not signed in</span>
        </div>

        <small class="help">Fetch is read-only. Consume is explicit.</small>
      </div>

      <footer>
        <div>© <span id="y"></span> Setfeed</div>
        <div>
          <a href="./security.html">Security</a>
          <span class="sep">·</span>
          <a href="./privacy.html">Privacy</a>
          <span class="sep">·</span>
          <a href="mailto:security@setfeed.app">security@setfeed.app</a>
        </div>
      </footer>
    </div>
  </div>

  <!-- Opening modal -->
  <div class="delvee-backdrop" id="delvee-modal" role="dialog" aria-modal="true" aria-labelledby="delvee-title">
    <div class="delvee-modal">
      <div class="delvee-head">
        <div class="delvee-title" id="delvee-title">
          <span class="delvee-badge">Setfeed</span>
          <span id="delvee-who">Opening…</span>
        </div>
        <button class="btn btn-quiet" id="delvee-close" type="button">Close</button>
      </div>

      <div class="delvee-body">
        <div class="delvee-stage" id="delvee-stage">
          <!-- overlay used during animation -->
          <div class="sf-vault-overlay" aria-hidden="true">
            <div class="sf-vault-noise"></div>
            <div class="sf-vault-bolt"></div>
          </div>

          <div class="delvee-reveal" id="delvee-reveal">
            <h3 style="margin-top:0; color: var(--text);" id="delvee-heading">Message</h3>

            <!-- ✅ changed from <p> to <div> so we can inject inline images -->
            <div id="delvee-text" style="color: var(--muted); white-space: pre-wrap; margin: 0;"></div>

            <div class="delvee-attachments hidden" id="delvee-attachments">
              <h4 id="delvee-attachments-title">Images</h4>
              <div class="delvee-thumb-grid" id="delvee-thumb-grid"></div>
              <div class="actions" id="delvee-attach-actions" style="margin-top: 10px; justify-content:flex-start;"></div>
            </div>

            <small class="help" style="margin-top:10px;">Decryption is local in your browser.</small>
          </div>
        </div>
      </div>

      <div class="delvee-actions">
        <button class="btn btn-secondary" id="delvee-consume" type="button">Consume</button>
        <button class="btn btn-primary" id="delvee-ok" type="button">Done</button>
      </div>
    </div>
  </div>

  <!-- Context menu modal (Released only) -->
  <div class="sf-modal-backdrop" id="sf-actions-modal" role="dialog" aria-modal="true" aria-labelledby="sf-actions-title" aria-describedby="sf-actions-body">
    <div class="sf-modal">
      <div class="sf-modal-header" id="sf-actions-title">Message options</div>
      <div class="sf-modal-body" id="sf-actions-body">
        <div id="sf-actions-meta" style="font-size:12px; color: var(--soft); margin-bottom: 10px;"></div>
        <div id="sf-actions-preview" style="white-space: pre-wrap; color: var(--muted);"></div>
      </div>
      <div class="sf-modal-actions">
        <button class="sf-modal-btn" id="sf-btn-pin" type="button">Pin</button>
        <button class="sf-modal-btn" id="sf-btn-hide-msg" type="button">Hide message</button>
        <button class="sf-modal-btn" id="sf-btn-block-sender" type="button">Hide sender</button>
        <button class="sf-modal-btn sf-modal-btn-danger" id="sf-btn-consume" type="button">Consume</button>
        <button class="sf-modal-btn sf-modal-btn-primary" id="sf-btn-done" type="button">Done</button>
      </div>
    </div>
  </div>

  <script>
    document.getElementById("y").textContent = new Date().getFullYear();

    const auth = window.sfAuth;
    const functions = window.sfFunctions;
    const db = window.sfDb;

    // ✅ Redirect completion handler
    auth.getRedirectResult().catch((e) => {
      console.error(e);
      const code = (e && e.code) ? String(e.code) : "";
      if (code === "auth/unauthorized-domain") {
        setStatus("warn", "Auth domain not authorized", "Add this domain in Firebase Auth → Settings → Authorized domains.");
      } else if (code) {
        setStatus("warn", "Sign-in failed", code);
      }
    });

    // -------------------------
    // Status helper
    // -------------------------
    const statusDot = document.getElementById("status-dot");
    const statusTitle = document.getElementById("status-title");
    const statusLine = document.getElementById("status-line");

    function setStatus(kind, title, line) {
      statusDot.className = "dot";
      if (kind === "good") statusDot.classList.add("good");
      if (kind === "warn") statusDot.classList.add("warn");
      statusTitle.textContent = title;
      statusLine.textContent = line;
    }

    // -------------------------
    // Consume tip
    // -------------------------
    const consumeTip = document.getElementById("consume-tip");
    const consumeTipDismiss = document.getElementById("consume-tip-dismiss");
    const LS_TIP = "sf_inbox_consume_tip_dismissed";

    function showConsumeTipIfNeeded(){
      let dismissed = false;
      try { dismissed = localStorage.getItem(LS_TIP) === "true"; } catch (_) {}
      if (!dismissed && consumeTip) consumeTip.classList.remove("hidden");
    }
    if (consumeTipDismiss) {
      consumeTipDismiss.addEventListener("click", () => {
        try { localStorage.setItem(LS_TIP, "true"); } catch (_) {}
        if (consumeTip) consumeTip.classList.add("hidden");
      });
    }

    // -------------------------
    // Routes
    // -------------------------
    const routeInbox = document.getElementById("route-inbox");
    const routeHidden = document.getElementById("route-hidden");
    const hiddenUi = document.getElementById("hidden-ui");
    const inboxUi = document.getElementById("inbox-ui");
    const navHidden = document.getElementById("nav-hidden");

    function showRoute(which){
      const isHidden = which === "hidden";
      routeInbox.classList.toggle("show", !isHidden);
      routeHidden.classList.toggle("show", isHidden);

      hiddenUi.classList.toggle("hidden", !(auth.currentUser));
      inboxUi.classList.toggle("hidden", !(auth.currentUser) || isHidden);
    }
    function currentRoute(){
      return (window.location.hash || "").toLowerCase().includes("hidden") ? "hidden" : "inbox";
    }
    window.addEventListener("hashchange", () => showRoute(currentRoute()));

    // -------------------------
    // Auth
    // -------------------------
    const AUTH_KEY = "sf_signed_authed";

    const btnGoogle = document.getElementById("btn-google");
    const btnSignOut = document.getElementById("btn-sign-out");
    const authPill = document.getElementById("auth-pill");

    function setSignedAuthedFlag(isAuthed) {
      try { localStorage.setItem(AUTH_KEY, isAuthed ? "true" : "false"); } catch (_) {}
      document.querySelectorAll(".auth-only").forEach(el => el.classList.toggle("hidden", !isAuthed));
    }

    function renderAuthUI(user){
      const isAuthed = !!user;
      setSignedAuthedFlag(isAuthed);

      btnGoogle.classList.toggle("hidden", isAuthed);
      btnSignOut.disabled = !isAuthed;
      authPill.textContent = isAuthed ? (user.email || "Signed in") : "Not signed in";

      if (navHidden) navHidden.classList.toggle("hidden", !isAuthed);

      showRoute(currentRoute());

      if (isAuthed) {
        setStatus("good", "Signed in", "Paste a Secure/Personal code and press Fetch.");
        showConsumeTipIfNeeded();
      } else {
        setStatus("warn", "Not signed in", "Sign in to fetch signed inbox messages.");
        if (consumeTip) consumeTip.classList.add("hidden");
      }
    }

    auth.onAuthStateChanged((user) => renderAuthUI(user));

    btnGoogle.addEventListener("click", async () => {
      try {
        setStatus("good", "Signing in…", "Opening Google sign-in…");
        const provider = new firebase.auth.GoogleAuthProvider();
        provider.setCustomParameters({ prompt: "select_account" });
        await auth.signInWithRedirect(provider);
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t sign in", "Google sign-in failed. Check Firebase Auth settings.");
      }
    });

    btnSignOut.addEventListener("click", async () => {
      try {
        await auth.signOut();
        setStatus("warn", "Signed out", "Sign in again to fetch signed inbox messages.");
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t sign out", "Try again.");
      }
    });

    // -------------------------
    // Local state (device-only)
    // -------------------------
    const LS = {
      awaitingIds: "sf_inbox_awaiting_ids",
      hiddenUpcomingIds: "sf_inbox_hidden_upcoming",
      hiddenReleasedIds: "sf_inbox_hidden_released",
      pinnedIds: "sf_inbox_pinned_ids",
      blockedSenders: "sf_inbox_blocked_senders",
      showBlocked: "sf_inbox_show_blocked",
      autoPolling: "sf_inbox_auto_polling"
    };

    function readJson(key, fallback){
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return fallback;
        return JSON.parse(raw);
      } catch (_) {
        return fallback;
      }
    }
    function writeJson(key, value){
      try { localStorage.setItem(key, JSON.stringify(value)); } catch (_) {}
    }

    function uniq(arr){
      const out = [];
      const seen = new Set();
      for (const x of arr || []) {
        if (!x) continue;
        if (seen.has(x)) continue;
        seen.add(x);
        out.push(x);
      }
      return out;
    }

    function getAwaitingIds(){ return uniq(readJson(LS.awaitingIds, [])); }
    function setAwaitingIds(v){ writeJson(LS.awaitingIds, uniq(v)); }

    function getHiddenUpcomingIds(){ return uniq(readJson(LS.hiddenUpcomingIds, [])); }
    function setHiddenUpcomingIds(v){ writeJson(LS.hiddenUpcomingIds, uniq(v)); }

    function getHiddenReleasedIds(){ return uniq(readJson(LS.hiddenReleasedIds, [])); }
    function setHiddenReleasedIds(v){ writeJson(LS.hiddenReleasedIds, uniq(v)); }

    function getPinnedIds(){ return uniq(readJson(LS.pinnedIds, [])); }
    function setPinnedIds(v){ writeJson(LS.pinnedIds, uniq(v)); }

    function getBlockedSenders(){ return uniq(readJson(LS.blockedSenders, [])); }
    function setBlockedSenders(v){ writeJson(LS.blockedSenders, uniq(v)); }

    function getShowBlocked(){
      try { return (localStorage.getItem(LS.showBlocked) === "true"); } catch (_) { return false; }
    }
    function setShowBlocked(v){
      try { localStorage.setItem(LS.showBlocked, v ? "true" : "false"); } catch (_) {}
    }

    function getAutoPolling(){
      try { return (localStorage.getItem(LS.autoPolling) === "true"); } catch (_) { return false; }
    }
    function setAutoPolling(v){
      try { localStorage.setItem(LS.autoPolling, v ? "true" : "false"); } catch (_) {}
    }

    function refreshHiddenNav(){
      const hiddenCount = getHiddenReleasedIds().length;
      const pillHidden = document.getElementById("pill-hidden");
      if (pillHidden) pillHidden.textContent = `${hiddenCount} hidden`;
    }

    // -------------------------
    // Message kind detection
    // -------------------------
    function detectKindFromPlaintext(pt){
      const s = (pt || "").trim();
      if (s.startsWith("Delvee — pulse summary") || s.startsWith("Setfeed — private pulse summary")) {
        return { kind: "delvee_summary", label: "Delvee Summary", pillText: "Delvee", pillCls: "delvee" };
      }
      return { kind: "generic", label: "Message", pillText: "", pillCls: "" };
    }

    // -------------------------
    // Crypto helpers (WebCrypto)
    // -------------------------
    function normalizeCodeAndroid(raw) { return raw.trim().toUpperCase().replace(/[\s-]/g, ""); }

    function b64ToBytes(b64) {
      const bin = atob(b64);
      const out = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
      return out;
    }

    function bytesToB64(bytes) {
      const u8 = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes);
      let bin = "";
      for (let i = 0; i < u8.length; i++) bin += String.fromCharCode(u8[i]);
      return btoa(bin);
    }

    async function sha256Hex(str) {
      const data = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function deriveAesKeyFromPassphrase(passphrase, saltBytes, usage) {
      const passBytes = new TextEncoder().encode(passphrase);
      const baseKey = await crypto.subtle.importKey("raw", passBytes, { name: "PBKDF2" }, false, ["deriveKey"]);
      const keyUsages = usage === "encrypt" ? ["encrypt"] : ["decrypt"];
      return await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: saltBytes, iterations: 100000, hash: "SHA-256" },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        keyUsages
      );
    }

    async function decryptEnvelopeForCode(rawCode, ciphertextB64, ivB64, saltB64) {
      try {
        const passphrase = normalizeCodeAndroid(rawCode);
        const salt = b64ToBytes(saltB64);
        const iv = b64ToBytes(ivB64);
        const ct = b64ToBytes(ciphertextB64);
        const key = await deriveAesKeyFromPassphrase(passphrase, salt, "decrypt");
        const pt = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
        return new TextDecoder().decode(pt);
      } catch (_) {
        return null;
      }
    }

    async function decryptAttachmentBytesForCode(rawCode, encryptedBytes, ivB64, saltB64) {
      const passphrase = normalizeCodeAndroid(rawCode);
      const salt = b64ToBytes(saltB64);
      const iv = b64ToBytes(ivB64);
      const key = await deriveAesKeyFromPassphrase(passphrase, salt, "decrypt");
      const pt = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, encryptedBytes);
      return new Uint8Array(pt);
    }

    async function encryptTextForCode(rawCode, plaintext) {
      const passphrase = normalizeCodeAndroid(rawCode);
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveAesKeyFromPassphrase(passphrase, salt, "encrypt");
      const ptBytes = new TextEncoder().encode(String(plaintext || ""));
      const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, ptBytes);
      return {
        ciphertextB64: bytesToB64(new Uint8Array(ct)),
        ivB64: bytesToB64(iv),
        saltB64: bytesToB64(salt),
      };
    }

    // -------------------------
    // Time formatting
    // -------------------------
    function formatLocal(deliverAtUtc, deliverAtLocalIso) {
      const src = deliverAtLocalIso || deliverAtUtc;
      if (!src) return "—";
      try {
        const d = new Date(src);
        if (Number.isNaN(d.getTime())) return "—";
        return d.toLocaleString(undefined, { weekday:"short", month:"short", day:"numeric", hour:"numeric", minute:"2-digit" });
      } catch (_) { return "—"; }
    }

    function parseDeliverMillis(deliverAtUtc, deliverAtLocalIso){
      const src = deliverAtLocalIso || deliverAtUtc;
      if (!src) return null;
      const d = new Date(src);
      const t = d.getTime();
      return Number.isFinite(t) ? t : null;
    }

    function nowWithOffsetIso() {
      // ISO string WITH local offset, e.g. 2026-02-22T12:34:56+00:00
      const d = new Date();
      const pad = (n) => String(Math.abs(n)).padStart(2, "0");
      const offMin = -d.getTimezoneOffset();
      const sign = offMin >= 0 ? "+" : "-";
      const hh = pad(Math.floor(Math.abs(offMin) / 60));
      const mm = pad(Math.abs(offMin) % 60);
      const yyyy = d.getFullYear();
      const mo = pad(d.getMonth() + 1);
      const da = pad(d.getDate());
      const h = pad(d.getHours());
      const m = pad(d.getMinutes());
      const s = pad(d.getSeconds());
      return `${yyyy}-${mo}-${da}T${h}:${m}:${s}${sign}${hh}:${mm}`;
    }

    function safeText(s) {
      const v = (s == null) ? "" : String(s);
      return v.replace(/[&<>"']/g, (c) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    }

    // -------------------------
    // UI elements
    // -------------------------
    const codeInput = document.getElementById("code-input");
    const btnFetch = document.getElementById("btn-fetch");
    const btnFetchSummaries = document.getElementById("btn-fetch-summaries");
    const btnClear = document.getElementById("btn-clear");
    const countPill = document.getElementById("count-pill");

    const btnAuto = document.getElementById("btn-auto");
    const autoLabel = document.getElementById("auto-label");

    const btnShowBlocked = document.getElementById("btn-show-blocked");
    const blockedLabel = document.getElementById("blocked-label");

    const btnSummariesOnly = document.getElementById("btn-summaries-only");
    const summariesLabel = document.getElementById("summaries-label");

    const listPinned = document.getElementById("list-pinned");
    const listUpcoming = document.getElementById("list-upcoming");
    const listAwaiting = document.getElementById("list-awaiting");
    const listReleased = document.getElementById("list-released");

    const pillPinned = document.getElementById("pill-pinned");
    const pillUpcoming = document.getElementById("pill-upcoming");
    const pillAwaiting = document.getElementById("pill-awaiting");
    const pillReleased = document.getElementById("pill-released");
    const headPinned = document.getElementById("head-pinned");

    const listHidden = document.getElementById("list-hidden");
    const btnHiddenBack = document.getElementById("btn-hidden-back");
    const btnHiddenClearAll = document.getElementById("btn-hidden-clearall");

    btnHiddenBack.addEventListener("click", () => { window.location.hash = ""; });
    btnHiddenClearAll.addEventListener("click", () => {
      setHiddenReleasedIds([]);
      refreshHiddenNav();
      renderHidden();
      setStatus("warn", "Cleared", "Hidden list cleared on this device.");
    });

    (function prefillFromUrl(){
      try{
        const u = new URL(window.location.href);
        const c = u.searchParams.get("code");
        if (c && codeInput) codeInput.value = c;
      } catch(_) {}
    })();

    // -------------------------
    // Attachments (signed URLs + decrypt + caching)
    // -------------------------
    let lastFetchedCode = "";
    const attachmentUrlCache = new Map(); // key -> objectUrl
    const attachmentBusy = new Set(); // key

    function cacheKey(envelopeId, attachmentId){ return `${envelopeId}::${attachmentId}`; }

    function revokeAllAttachmentUrls(){
      for (const url of attachmentUrlCache.values()) {
        try { URL.revokeObjectURL(url); } catch (_) {}
      }
      attachmentUrlCache.clear();
      attachmentBusy.clear();
    }

    function normalizeAttachments(raw){
      const arr = Array.isArray(raw) ? raw : [];
      return arr
        .map((a) => (a || {}))
        .map((a) => ({
          attachmentId: (typeof a.attachmentId === "string") ? a.attachmentId : null,
          contentType: (typeof a.contentType === "string") ? a.contentType : null,
          sizeBytes: (typeof a.sizeBytes === "number") ? a.sizeBytes : null,
          ivB64: (typeof a.ivB64 === "string") ? a.ivB64 : null,
          saltB64: (typeof a.saltB64 === "string") ? a.saltB64 : null,
        }))
        .filter((a) => a.attachmentId && a.contentType && a.ivB64 && a.saltB64);
    }

    async function openSignedAttachmentAsObjectUrl({ rawCode, signedEnvelopeId, attachment }) {
      const k = cacheKey(signedEnvelopeId, attachment.attachmentId);
      if (attachmentUrlCache.has(k)) return attachmentUrlCache.get(k);

      if (attachmentBusy.has(k)) {
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 120));
          if (attachmentUrlCache.has(k)) return attachmentUrlCache.get(k);
        }
        throw new Error("Attachment busy");
      }

      attachmentBusy.add(k);
      try {
        const callable = functions.httpsCallable("createSignedAttachmentDownloadUrl");
        const res = await callable({ signedEnvelopeId, attachmentId: attachment.attachmentId });
        const payload = (res && res.data) ? res.data : {};
        const downloadUrl = payload.downloadUrl;
        if (!downloadUrl) throw new Error("No downloadUrl");

        const r = await fetch(downloadUrl);
        if (!r.ok) throw new Error(`Download failed (${r.status})`);
        const encBuf = await r.arrayBuffer();

        const plainBytes = await decryptAttachmentBytesForCode(rawCode, encBuf, attachment.ivB64, attachment.saltB64);

        const blob = new Blob([plainBytes], { type: attachment.contentType || "application/octet-stream" });
        const url = URL.createObjectURL(blob);

        attachmentUrlCache.set(k, url);
        return url;
      } finally {
        attachmentBusy.delete(k);
      }
    }

    // -------------------------
    // Delvee account inbox images (WEB FALLBACK: account_inbox -> delivery_jobs)
    // -------------------------
    const delveeAccountInboxCache = new Map(); // sessionId -> { images: [], imagesCount, fetchedAtMs }
    const delveeAccountInboxBusy = new Set();  // sessionId

    function asStr(v){ return (typeof v === "string" && v.trim().length) ? v.trim() : null; }
    function asNum(v){ return (typeof v === "number" && Number.isFinite(v)) ? v : null; }
    function asArr(v){ return Array.isArray(v) ? v : []; }

    function extractDelveeSessionIdFromSummaryText(pt){
      const s = String(pt || "");
      // Typical: "Session DV-ABCD-EFGH"
      let m = s.match(/\bSession\s+(DV-[A-Z0-9]{4}-[A-Z0-9]{4})\b/i);
      if (m && m[1]) return String(m[1]).toUpperCase();

      // Sometimes: "Session DV-ABCD-EFGHParticipants:" (missing whitespace)
      m = s.match(/\bSession\s*(DV-[A-Z0-9]{4}-[A-Z0-9]{4})\b/i);
      if (m && m[1]) return String(m[1]).toUpperCase();

      return null;
    }

    // ✅ allow iv/salt to be null (treat bytes as plaintext if missing)
    function normalizeJobImages(raw){
      return asArr(raw).map(x => (x || {})).map(m => ({
        storagePath: asStr(m.storagePath),
        contentType: asStr(m.contentType) || "image/jpeg",
        sizeBytes: asNum(m.sizeBytes),
        ivB64: asStr(m.ivB64),
        saltB64: asStr(m.saltB64),
      })).filter(x => x.storagePath);
    }

    // ✅ Replacement: prefer /delvee_account_inbox/{sid}; fallback to /delvee_delivery_jobs/{sid}
    async function fetchDelveeAccountInboxDoc(sessionId){
      const sid = asStr(sessionId);
      if (!sid) return { images: [], imagesCount: 0, fetchedAtMs: Date.now() };

      if (delveeAccountInboxCache.has(sid)) return delveeAccountInboxCache.get(sid);
      if (delveeAccountInboxBusy.has(sid)) {
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 120));
          if (delveeAccountInboxCache.has(sid)) return delveeAccountInboxCache.get(sid);
        }
        return { images: [], imagesCount: 0, fetchedAtMs: Date.now() };
      }

      if (!auth.currentUser) return { images: [], imagesCount: 0, fetchedAtMs: Date.now() };

      delveeAccountInboxBusy.add(sid);
      try {
        const uid = auth.currentUser.uid;

        // 1) Prefer account inbox doc (newer/cleaner contract)
        try {
          const ref = db.collection("users").doc(uid).collection("delvee_account_inbox").doc(sid);
          const snap = await ref.get();
          if (snap.exists) {
            const d = snap.data() || {};
            const images = normalizeJobImages(d.images);
            const imagesCount = (typeof d.imagesCount === "number" && Number.isFinite(d.imagesCount)) ? d.imagesCount : images.length;
            const out = { images, imagesCount, fetchedAtMs: Date.now() };
            delveeAccountInboxCache.set(sid, out);
            return out;
          }
        } catch (e) {
          console.warn("[fetchDelveeAccountInboxDoc] account_inbox read failed", e);
        }

        // 2) ✅ Fallback: delivery job doc (what backend always creates)
        try {
          const jref = db.collection("users").doc(uid).collection("delvee_delivery_jobs").doc(sid);
          const jsnap = await jref.get();
          if (jsnap.exists) {
            const d = jsnap.data() || {};
            const images = normalizeJobImages(d.images);
            const imagesCount = (typeof d.imagesCount === "number" && Number.isFinite(d.imagesCount)) ? d.imagesCount : images.length;
            const out = { images, imagesCount, fetchedAtMs: Date.now() };
            delveeAccountInboxCache.set(sid, out);
            return out;
          }
        } catch (e) {
          console.warn("[fetchDelveeAccountInboxDoc] delivery_jobs fallback read failed", e);
        }

        const empty = { images: [], imagesCount: 0, fetchedAtMs: Date.now() };
        delveeAccountInboxCache.set(sid, empty);
        return empty;
      } finally {
        delveeAccountInboxBusy.delete(sid);
      }
    }

    const delveeInlineUrlCache = new Map(); // key -> objectUrl
    const delveeInlineBusy = new Set();

    function delveeInlineKey(sessionId, storagePath, ivB64, saltB64){
      return `${sessionId}::${storagePath}::${ivB64 || "noiv"}::${saltB64 || "nosalt"}`;
    }

    async function openDelveeJobImageAsObjectUrl(rawCode, sessionId, imgMeta){
      const k = delveeInlineKey(sessionId, imgMeta.storagePath, imgMeta.ivB64, imgMeta.saltB64);
      if (delveeInlineUrlCache.has(k)) return delveeInlineUrlCache.get(k);

      if (delveeInlineBusy.has(k)) {
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 120));
          if (delveeInlineUrlCache.has(k)) return delveeInlineUrlCache.get(k);
        }
        throw new Error("Inline image busy");
      }

      delveeInlineBusy.add(k);
      try {
        const dlCallable = functions.httpsCallable("delveeCreateJobImageDownloadUrl");
        const dlRes = await dlCallable({ sessionId, storagePath: imgMeta.storagePath });
        const dlPayload = (dlRes && dlRes.data) ? dlRes.data : {};
        const downloadUrl = dlPayload.downloadUrl;
        if (!downloadUrl) throw new Error("No downloadUrl");

        const r = await fetch(downloadUrl);
        if (!r.ok) throw new Error(`Download failed (${r.status})`);
        const encBuf = await r.arrayBuffer();

        let bytesToShow;
        const hasIvSalt = !!(imgMeta && imgMeta.ivB64 && imgMeta.saltB64);

        if (hasIvSalt) {
          try {
            bytesToShow = await decryptAttachmentBytesForCode(rawCode, encBuf, imgMeta.ivB64, imgMeta.saltB64);
          } catch (e) {
            console.warn("[openDelveeJobImageAsObjectUrl] decrypt failed", e);
            throw e;
          }
        } else {
          bytesToShow = new Uint8Array(encBuf);
        }

        const blob = new Blob([bytesToShow], { type: imgMeta.contentType || "image/jpeg" });
        const url = URL.createObjectURL(blob);
        delveeInlineUrlCache.set(k, url);
        return url;
      } finally {
        delveeInlineBusy.delete(k);
      }
    }

    // -------------------------
    // UI: Modal (Open flow)
    // -------------------------
    const delveeModal = document.getElementById("delvee-modal");
    const delveeClose = document.getElementById("delvee-close");
    const delveeOk = document.getElementById("delvee-ok");
    const delveeStage = document.getElementById("delvee-stage");
    const delveeText = document.getElementById("delvee-text");
    const delveeWho = document.getElementById("delvee-who");
    const delveeConsume = document.getElementById("delvee-consume");
    const delveeHeading = document.getElementById("delvee-heading");

    const delveeAttachments = document.getElementById("delvee-attachments");
    const delveeAttachmentsTitle = document.getElementById("delvee-attachments-title");
    const delveeThumbGrid = document.getElementById("delvee-thumb-grid");
    const delveeAttachActions = document.getElementById("delvee-attach-actions");

    let delveeActiveEnvelopeId = null;
    window.delveeActiveEnvelopeId = null; // ✅ keep console introspection stable

    function clearModalAttachmentsUI(){
      if (delveeThumbGrid) delveeThumbGrid.innerHTML = "";
      if (delveeAttachActions) delveeAttachActions.innerHTML = "";
      if (delveeAttachments) delveeAttachments.classList.add("hidden");
    }

    function modalHide(){
      delveeModal.classList.remove("show");
      if (delveeStage) {
        delveeStage.classList.remove("is-playing");
        delveeStage.classList.remove("is-revealed");
      }
      if (delveeText) delveeText.textContent = "";
      if (delveeWho) delveeWho.textContent = "Opening…";
      if (delveeConsume) {
        delveeConsume.disabled = false;
        delveeConsume.textContent = "Consume";
      }
      delveeActiveEnvelopeId = null;
      window.delveeActiveEnvelopeId = null;
      if (delveeHeading) delveeHeading.textContent = "Message";
      clearModalAttachmentsUI();
    }

    async function renderDelveeAccountImagesUI({ sessionId, rawCode, images }){
      clearModalAttachmentsUI();
      if (!sessionId || !images || images.length === 0) return;

      if (delveeAttachmentsTitle) delveeAttachmentsTitle.textContent = `Images (${images.length})`;
      if (delveeAttachments) delveeAttachments.classList.remove("hidden");

      for (let i = 0; i < images.length; i++) {
        const sk = document.createElement("div");
        sk.className = "sf-thumb-skel";
        sk.textContent = "…";
        delveeThumbGrid.appendChild(sk);
      }

      for (let i = 0; i < images.length; i++) {
        const imgMeta = images[i];
        const skel = delveeThumbGrid.children[i];

        try {
          const url = await openDelveeJobImageAsObjectUrl(rawCode, sessionId, imgMeta);
          const img = document.createElement("img");
          img.className = "sf-thumb";
          img.alt = "Image";
          img.src = url;
          img.title = "Open image";
          img.addEventListener("click", () => window.open(url, "_blank", "noopener"));
          delveeThumbGrid.replaceChild(img, skel);
        } catch (e) {
          console.warn("[delvee thumb load failed]", e);
          skel.textContent = "x";
        }
      }

      if (delveeAttachActions) {
        const btnOpenAll = document.createElement("button");
        btnOpenAll.className = "btn btn-secondary";
        btnOpenAll.type = "button";
        btnOpenAll.textContent = "Open all images";
        btnOpenAll.addEventListener("click", async () => {
          for (const m of images) {
            try {
              const url = await openDelveeJobImageAsObjectUrl(rawCode, sessionId, m);
              window.open(url, "_blank", "noopener");
            } catch (_) {}
          }
        });
        delveeAttachActions.appendChild(btnOpenAll);
      }
    }

    async function renderBodyWithDelveeAccountImages(envelopeId, bodyText){
      const item = findItemById(envelopeId);
      const rawCode = (lastFetchedCode || (codeInput && codeInput.value) || "").trim();

      const pt = String(bodyText || "");
      const container = document.createElement("div");

      const sessionId =
        (item && item.delveeSessionId) ? item.delveeSessionId :
        extractDelveeSessionIdFromSummaryText(pt);

      const doc = sessionId ? await fetchDelveeAccountInboxDoc(sessionId) : { images: [], imagesCount: 0 };
      const images = doc && Array.isArray(doc.images) ? doc.images : [];

      const lines = pt.split("\n");
      let imgIndex = 0;

      for (const line of lines) {
        const trimmed = line.trim();
        const looksLikeImageLine =
          trimmed === "[image]" ||
          trimmed === "• [image]" ||
          trimmed.includes("[image]");

        if (looksLikeImageLine && imgIndex < images.length && sessionId) {
          const p = document.createElement("div");
          p.textContent = line;
          p.style.whiteSpace = "pre-wrap";
          p.style.marginBottom = "6px";
          container.appendChild(p);

          const imgMeta = images[imgIndex++];
          const img = document.createElement("img");
          img.className = "sf-inline-img";
          img.alt = "Image";
          img.loading = "lazy";
          container.appendChild(img);

          openDelveeJobImageAsObjectUrl(rawCode, sessionId, imgMeta)
            .then((url) => { img.src = url; })
            .catch(() => { img.remove(); });

          continue;
        }

        const div = document.createElement("div");
        div.textContent = line;
        div.style.whiteSpace = "pre-wrap";
        container.appendChild(div);
      }

      if (sessionId) {
        await renderDelveeAccountImagesUI({ sessionId, rawCode, images });
      } else {
        clearModalAttachmentsUI();
      }

      return container;
    }

    function modalShow({ envelopeId, body, senderUid, kindLabel }){
      delveeActiveEnvelopeId = envelopeId;
      window.delveeActiveEnvelopeId = envelopeId; // ✅ for console/debug

      if (delveeWho) delveeWho.textContent = senderUid ? `From ${senderUid}` : "A surprise drop";
      if (delveeHeading) delveeHeading.textContent = kindLabel || "Message";
      if (delveeText) delveeText.textContent = "";

      clearModalAttachmentsUI();

      delveeModal.classList.add("show");

      if (delveeStage) {
        delveeStage.classList.remove("is-revealed");
        delveeStage.classList.add("is-playing");
      }

      const REVEAL_MS = 950;
      setTimeout(async () => {
        if (!delveeActiveEnvelopeId) return;

        const item = findItemById(envelopeId);
        const isDelveeSummary = item && item.kind === "delvee_summary";

        if (delveeText) {
          if (isDelveeSummary) {
            const node = await renderBodyWithDelveeAccountImages(envelopeId, body || "");
            delveeText.innerHTML = "";
            delveeText.appendChild(node);
          } else {
            delveeText.textContent = body || "";
            await renderModalAttachmentsForSignedEnvelope(envelopeId);
          }
        }

        if (delveeStage) {
          delveeStage.classList.remove("is-playing");
          delveeStage.classList.add("is-revealed");
        }
      }, REVEAL_MS);
    }

    delveeClose.addEventListener("click", modalHide);
    delveeOk.addEventListener("click", modalHide);
    delveeModal.addEventListener("click", (e) => { if (e.target === delveeModal) modalHide(); });

    // -------------------------
    // Modal images for normal signed envelopes (non-Delvee)
    // -------------------------
    async function renderModalAttachmentsForSignedEnvelope(envelopeId){
      clearModalAttachmentsUI();
      const item = findItemById(envelopeId);
      if (!item || !Array.isArray(item.attachments) || item.attachments.length === 0) return;

      const rawCode = (lastFetchedCode || (codeInput && codeInput.value) || "").trim();
      if (!rawCode) return;

      if (delveeAttachmentsTitle) delveeAttachmentsTitle.textContent = `Images (${item.attachments.length})`;
      if (delveeAttachments) delveeAttachments.classList.remove("hidden");

      for (let i = 0; i < item.attachments.length; i++) {
        const sk = document.createElement("div");
        sk.className = "sf-thumb-skel";
        sk.textContent = "…";
        delveeThumbGrid.appendChild(sk);
      }

      for (let i = 0; i < item.attachments.length; i++) {
        const a = item.attachments[i];
        const skel = delveeThumbGrid.children[i];

        try {
          const url = await openSignedAttachmentAsObjectUrl({ rawCode, signedEnvelopeId: item.id, attachment: a });
          const img = document.createElement("img");
          img.className = "sf-thumb";
          img.alt = "Image";
          img.src = url;
          img.title = "Open image";
          img.addEventListener("click", () => window.open(url, "_blank", "noopener"));
          delveeThumbGrid.replaceChild(img, skel);
        } catch (e) {
          console.error(e);
          skel.textContent = "x";
        }
      }

      if (delveeAttachActions) {
        const btnOpenAll = document.createElement("button");
        btnOpenAll.className = "btn btn-secondary";
        btnOpenAll.type = "button";
        btnOpenAll.textContent = "Open all images";
        btnOpenAll.addEventListener("click", async () => {
          for (const a of item.attachments) {
            try {
              const url = await openSignedAttachmentAsObjectUrl({ rawCode, signedEnvelopeId: item.id, attachment: a });
              window.open(url, "_blank", "noopener");
            } catch (_) {}
          }
        });
        delveeAttachActions.appendChild(btnOpenAll);
      }
    }

    // -------------------------
    // Released actions modal
    // -------------------------
    const actionsModal = document.getElementById("sf-actions-modal");
    const actionsMeta = document.getElementById("sf-actions-meta");
    const actionsPreview = document.getElementById("sf-actions-preview");

    const btnActPin = document.getElementById("sf-btn-pin");
    const btnActHideMsg = document.getElementById("sf-btn-hide-msg");
    const btnActBlockSender = document.getElementById("sf-btn-block-sender");
    const btnActConsume = document.getElementById("sf-btn-consume");
    const btnActDone = document.getElementById("sf-btn-done");

    let activeActionItem = null;

    function showActionsModal(item){
      activeActionItem = item;
      actionsMeta.textContent = `${item.when || "—"}${item.senderUid ? " · " + item.senderUid : ""}`;
      actionsPreview.textContent = item.body ? item.body : "Hidden — press Open to reveal";
      actionsModal.classList.add("show");
    }
    function hideActionsModal(){
      actionsModal.classList.remove("show");
      activeActionItem = null;
    }

    actionsModal.addEventListener("click", (e) => { if (e.target === actionsModal) hideActionsModal(); });
    btnActDone.addEventListener("click", hideActionsModal);
    window.addEventListener("keydown", (e) => { if (e.key === "Escape") { modalHide(); hideActionsModal(); } });

    // -------------------------
    // Notifications
    // -------------------------
    async function ensureBrowserNotifications(){
      try {
        if (!("Notification" in window)) return false;
        if (Notification.permission === "granted") return true;
        if (Notification.permission === "denied") return false;
        const p = await Notification.requestPermission();
        return p === "granted";
      } catch (_) {
        return false;
      }
    }

    function notifyReleased(title, body){
      try {
        if (!("Notification" in window)) return;
        if (Notification.permission !== "granted") return;
        new Notification(title, { body });
      } catch (_) {}
    }

    // -------------------------
    // Delvee delivery jobs -> safe state machine processor
    // -------------------------
    const JOBS_COLL = "delvee_delivery_jobs";
    const JOB_STALE_MS = 3 * 60_000;  // treat PROCESSING older than this as abandoned
    const JOB_MAX_ATTEMPTS = 5;

    async function claimJobTx(jobRef){
      // returns { ok, job, reason }
      return await db.runTransaction(async (tx) => {
        const snap = await tx.get(jobRef);
        if (!snap.exists) return { ok:false, reason:"missing" };

        const d = snap.data() || {};
        const state = asStr(d.state) || "PENDING";
        const attempts = asNum(d.attempts) || 0;
        const updatedAtUtc = asStr(d.updatedAtUtc) || null;
        const updatedAtMs = updatedAtUtc ? (new Date(updatedAtUtc).getTime()) : 0;

        const nowMs = Date.now();
        const isStaleProcessing = (state === "PROCESSING") && (updatedAtMs > 0) && (nowMs - updatedAtMs > JOB_STALE_MS);

        const eligible =
          state === "PENDING" ||
          state === "RETRY" ||
          isStaleProcessing;

        if (!eligible) return { ok:false, reason:`state:${state}` };

        if (attempts >= JOB_MAX_ATTEMPTS) {
          tx.set(jobRef, {
            state: "FAILED",
            updatedAtUtc: new Date().toISOString(),
            lastError: "Max attempts reached",
          }, { merge:true });
          return { ok:false, reason:"max_attempts" };
        }

        tx.set(jobRef, {
          state: "PROCESSING",
          attempts: attempts + 1,
          updatedAtUtc: new Date().toISOString(),
          lastError: null,
        }, { merge:true });

        return { ok:true, job: { id: snap.id, ...d, attempts: attempts + 1, state:"PROCESSING" } };
      });
    }

    async function setJobState(jobRef, state, extra){
      const patch = Object.assign({
        state,
        updatedAtUtc: new Date().toISOString(),
      }, extra || {});
      await jobRef.set(patch, { merge:true });
    }

    async function deliverJobIntoSignedInbox(job, rawCode){
      const summaryText = asStr(job.summaryText) || null;
      if (!summaryText) throw new Error("Job missing summaryText");

      const deliverAtLocalIso = nowWithOffsetIso();
      const userTimezone = (Intl && Intl.DateTimeFormat().resolvedOptions) ? (Intl.DateTimeFormat().resolvedOptions().timeZone || "UTC") : "UTC";

      const enc = await encryptTextForCode(rawCode, summaryText);

      const codeHash = await sha256Hex(normalizeCodeAndroid(rawCode));
      const clientRequestId = `job_${job.sessionId}_${Date.now()}_${Math.random().toString(16).slice(2)}`;

      const sendCallable = functions.httpsCallable("sendSignedCiphertext");
      const sendRes = await sendCallable({
        codeHash,
        ciphertext: enc.ciphertextB64,
        iv: enc.ivB64,
        salt: enc.saltB64,
        deliverAtLocalIso,
        userTimezone,
        clientRequestId,
        attachments: [],
      });

      const sendPayload = (sendRes && sendRes.data) ? sendRes.data : {};
      return {
        signedEnvelopeId: sendPayload.signedEnvelopeId || null,
        attachmentCount: 0,
      };
    }

    async function processDelveeJobsOnce(rawCode, { quiet } = { quiet:false }){
      if (!auth.currentUser) return { processed: 0, skipped: 0 };

      const uid = auth.currentUser.uid;
      const code = (rawCode || "").trim();
      if (!code) {
        if (!quiet) setStatus("warn", "Code needed", "Paste a Secure/Personal code first.");
        return { processed: 0, skipped: 0 };
      }

      const jobsRef = db.collection("users").doc(uid).collection(JOBS_COLL);
      const snap = await jobsRef.where("state", "in", ["PENDING", "RETRY", "PROCESSING"]).limit(25).get();
      if (snap.empty) return { processed: 0, skipped: 0 };

      let processed = 0;
      let skipped = 0;

      for (const doc of snap.docs) {
        const jobRef = doc.ref;

        let claimed;
        try {
          claimed = await claimJobTx(jobRef);
        } catch (e) {
          console.warn("[claimJobTx failed]", e);
          skipped++;
          continue;
        }

        if (!claimed || !claimed.ok) { skipped++; continue; }
        const job = claimed.job;

        try {
          if (!quiet) setStatus("good", "Delivering summary…", `Processing Delvee job ${job.sessionId || job.id}…`);

          const delivered = await deliverJobIntoSignedInbox(job, code);

          await setJobState(jobRef, "DELIVERED", {
            deliveredAtUtc: new Date().toISOString(),
            lastError: null,
            deliveredSignedEnvelopeId: delivered.signedEnvelopeId || null,
          });

          processed++;
        } catch (e) {
          console.error("[deliver job failed]", e);

          const attempts = asNum(job.attempts) || 1;
          const msg = (e && e.message) ? String(e.message) : "Delivery failed";

          if (attempts >= JOB_MAX_ATTEMPTS) {
            await setJobState(jobRef, "FAILED", { lastError: msg });
          } else {
            await setJobState(jobRef, "RETRY", { lastError: msg });
          }

          skipped++;
        }
      }

      if (!quiet) {
        if (processed > 0) setStatus("good", "Delivered", `Delivered ${processed} Delvee summary job(s) into this inbox.`);
        else setStatus("warn", "No deliverable jobs", "No pending Delvee summary jobs could be delivered right now.");
      }

      return { processed, skipped };
    }

    // -------------------------
    // Fetch + normalize (signed envelopes)
    // -------------------------
    async function fetchSignedEnvelopesForCode(rawCode) {
      const normalized = normalizeCodeAndroid(rawCode);
      const codeHash = await sha256Hex(normalized);

      const callable = functions.httpsCallable("fetchSignedEnvelopes");
      const res = await callable({ codeHash });

      const payload = (res && res.data) ? res.data : {};
      const arr = Array.isArray(payload.envelopes) ? payload.envelopes : [];
      return arr;
    }

    let decryptedById = new Map();
    let latestItems = [];
    let summariesOnly = false;

    async function buildLatestItems(rawCode, envelopes){
      decryptedById = new Map();
      const out = [];

      for (const env of envelopes || []) {
        const id = env.signedEnvelopeId;
        const senderUid = env.senderUid || null;
        const deliverAtUtc = env.deliverAtUtc || null;
        const deliverAtLocalIso = env.deliverAtLocalIso || null;
        const when = formatLocal(deliverAtUtc, deliverAtLocalIso);
        const deliverMillis = parseDeliverMillis(deliverAtUtc, deliverAtLocalIso);

        const ciphertext = env.ciphertext || env.ciphertextB64;
        const iv = env.iv || env.ivB64;
        const salt = env.salt || env.saltB64;

        if (!id || !ciphertext || !iv || !salt) continue;

        const pt = await decryptEnvelopeForCode(rawCode, ciphertext, iv, salt);
        if (pt == null) continue;

        const k = detectKindFromPlaintext(pt);

        const delveeSessionId = (k.kind === "delvee_summary") ? extractDelveeSessionIdFromSummaryText(pt) : null;

        const attachments = normalizeAttachments(env.attachments);

        decryptedById.set(id, pt);
        out.push({
          id,
          senderUid,
          when,
          deliverMillis,
          kind: k.kind,
          kindLabel: k.label,
          kindPillText: k.pillText,
          kindPillCls: k.pillCls,
          attachments,
          delveeSessionId,
        });
      }

      return out;
    }

    function categorize(items){
      const now = Date.now();

      const awaitingIds = new Set(getAwaitingIds());
      const hiddenUpcomingIds = new Set(getHiddenUpcomingIds());
      const hiddenReleasedIds = new Set(getHiddenReleasedIds());
      const pinnedIds = new Set(getPinnedIds());

      const blockedSenders = new Set(getBlockedSenders());
      const showBlocked = getShowBlocked();

      const pinned = [];
      const upcoming = [];
      const awaiting = [];
      const released = [];

      for (const it of items || []) {
        if (summariesOnly && it.kind !== "delvee_summary") continue;

        const isSenderBlocked = it.senderUid && blockedSenders.has(it.senderUid);
        if (!showBlocked && isSenderBlocked) continue;

        const deliverMillis = it.deliverMillis;
        const isReleased = (deliverMillis == null) ? true : (deliverMillis <= now);

        if (isReleased) {
          if (hiddenReleasedIds.has(it.id)) continue;

          const body = decryptedById.get(it.id) || "";
          const entry = { ...it, body };

          if (pinnedIds.has(it.id)) pinned.push(entry);
          else released.push(entry);
          continue;
        }

        const entry = { ...it, body: "" };

        if (awaitingIds.has(it.id)) awaiting.push(entry);
        else {
          if (hiddenUpcomingIds.has(it.id)) continue;
          upcoming.push(entry);
        }
      }

      const bySoon = (a,b) => (a.deliverMillis ?? 0) - (b.deliverMillis ?? 0);
      const byNew = (a,b) => (b.deliverMillis ?? 0) - (a.deliverMillis ?? 0);

      upcoming.sort(bySoon);
      awaiting.sort(bySoon);
      released.sort(byNew);
      pinned.sort(byNew);

      return { pinned, upcoming, awaiting, released };
    }

    // -------------------------
    // Swipe + rendering
    // -------------------------
    function attachSwipeHandlers(cardEl, opts){
      const dragEl = cardEl.querySelector(".sf-drag");
      const bgEl = cardEl.querySelector(".sf-swipe-bg");

      let startX = 0;
      let startY = 0;
      let dx = 0;
      let active = false;

      let longPressTimer = null;
      let longPressFired = false;

      const SWIPE_THRESHOLD = 72;

      function clearLongPress(){
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      function setDrag(x){
        dragEl.style.transition = "none";
        dragEl.style.transform = `translateX(${x}px)`;
        if (bgEl) bgEl.classList.toggle("show", Math.abs(x) > 8);
      }

      function settle(){
        dragEl.style.transition = "transform 140ms ease";
        dragEl.style.transform = "translateX(0px)";
        if (bgEl) bgEl.classList.remove("show");
      }

      function onDown(e){
        if (e.target && e.target.closest && e.target.closest("button,a,input,select,textarea,label")) return;

        if (!dragEl) return;
        active = true;
        startX = e.clientX;
        startY = e.clientY;
        dx = 0;
        longPressFired = false;

        if (opts.enableLongPress) {
          clearLongPress();
          longPressTimer = setTimeout(() => {
            longPressFired = true;
            try { navigator.vibrate && navigator.vibrate(12); } catch (_) {}
            opts.onLongPress && opts.onLongPress();
          }, 520);
        }

        try { cardEl.setPointerCapture && cardEl.setPointerCapture(e.pointerId); } catch (_) {}
      }

      function onMove(e){
        if (!active) return;

        const cx = e.clientX;
        const cy = e.clientY;
        dx = cx - startX;
        const dy = cy - startY;

        if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 10) {
          clearLongPress();
          settle();
          active = false;
          return;
        }

        if (Math.abs(dx) > 8) clearLongPress();
        if (opts.onSwipeLeft || opts.onSwipeRight) setDrag(dx);
      }

      async function onUp(){
        if (!active) return;
        active = false;
        clearLongPress();

        if (longPressFired) { settle(); return; }

        if (opts.onSwipeLeft || opts.onSwipeRight) {
          const commitRight = dx >= SWIPE_THRESHOLD;
          const commitLeft = dx <= -SWIPE_THRESHOLD;

          if (commitRight && opts.onSwipeRight) {
            dragEl.style.transition = "transform 120ms ease";
            dragEl.style.transform = "translateX(110px)";
            setTimeout(() => opts.onSwipeRight && opts.onSwipeRight(), 90);
            return;
          }

          if (commitLeft && opts.onSwipeLeft) {
            dragEl.style.transition = "transform 120ms ease";
            dragEl.style.transform = "translateX(-110px)";
            setTimeout(() => opts.onSwipeLeft && opts.onSwipeLeft(), 90);
            return;
          }
        }

        settle();
      }

      cardEl.addEventListener("pointerdown", onDown);
      cardEl.addEventListener("pointermove", onMove);
      cardEl.addEventListener("pointerup", onUp);
      cardEl.addEventListener("pointercancel", onUp);
      cardEl.addEventListener("lostpointercapture", onUp);
    }

    function messageCardHTML(item, mode){
      const isAwaiting = mode === "awaiting";
      const isReleased = (mode === "released" || mode === "pinned");
      const isHidden = mode === "hidden";

      const sender = item.senderUid ? `Sender: ${item.senderUid}` : "Sender: —";
      const when = item.when || "—";

      const bodyText =
        isReleased ? "Hidden — press Open" :
        isAwaiting ? "Awaiting — notify me when ready" :
        isHidden ? "Hidden" :
        "Upcoming";

      const leftLabel = mode === "upcoming" ? "Hide" : "";
      const rightLabel = mode === "upcoming" ? "Awaiting" : "";

      const btns = [];
      if (isReleased) {
        btns.push(`<button class="btn btn-secondary" type="button" data-open="${safeText(item.id)}">Open</button>`);
        btns.push(`<button class="btn btn-quiet" type="button" data-consume="${safeText(item.id)}">Consume</button>`);
        btns.push(`<button class="btn btn-quiet" type="button" data-more="${safeText(item.id)}">•••</button>`);
      } else if (isHidden) {
        btns.push(`<button class="btn btn-secondary" type="button" data-restore="${safeText(item.id)}">Restore</button>`);
      } else {
        btns.push(`<button class="btn btn-quiet" type="button" data-hide-upcoming="${safeText(item.id)}">Hide</button>`);
        if (!isAwaiting) btns.push(`<button class="btn btn-secondary" type="button" data-make-awaiting="${safeText(item.id)}">Mark awaiting</button>`);
      }

      const titleText = (item && item.kindLabel) ? item.kindLabel : (mode === "pinned" ? "Pinned message" : "Message");
      const pill =
        (item && item.kind === "delvee_summary")
          ? `<span class="sf-kind delvee">${safeText(item.kindPillText || "Delvee")}</span>`
          : ``;

      const isDelvee = (item && item.kind === "delvee_summary");
      const signedAttachmentCount = Array.isArray(item.attachments) ? item.attachments.length : 0;

      const attachCountLine = (isReleased && (isDelvee || signedAttachmentCount > 0))
        ? `<div class="sf-attach-count" data-attach-line="1" data-sid="${safeText(item.delveeSessionId || "")}">
             <span class="dot"></span>
             <span data-attach-text="1">${isDelvee ? "Images: …" : ("Images: " + signedAttachmentCount)}</span>
           </div>`
        : ``;

      return `
        <div class="sf-msg-card" data-id="${safeText(item.id)}" data-mode="${safeText(mode)}">
          <div class="sf-swipe-bg">
            <div class="sf-swipe-left">${safeText(leftLabel)}</div>
            <div class="sf-swipe-right">${safeText(rightLabel)}</div>
          </div>

          <div class="sf-drag">
            <div class="sf-msg-top">
              <div class="sf-msg-title">
                ${pill}
                <span class="sf-msg-title-text">${safeText(titleText)}</span>
              </div>
              <div class="sf-msg-meta">
                <span>${safeText(when)}</span>
                <span>${safeText(sender)}</span>
              </div>
            </div>

            <div class="sf-msg-body">${safeText(bodyText)}</div>

            ${attachCountLine}

            <div class="sf-msg-actions">
              ${btns.join("")}
            </div>
          </div>
        </div>
      `;
    }

    async function consumeEnvelope(id){
      if (!id) return;

      try {
        setStatus("good", "Consuming…", "Marking envelope consumed…");
        const callable = functions.httpsCallable("markSignedEnvelopeConsumed");
        await callable({ signedEnvelopeId: id });

        setAwaitingIds(getAwaitingIds().filter(x => x !== id));
        setHiddenUpcomingIds(getHiddenUpcomingIds().filter(x => x !== id));
        setHiddenReleasedIds(getHiddenReleasedIds().filter(x => x !== id));
        setPinnedIds(getPinnedIds().filter(x => x !== id));

        decryptedById.delete(id);
        latestItems = latestItems.filter(x => x.id !== id);

        refreshHiddenNav();
        renderAll();
        setStatus("good", "Consumed", "Message consumed (won’t return on future fetches).");
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t consume", "If this keeps happening, confirm the callable is deployed as markSignedEnvelopeConsumed.");
      }
    }

    function renderEmpty(el, title, subtitle){
      el.innerHTML = `
        <div class="panel">
          <p class="panel-title">${safeText(title)}</p>
          <p class="panel-sub">${safeText(subtitle)}</p>
          <small class="help">Tip: press Fetch after sending a message.</small>
        </div>
      `;
    }

    function renderHidden(){
      const hiddenIds = new Set(getHiddenReleasedIds());
      const hiddenItems = (latestItems || [])
        .filter(it => hiddenIds.has(it.id))
        .map(it => ({ ...it, body: decryptedById.get(it.id) || "" }));

      const pillHidden = document.getElementById("pill-hidden");
      if (pillHidden) pillHidden.textContent = `${hiddenItems.length} hidden`;

      if (hiddenItems.length === 0) {
        renderEmpty(listHidden, "No hidden messages", "Hide a released message to see it here.");
        return;
      }

      listHidden.innerHTML = hiddenItems.map(it => messageCardHTML(it, "hidden")).join("");

      listHidden.querySelectorAll("button[data-restore]").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.getAttribute("data-restore");
          if (!id) return;
          setHiddenReleasedIds(getHiddenReleasedIds().filter(x => x !== id));
          refreshHiddenNav();
          renderAll();
          setStatus("good", "Restored", "Message restored to Released.");
        });
      });
    }

    async function hydrateDelveeImageCounts(){
      const cards = document.querySelectorAll('.sf-msg-card[data-mode="released"], .sf-msg-card[data-mode="pinned"]');
      const sidSet = new Set();

      cards.forEach(card => {
        const attachLine = card.querySelector('[data-attach-line="1"]');
        if (!attachLine) return;
        const sid = attachLine.getAttribute("data-sid") || "";
        const sidTrim = sid.trim();
        if (!sidTrim) return;
        sidSet.add(sidTrim);
      });

      const sids = Array.from(sidSet);
      if (sids.length === 0) return;

      for (const sid of sids) {
        try {
          const doc = await fetchDelveeAccountInboxDoc(sid);
          const n = (doc && typeof doc.imagesCount === "number") ? doc.imagesCount : (doc.images ? doc.images.length : 0);

          document.querySelectorAll(`[data-attach-line="1"][data-sid="${CSS.escape(sid)}"]`).forEach(line => {
            const span = line.querySelector('[data-attach-text="1"]');
            if (span) span.textContent = `Images: ${n}`;
          });
        } catch (_) {}
      }
    }

    function renderAll(){
      refreshHiddenNav();

      const { pinned, upcoming, awaiting, released } = categorize(latestItems);

      pillPinned.textContent = String(pinned.length);
      pillUpcoming.textContent = String(upcoming.length);
      pillAwaiting.textContent = String(awaiting.length);
      pillReleased.textContent = String(released.length);

      const total = pinned.length + upcoming.length + awaiting.length + released.length;
      countPill.textContent = `${total} message${total === 1 ? "" : "s"}`;

      if (pinned.length > 0) {
        headPinned.style.display = "flex";
        listPinned.innerHTML = pinned.map(it => messageCardHTML(it, "pinned")).join("");
      } else {
        headPinned.style.display = "none";
        listPinned.innerHTML = "";
      }

      if (upcoming.length === 0) renderEmpty(listUpcoming, summariesOnly ? "No upcoming summaries" : "No upcoming messages", "Upcoming messages appear here until delivery time.");
      else listUpcoming.innerHTML = upcoming.map(it => messageCardHTML(it, "upcoming")).join("");

      if (awaiting.length === 0) renderEmpty(listAwaiting, summariesOnly ? "No awaiting summaries" : "No awaiting messages", "Swipe right on an upcoming message to mark it Awaiting.");
      else listAwaiting.innerHTML = awaiting.map(it => messageCardHTML(it, "awaiting")).join("");

      if (released.length === 0) renderEmpty(listReleased, summariesOnly ? "No released summaries" : "No released messages", "When delivery time arrives, messages appear here.");
      else listReleased.innerHTML = released.map(it => messageCardHTML(it, "released")).join("");

      wireUpcoming(listUpcoming);
      wireAwaiting(listAwaiting);
      wireReleased(listPinned);
      wireReleased(listReleased);

      if (currentRoute() === "hidden") renderHidden();

      hydrateDelveeImageCounts().catch(() => {});
    }

    function findItemById(id){
      return (latestItems || []).find(x => x.id === id) || null;
    }

    function wireUpcoming(container){
      container.querySelectorAll(".sf-msg-card").forEach(card => {
        const id = card.getAttribute("data-id");
        if (!id) return;

        attachSwipeHandlers(card, {
          onSwipeRight: async () => {
            const awaiting = getAwaitingIds();
            if (!awaiting.includes(id)) awaiting.push(id);
            setAwaitingIds(awaiting);

            const ok = await ensureBrowserNotifications();
            if (ok) setStatus("good", "Awaiting", "Browser notifications enabled for awaiting items.");
            else setStatus("warn", "Awaiting", "Awaiting set. Enable browser notifications if you want alerts.");

            renderAll();
          },
          onSwipeLeft: () => {
            const hidden = getHiddenUpcomingIds();
            if (!hidden.includes(id)) hidden.push(id);
            setHiddenUpcomingIds(hidden);
            setStatus("warn", "Hidden (upcoming)", "Hidden until release time (device-only).");
            renderAll();
          },
          enableLongPress: false
        });

        const btnHide = card.querySelector("button[data-hide-upcoming]");
        if (btnHide) btnHide.addEventListener("click", () => {
          const hidden = getHiddenUpcomingIds();
          if (!hidden.includes(id)) hidden.push(id);
          setHiddenUpcomingIds(hidden);
          setStatus("warn", "Hidden (upcoming)", "Hidden until release time (device-only).");
          renderAll();
        });

        const btnAwait = card.querySelector("button[data-make-awaiting]");
        if (btnAwait) btnAwait.addEventListener("click", async () => {
          const awaiting = getAwaitingIds();
          if (!awaiting.includes(id)) awaiting.push(id);
          setAwaitingIds(awaiting);

          const ok = await ensureBrowserNotifications();
          if (ok) setStatus("good", "Awaiting", "Browser notifications enabled for awaiting items.");
          else setStatus("warn", "Awaiting", "Awaiting set. Enable browser notifications if you want alerts.");

          renderAll();
        });
      });
    }

    function wireAwaiting(container){
      container.querySelectorAll(".sf-msg-card").forEach(card => {
        const id = card.getAttribute("data-id");
        if (!id) return;

        attachSwipeHandlers(card, { enableLongPress: false });

        const btnHide = card.querySelector("button[data-hide-upcoming]");
        if (btnHide) btnHide.addEventListener("click", () => {
          const hidden = getHiddenUpcomingIds();
          if (!hidden.includes(id)) hidden.push(id);
          setHiddenUpcomingIds(hidden);

          setAwaitingIds(getAwaitingIds().filter(x => x !== id));

          setStatus("warn", "Hidden (upcoming)", "Hidden until release time (device-only).");
          renderAll();
        });
      });
    }

    function wireReleased(container){
      container.querySelectorAll(".sf-msg-card").forEach(card => {
        const id = card.getAttribute("data-id");
        if (!id) return;

        const item = findItemById(id);
        if (!item) return;

        attachSwipeHandlers(card, {
          enableLongPress: true,
          onLongPress: () => {
            const body = decryptedById.get(id) || "";
            showActionsModal({ id, senderUid: item.senderUid || null, when: item.when, body });
          }
        });

        const btnOpen = card.querySelector("button[data-open]");
        if (btnOpen) btnOpen.addEventListener("click", () => {
          const full = findItemById(id);
          const body = decryptedById.get(id) || "";
          const kindLabel = full && full.kindLabel ? full.kindLabel : "Message";
          modalShow({ envelopeId: id, body, senderUid: full ? (full.senderUid || null) : null, kindLabel });
        });

        const btnConsume = card.querySelector("button[data-consume]");
        if (btnConsume) btnConsume.addEventListener("click", async () => {
          btnConsume.disabled = true;
          btnConsume.textContent = "Consuming…";
          await consumeEnvelope(id);
        });

        const btnMore = card.querySelector("button[data-more]");
        if (btnMore) btnMore.addEventListener("click", () => {
          const body = decryptedById.get(id) || "";
          showActionsModal({ id, senderUid: item.senderUid || null, when: item.when, body });
        });
      });
    }

    btnActPin.addEventListener("click", () => {
      if (!activeActionItem) return;
      const pinned = getPinnedIds();
      if (!pinned.includes(activeActionItem.id)) pinned.push(activeActionItem.id);
      setPinnedIds(pinned);
      hideActionsModal();
      renderAll();
      setStatus("good", "Pinned", "Message pinned on this device.");
    });

    btnActHideMsg.addEventListener("click", () => {
      if (!activeActionItem) return;
      const hidden = getHiddenReleasedIds();
      if (!hidden.includes(activeActionItem.id)) hidden.push(activeActionItem.id);
      setHiddenReleasedIds(hidden);
      hideActionsModal();
      refreshHiddenNav();
      renderAll();
      setStatus("warn", "Hidden", "Message hidden on this device.");
    });

    btnActBlockSender.addEventListener("click", () => {
      if (!activeActionItem) return;
      if (!activeActionItem.senderUid) {
        setStatus("warn", "No sender", "This message has no sender id to hide.");
        return;
      }
      const blocked = getBlockedSenders();
      if (!blocked.includes(activeActionItem.senderUid)) blocked.push(activeActionItem.senderUid);
      setBlockedSenders(blocked);
      hideActionsModal();
      applyToggleUI();
      renderAll();
      setStatus("warn", "Sender hidden", "Messages from this sender are hidden on this device.");
    });

    btnActConsume.addEventListener("click", async () => {
      if (!activeActionItem) return;
      await consumeEnvelope(activeActionItem.id);
      hideActionsModal();
    });

    delveeConsume.addEventListener("click", async () => {
      if (!delveeActiveEnvelopeId) return;
      delveeConsume.disabled = true;
      delveeConsume.textContent = "Consuming…";
      await consumeEnvelope(delveeActiveEnvelopeId);
      modalHide();
    });

    // -------------------------
    // Auto polling + toggles
    // -------------------------
    let autoTimer = null;

    function applyToggleUI(){
      autoLabel.textContent = `Auto polling: ${getAutoPolling() ? "On" : "Off"}`;
      blockedLabel.textContent = `Hidden senders: ${getShowBlocked() ? "Shown" : "Hidden"}`;
      summariesLabel.textContent = `Show: ${summariesOnly ? "Summaries" : "All"}`;
    }

    function stopAuto(){
      if (autoTimer) clearInterval(autoTimer);
      autoTimer = null;
    }

    function startAuto(){
      stopAuto();
      autoTimer = setInterval(async () => {
        if (!auth.currentUser) return;
        const rawCode = (codeInput && codeInput.value) ? codeInput.value.trim() : "";
        if (!rawCode) return;

        try { await processDelveeJobsOnce(rawCode, { quiet:true }); } catch (_) {}

        await doFetch(rawCode, { quiet: true });
      }, 15000);
    }

    btnAuto.addEventListener("click", async () => {
      const next = !getAutoPolling();
      setAutoPolling(next);
      applyToggleUI();
      if (next) {
        startAuto();
        setStatus("good", "Auto polling on", "Fetching every ~15s while this tab is open.");
      } else {
        stopAuto();
        setStatus("warn", "Auto polling off", "Manual Fetch only.");
      }
    });

    btnShowBlocked.addEventListener("click", () => {
      const next = !getShowBlocked();
      setShowBlocked(next);
      applyToggleUI();
      renderAll();
      setStatus("good", "Updated", next ? "Hidden senders are now shown everywhere." : "Hidden senders are now hidden everywhere.");
    });

    btnSummariesOnly.addEventListener("click", () => {
      summariesOnly = !summariesOnly;
      applyToggleUI();
      renderAll();
    });

    // -------------------------
    // Fetch flow
    // -------------------------
    async function doFetch(rawCode, { quiet } = { quiet:false }){
      if (!auth.currentUser) {
        if (!quiet) setStatus("warn", "Sign-in required", "Sign in to fetch signed inbox messages.");
        return;
      }

      const code = (rawCode || "").trim();
      if (!code) {
        if (!quiet) setStatus("warn", "Code needed", "Paste a Secure/Personal code first.");
        return;
      }

      try {
        if (!quiet) setStatus("good", "Fetching…", "Calling fetchSignedEnvelopes…");
        const envelopes = await fetchSignedEnvelopesForCode(code);
        const items = await buildLatestItems(code, envelopes);

        if (lastFetchedCode && normalizeCodeAndroid(lastFetchedCode) !== normalizeCodeAndroid(code)) {
          revokeAllAttachmentUrls();
        }
        lastFetchedCode = code;

        const prev = latestItems;
        latestItems = items;

        const awaitingIds = new Set(getAwaitingIds());
        const now = Date.now();

        for (const it of latestItems) {
          if (!awaitingIds.has(it.id)) continue;
          const t = it.deliverMillis;
          const isReleasedNow = (t == null) ? true : (t <= now);
          if (!isReleasedNow) continue;

          const prevIt = (prev || []).find(x => x.id === it.id) || null;
          const prevT = prevIt ? prevIt.deliverMillis : null;
          const wasReleasedBefore = (prevT == null) ? !!prevIt : (prevT <= now);

          if (!wasReleasedBefore) {
            notifyReleased("Setfeed — message released", it.senderUid ? `From ${it.senderUid}` : "A message is ready.");
          }
        }

        renderAll();

        if (!quiet) {
          if (latestItems.length === 0) setStatus("warn", "No messages", "No decryptable messages for this code (or none unconsumed).");
          else setStatus("good", "Fetched", "Lists updated. Open reveals inside the vault.");
        }
      } catch (e) {
        console.error(e);
        if (!quiet) setStatus("warn", "Fetch failed", (e && e.message) ? e.message : "Fetch failed. Try again.");
      }
    }

    btnFetch.addEventListener("click", async () => {
      btnFetch.disabled = true;
      const prev = btnFetch.textContent;
      btnFetch.textContent = "Fetching…";
      try {
        await doFetch(codeInput.value, { quiet:false });
      } finally {
        btnFetch.disabled = false;
        btnFetch.textContent = prev;
      }
    });

    btnFetchSummaries.addEventListener("click", async () => {
      btnFetchSummaries.disabled = true;
      const prev = btnFetchSummaries.textContent;
      btnFetchSummaries.textContent = "Fetching…";
      try {
        const raw = (codeInput && codeInput.value) ? codeInput.value.trim() : "";

        try { await processDelveeJobsOnce(raw, { quiet:false }); } catch (e) { console.error(e); }

        await doFetch(raw, { quiet:false });

        summariesOnly = true;
        applyToggleUI();
        renderAll();
        setStatus("good", "Summaries", "Showing Delvee Summaries only.");
      } finally {
        btnFetchSummaries.disabled = false;
        btnFetchSummaries.textContent = prev;
      }
    });

    btnClear.addEventListener("click", () => {
      codeInput.value = "";
      setAwaitingIds([]);

      decryptedById = new Map();
      latestItems = [];
      summariesOnly = false;
      lastFetchedCode = "";

      revokeAllAttachmentUrls();
      delveeAccountInboxCache.clear();
      delveeAccountInboxBusy.clear();
      delveeInlineUrlCache.clear();
      delveeInlineBusy.clear();

      applyToggleUI();
      refreshHiddenNav();
      renderAll();
      setStatus("warn", "Cleared", "Inbox cleared. Paste a code and press Fetch.");
    });

    // Boot
    applyToggleUI();
    refreshHiddenNav();

    if (getAutoPolling()) startAuto();

    showRoute(currentRoute());

    latestItems = [];
    renderAll();
    setStatus("good", "Ready", "Sign in to fetch signed inbox messages.");
  </script>
</body>
</html>
