<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Inbox — Setfeed</title>
  <meta name="description" content="Your Setfeed inbox feed (signed-in view)." />

  <meta name="theme-color" content="#FFFBFE" id="meta-theme-color" />

  <link rel="icon" href="./favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="./favicon-32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="./favicon-16.png" sizes="16x16">
  <link rel="apple-touch-icon" href="./apple-touch-icon.png" sizes="180x180">

  <link rel="stylesheet" href="./styles.css" />

  <!-- FIREBASE (AUTH + FUNCTIONS) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCECKG-00tijJrt5qvRy3L27ZzE7bocNrU",
      authDomain: "setfeed-fcd7a.firebaseapp.com",
      projectId: "setfeed-fcd7a",
      storageBucket: "setfeed-fcd7a.firebasestorage.app",
      messagingSenderId: "553573263069",
      appId: "1:553573263069:web:e5c9884101ca38eaee1d34"
    };

    if (!firebase.apps || firebase.apps.length === 0) firebase.initializeApp(firebaseConfig);

    const functions = firebase.app().functions("europe-west2");
    const auth = firebase.auth();
  </script>

  <!-- THEME -->
  <script>
    (function(){
      const THEME_KEY = "sf_theme_mode";
      const root = document.documentElement;

      function applyTheme(){
        let stored = "system";
        try { stored = localStorage.getItem(THEME_KEY) || "system"; } catch (_) {}

        if (stored === "light" || stored === "dark") root.setAttribute("data-theme", stored);
        else root.removeAttribute("data-theme");

        const effective =
          root.getAttribute("data-theme") ||
          (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");

        const meta = document.getElementById("meta-theme-color");
        if (meta) meta.content = (effective === "dark") ? "#0F1114" : "#FFFBFE";
      }

      applyTheme();
      window.addEventListener("storage", (e) => { if (e && e.key === THEME_KEY) applyTheme(); });
    })();
  </script>
</head>

<body class="page-bg">
  <header class="site-header">
    <div class="header-inner">
      <a class="brand-mark" href="./" aria-label="Setfeed home">
        <img class="logo" src="./logo.png" alt="" aria-hidden="true" />
      </a>

      <a class="brand-title" href="./">Setfeed</a>

      <nav class="nav" aria-label="Primary">
        <a href="./">Home</a>
        <a href="./send.html">Send</a>
        <a href="./receive.html">Receive</a>
        <a class="auth-only hidden" href="./inbox.html" aria-current="page">Inbox</a>
        <a href="./security.html">Security</a>
        <a href="./privacy.html">Privacy</a>
        <a class="nav-cta" href="#" aria-label="Download Setfeed app">Download app</a>
      </nav>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <h1>Inbox</h1>
      <p class="lead">
        This web inbox is deliberate: <strong>no auto-fetch</strong>. You choose a code, then press <strong>Fetch</strong>.
        Decryption happens locally in your browser.
      </p>

      <div class="panel">
        <p class="panel-title">Sign in</p>
        <p class="panel-sub">
          Signed envelopes require sign-in. Rolling inbox is intentionally not shown here.
        </p>

        <div class="actions">
          <button class="btn btn-lg btn-primary" id="btn-google" type="button">Google</button>
          <button class="btn btn-lg btn-quiet" id="btn-sign-out" type="button" disabled>Sign out</button>
          <span class="kbd" id="auth-pill">Not signed in</span>
        </div>

        <small class="help">
          Fetch is read-only. Consume is explicit.
        </small>
      </div>

      <div class="status" role="status" aria-live="polite">
        <div class="status-title">
          <span class="dot" id="status-dot"></span>
          <span id="status-title">Ready</span>
        </div>
        <p class="status-line" id="status-line">Sign in to fetch signed inbox messages.</p>
      </div>

      <div id="inbox-ui" class="hidden">
        <h2>Fetch signed envelopes</h2>

        <div class="row">
          <div class="col">
            <div class="field">
              <label for="code-input">Secure or Personal code</label>
              <input id="code-input" type="text" inputmode="text" placeholder="Paste SF-… or SFS-…" />
            </div>

            <div class="msg-toolbar">
              <div class="left">
                <button class="btn btn-primary" id="btn-fetch" type="button">Fetch</button>
                <button class="btn btn-quiet" id="btn-clear" type="button">Clear</button>
              </div>
              <div class="right">
                <span class="kbd" id="count-pill">0 messages</span>
              </div>
            </div>

            <small class="help">
              Fetch calls <strong>fetchSignedEnvelopes</strong> with your code hash. Decrypt happens locally.
            </small>
          </div>

          <div class="col">
            <div class="panel">
              <p class="panel-title">Delvex</p>
              <p class="panel-sub">
                “Open” runs a small ritual animation before revealing plaintext.
              </p>
              <ul>
                <li>No autoplay network.</li>
                <li>Reveal is local after decrypt.</li>
                <li>Consume is explicit.</li>
              </ul>
            </div>
          </div>
        </div>

        <h2 style="margin-top: var(--s-6);">Messages</h2>
        <div class="msg-list" id="msg-list"></div>
      </div>

      <footer>
        <div>© <span id="y"></span> Setfeed</div>
        <div>
          <a href="./security.html">Security</a>
          <span class="sep">·</span>
          <a href="./privacy.html">Privacy</a>
          <span class="sep">·</span>
          <a href="mailto:security@setfeed.app">security@setfeed.app</a>
        </div>
      </footer>
    </div>
  </div>

  <!-- Delvex opening modal -->
  <div class="delvex-backdrop" id="delvex-modal" role="dialog" aria-modal="true" aria-labelledby="delvex-title">
    <div class="delvex-modal">
      <div class="delvex-head">
        <div class="delvex-title" id="delvex-title">
          <span class="delvex-badge">Delvex</span>
          <span id="delvex-who">Opening…</span>
        </div>
        <button class="btn btn-quiet" id="delvex-close" type="button">Close</button>
      </div>

      <div class="delvex-body">
        <div class="delvex-stage" id="delvex-stage">
          <div class="delvex-bolt" aria-hidden="true">
            <svg viewBox="0 0 64 64" role="img" aria-hidden="true">
              <path class="bolt-fill" d="M36 2L10 36h18l-4 26 30-40H36l4-20z"/>
            </svg>
          </div>

          <div class="delvex-confetti" id="delvex-confetti" aria-hidden="true">
            <i style="left:12%; top:22%"></i>
            <i style="left:22%; top:58%"></i>
            <i style="left:35%; top:18%"></i>
            <i style="left:48%; top:64%"></i>
            <i style="left:62%; top:26%"></i>
            <i style="left:74%; top:56%"></i>
            <i style="left:86%; top:34%"></i>
          </div>

          <div class="delvex-envelope" aria-hidden="true">
            <div class="delvex-flap"></div>
          </div>

          <div class="delvex-reveal" id="delvex-reveal">
            <h3 style="margin-top:0;">Message</h3>
            <p id="delvex-text"></p>
            <small class="help" style="margin-top:10px;">
              Shared opening can be its own route later (ritual replay / invite link / ad slot).
            </small>
          </div>
        </div>
      </div>

      <div class="delvex-actions">
        <button class="btn btn-secondary" id="delvex-consume" type="button">Consume</button>
        <button class="btn btn-primary" id="delvex-ok" type="button">Done</button>
      </div>
    </div>
  </div>

  <script>
    document.getElementById("y").textContent = new Date().getFullYear();

    const statusDot = document.getElementById("status-dot");
    const statusTitle = document.getElementById("status-title");
    const statusLine = document.getElementById("status-line");

    function setStatus(kind, title, line) {
      statusDot.className = "dot";
      if (kind === "good") statusDot.classList.add("good");
      if (kind === "warn") statusDot.classList.add("warn");
      statusTitle.textContent = title;
      statusLine.textContent = line;
    }

    const AUTH_KEY = "sf_signed_authed";

    const btnGoogle = document.getElementById("btn-google");
    const btnSignOut = document.getElementById("btn-sign-out");
    const authPill = document.getElementById("auth-pill");
    const inboxUi = document.getElementById("inbox-ui");

    function setSignedAuthedFlag(isAuthed) {
      try { localStorage.setItem(AUTH_KEY, isAuthed ? "true" : "false"); } catch (_) {}
      document.querySelectorAll(".auth-only").forEach(el => el.classList.toggle("hidden", !isAuthed));
    }

    function renderAuthUI(user){
      const isAuthed = !!user;
      setSignedAuthedFlag(isAuthed);

      btnSignOut.disabled = !isAuthed;
      inboxUi.classList.toggle("hidden", !isAuthed);
      authPill.textContent = isAuthed ? (user.email || "Signed in") : "Not signed in";

      if (isAuthed) setStatus("good", "Signed in", "Paste a Secure/Personal code and press Fetch.");
      else setStatus("warn", "Not signed in", "Sign in to fetch signed inbox messages.");
    }

    auth.onAuthStateChanged((user) => renderAuthUI(user));

    btnGoogle.addEventListener("click", async () => {
      try {
        setStatus("good", "Signing in…", "Opening Google sign-in…");
        const provider = new firebase.auth.GoogleAuthProvider();
        provider.setCustomParameters({ prompt: "select_account" });
        await auth.signInWithPopup(provider);
        setStatus("good", "Signed in", "You can fetch signed envelopes now.");
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t sign in", "Google sign-in failed. Check pop-up blocking and try again.");
      }
    });

    btnSignOut.addEventListener("click", async () => {
      try {
        await auth.signOut();
        setStatus("warn", "Signed out", "Sign in again to fetch signed inbox messages.");
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t sign out", "Try again.");
      }
    });

    // Crypto helpers (unchanged from your version)
    function normalizeCodeAndroid(raw) { return raw.trim().toUpperCase().replace(/[\s-]/g, ""); }

    function b64ToBytes(b64) {
      const bin = atob(b64);
      const out = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
      return out;
    }

    async function sha256Hex(str) {
      const data = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function deriveAesKeyFromPassphrase(passphrase, saltBytes) {
      const passBytes = new TextEncoder().encode(passphrase);
      const baseKey = await crypto.subtle.importKey("raw", passBytes, { name: "PBKDF2" }, false, ["deriveKey"]);
      return await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: saltBytes, iterations: 100000, hash: "SHA-256" },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["decrypt"]
      );
    }

    async function decryptEnvelopeForCode(rawCode, ciphertextB64, ivB64, saltB64) {
      try {
        const passphrase = normalizeCodeAndroid(rawCode);
        const salt = b64ToBytes(saltB64);
        const iv = b64ToBytes(ivB64);
        const ct = b64ToBytes(ciphertextB64);
        const key = await deriveAesKeyFromPassphrase(passphrase, salt);
        const pt = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
        return new TextDecoder().decode(pt);
      } catch (_) {
        return null;
      }
    }

    function safeText(s) {
      const v = (s == null) ? "" : String(s);
      return v.replace(/[&<>"']/g, (c) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    }

    function formatWhen(deliverAtUtc, deliverAtLocalIso) {
      const src = deliverAtLocalIso || deliverAtUtc;
      if (!src) return "—";
      try {
        const d = new Date(src);
        if (Number.isNaN(d.getTime())) return "—";
        return d.toLocaleString(undefined, { weekday:"short", month:"short", day:"numeric", hour:"numeric", minute:"2-digit" });
      } catch (_) { return "—"; }
    }

    const codeInput = document.getElementById("code-input");
    const btnFetch = document.getElementById("btn-fetch");
    const btnClear = document.getElementById("btn-clear");
    const msgList = document.getElementById("msg-list");
    const countPill = document.getElementById("count-pill");

    function renderEmpty(){
      msgList.innerHTML = `
        <div class="panel">
          <p class="panel-title">No messages</p>
          <p class="panel-sub">Fetch will show messages only if the code matches and there are unconsumed signed envelopes.</p>
          <small class="help">Tip: make sure you pasted the exact code used to send.</small>
        </div>
      `;
      countPill.textContent = "0 messages";
    }
    renderEmpty();

    // Delvex modal hooks
    const delvexModal = document.getElementById("delvex-modal");
    const delvexClose = document.getElementById("delvex-close");
    const delvexOk = document.getElementById("delvex-ok");
    const delvexStage = document.getElementById("delvex-stage");
    const delvexText = document.getElementById("delvex-text");
    const delvexWho = document.getElementById("delvex-who");
    const delvexConsume = document.getElementById("delvex-consume");

    let delvexActiveEnvelopeId = null;
    let delvexActiveCardEl = null;

    function delvexHide(){
      delvexModal.classList.remove("show");
      delvexStage.classList.remove("is-playing");
      delvexStage.classList.remove("is-revealed");
      delvexText.textContent = "";
      delvexWho.textContent = "Opening…";
      delvexConsume.disabled = false;
      delvexConsume.textContent = "Consume";
      delvexActiveEnvelopeId = null;
      delvexActiveCardEl = null;
    }

    function delvexShow({ envelopeId, body, senderUid }){
      delvexActiveEnvelopeId = envelopeId;
      delvexWho.textContent = senderUid ? `From ${senderUid}` : "A surprise drop";
      delvexText.textContent = "";

      delvexModal.classList.add("show");
      delvexStage.classList.remove("is-playing");
      delvexStage.classList.remove("is-revealed");

      requestAnimationFrame(() => {
        delvexStage.classList.add("is-playing");
        setTimeout(() => {
          delvexText.textContent = body || "";
          delvexStage.classList.add("is-revealed");
        }, 920);
      });
    }

    delvexClose.addEventListener("click", delvexHide);
    delvexOk.addEventListener("click", delvexHide);
    delvexModal.addEventListener("click", (e) => { if (e.target === delvexModal) delvexHide(); });
    window.addEventListener("keydown", (e) => { if (e.key === "Escape") delvexHide(); });

    delvexConsume.addEventListener("click", async () => {
      if (!delvexActiveEnvelopeId) return;

      delvexConsume.disabled = true;
      delvexConsume.textContent = "Consuming…";

      try {
        const callable = functions.httpsCallable("markSignedEnvelopeConsumed");
        await callable({ signedEnvelopeId: delvexActiveEnvelopeId });

        delvexConsume.textContent = "Consumed";

        if (delvexActiveCardEl) delvexActiveCardEl.remove();
        const remaining = msgList.querySelectorAll(".msg-card").length;
        countPill.textContent = `${remaining} message${remaining === 1 ? "" : "s"}`;
        if (remaining === 0) renderEmpty();
      } catch (e) {
        console.error(e);
        delvexConsume.disabled = false;
        delvexConsume.textContent = "Consume";
        setStatus("warn", "Couldn’t consume", "Try again. Session may have expired.");
      }
    });

    async function fetchSignedEnvelopesForCode(rawCode) {
      const normalized = normalizeCodeAndroid(rawCode);
      const codeHash = await sha256Hex(normalized);

      const callable = functions.httpsCallable("fetchSignedEnvelopes");
      const res = await callable({ codeHash });

      const payload = (res && res.data) ? res.data : {};
      return Array.isArray(payload.envelopes) ? payload.envelopes : [];
    }

    function renderMessages(items){
      msgList.innerHTML = "";

      if (!items || items.length === 0) { renderEmpty(); return; }

      countPill.textContent = `${items.length} message${items.length === 1 ? "" : "s"}`;

      for (const it of items) {
        const when = formatWhen(it.deliverAtUtc, it.deliverAtLocalIso);
        const sender = it.senderUid ? `Sender: ${it.senderUid}` : "Sender: —";

        const card = document.createElement("div");
        card.className = "msg-card";

        card.innerHTML = `
          <div class="msg-top">
            <div class="msg-title">Message</div>
            <div class="msg-meta">
              <span>Deliver: ${safeText(when)}</span>
              <span>${safeText(sender)}</span>
            </div>
          </div>

          <div class="msg-body">${safeText(it.body)}</div>

          <div class="msg-actions">
            <button class="btn btn-secondary" type="button" data-open="${safeText(it.signedEnvelopeId)}">Open</button>
            <button class="btn btn-quiet" type="button" data-consume="${safeText(it.signedEnvelopeId)}">Consume</button>
          </div>
        `;

        msgList.appendChild(card);
      }

      msgList.querySelectorAll("button[data-open]").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.getAttribute("data-open");
          if (!id) return;
          const found = items.find(x => x.signedEnvelopeId === id);
          if (!found) return;

          delvexActiveCardEl = btn.closest(".msg-card") || null;
          delvexShow({ envelopeId: found.signedEnvelopeId, body: found.body, senderUid: found.senderUid });
        });
      });

      msgList.querySelectorAll("button[data-consume]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-consume");
          if (!id) return;

          btn.disabled = true;
          btn.textContent = "Consuming…";

          try {
            const callable = functions.httpsCallable("markSignedEnvelopeConsumed");
            await callable({ signedEnvelopeId: id });

            const card = btn.closest(".msg-card");
            if (card) card.remove();

            const remaining = msgList.querySelectorAll(".msg-card").length;
            countPill.textContent = `${remaining} message${remaining === 1 ? "" : "s"}`;
            if (remaining === 0) renderEmpty();
          } catch (e) {
            console.error(e);
            btn.disabled = false;
            btn.textContent = "Consume";
            setStatus("warn", "Couldn’t consume", "Try again. Session may have expired.");
          }
        });
      });
    }

    btnFetch.addEventListener("click", async () => {
      if (!auth.currentUser) { setStatus("warn", "Sign-in required", "Sign in to fetch signed inbox messages."); return; }

      const rawCode = codeInput.value.trim();
      if (!rawCode) { setStatus("warn", "Code needed", "Paste a Secure/Personal code first."); return; }

      btnFetch.disabled = true;
      btnFetch.textContent = "Fetching…";

      try {
        setStatus("good", "Fetching…", "Calling fetchSignedEnvelopes…");
        const envelopes = await fetchSignedEnvelopesForCode(rawCode);

        const out = [];
        for (const env of envelopes) {
          const ciphertext = env.ciphertext || env.ciphertextB64;
          const iv = env.iv || env.ivB64;
          const salt = env.salt || env.saltB64;
          if (!ciphertext || !iv || !salt) continue;

          const pt = await decryptEnvelopeForCode(rawCode, ciphertext, iv, salt);
          if (pt == null) continue;

          out.push({
            signedEnvelopeId: env.signedEnvelopeId,
            senderUid: env.senderUid || null,
            deliverAtUtc: env.deliverAtUtc || null,
            deliverAtLocalIso: env.deliverAtLocalIso || null,
            body: pt
          });
        }

        if (out.length === 0) setStatus("warn", "No messages", "Either there are no unconsumed envelopes, or the code doesn’t match.");
        else setStatus("good", "Fetched", "Messages decrypted locally. Open to reveal with Delvex.");

        renderMessages(out);
      } catch (e) {
        console.error(e);
        setStatus("warn", "Fetch failed", (e && e.message) ? e.message : "Fetch failed. Try again.");
      } finally {
        btnFetch.disabled = false;
        btnFetch.textContent = "Fetch";
      }
    });

    btnClear.addEventListener("click", () => {
      codeInput.value = "";
      renderEmpty();
      setStatus("warn", "Cleared", "Inbox cleared. Paste a code and press Fetch.");
    });

    setStatus("good", "Ready", "Sign in to fetch signed inbox messages.");
  </script>
</body>
</html>
