<!-- inbox.html (FULL FILE REPLACEMENT) -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Inbox — Setfeed</title>
  <meta name="description" content="Your Setfeed inbox feed (signed-in view)." />

  <meta name="theme-color" content="#FFFBFE" id="meta-theme-color" />

  <link rel="icon" href="./favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="./favicon-32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="./favicon-16.png" sizes="16x16">
  <link rel="apple-touch-icon" href="./apple-touch-icon.png" sizes="180x180">

  <link rel="stylesheet" href="./styles.css" />

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-check-compat.js"></script>

  <script>
    // Firebase config (same as send.html)
    const firebaseConfig = {
      apiKey: "AIzaSyCECKG-00tijJrt5qvRy3L27ZzE7bocNrU",
      authDomain: "setfeed-fcd7a.firebaseapp.com",
      projectId: "setfeed-fcd7a",
      storageBucket: "setfeed-fcd7a.firebasestorage.app",
      messagingSenderId: "553573263069",
      appId: "1:553573263069:web:e5c9884101ca38eaee1d34"
    };

    // TODO: replace with your real App Check reCAPTCHA v3 site key
    const RECAPTCHA_SITE_KEY = "PLACEHOLDER";

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const functions = firebase.app().functions("europe-west2");

    function startAppCheck() {
      try {
        firebase.appCheck().activate(RECAPTCHA_SITE_KEY, true);
      } catch (e) {
        console.warn("[AppCheck] init failed:", e);
      }
    }
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", startAppCheck, { once: true });
    } else {
      startAppCheck();
    }
  </script>

  <script>
    (function(){
      const themeKey = "sf_theme_mode"; // "system" | "light" | "dark"
      const stored = localStorage.getItem(themeKey) || "system";
      const root = document.documentElement;

      if (stored === "light" || stored === "dark") root.setAttribute("data-theme", stored);
      else root.removeAttribute("data-theme");

      const effective =
        root.getAttribute("data-theme") ||
        (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");

      const meta = document.getElementById("meta-theme-color");
      if (meta) meta.content = (effective === "dark") ? "#0F1114" : "#FFFBFE";
    })();
  </script>

  <style>
    .hidden{ display:none !important; }

    .inbox-actions{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
      margin-top: var(--s-3);
      margin-bottom: var(--s-4);
    }

    .sf-kv{
      display:flex;
      flex-direction: column;
      gap: 6px;
      margin-top: var(--s-3);
    }
    .sf-kv small{
      color: rgba(233,238,246,0.7);
    }

    .msg-list{
      display:flex;
      flex-direction: column;
      gap: 10px;
      margin-top: var(--s-4);
    }
    .msg-card{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      padding: 12px 12px;
      overflow: hidden;
    }
    .msg-top{
      display:flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      align-items: baseline;
      margin-bottom: 8px;
    }
    .msg-title{
      font-weight: 700;
    }
    .msg-meta{
      font-size: 12px;
      color: rgba(233,238,246,0.75);
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .msg-body{
      white-space: pre-wrap;
      line-height: 1.35;
    }
    .msg-actions{
      display:flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .pill-quiet{
      display:inline-block;
      border-radius: 999px;
      padding: 6px 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      font-weight: 650;
      font-size: 12px;
      color: rgba(233,238,246,0.85);
    }
  </style>
</head>

<body class="page-bg">
  <header class="site-header">
    <div class="header-inner">
      <a class="brand-mark" href="./" aria-label="Setfeed home">
        <img class="logo" src="./logo.png" alt="" aria-hidden="true" />
      </a>

      <a class="brand-title" href="./">Setfeed</a>

      <nav class="nav" aria-label="Primary">
        <a href="./">Home</a>
        <a href="./send.html">Send</a>
        <a href="./receive.html">Receive</a>
        <a class="auth-only hidden" href="./inbox.html" aria-current="page">Inbox</a>
        <a href="./security.html">Security</a>
        <a href="./privacy.html">Privacy</a>
        <a class="nav-cta" href="#" aria-label="Download Setfeed app">Download app</a>
      </nav>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <h1>Inbox</h1>
      <p class="lead">
        This is a signed-in web inbox for Signed envelopes. It fetches explicitly when you press Fetch.
      </p>

      <!-- Gate (signed out) -->
      <div class="panel" id="inbox-gate">
        <p class="panel-title">Sign in required</p>
        <p class="panel-sub">
          Inbox is available only after you sign in.
        </p>

        <div class="actions">
          <button class="btn btn-lg btn-primary" id="btn-google" type="button">Sign in with Google</button>
          <a class="btn btn-lg btn-quiet" href="./send.html#signin">Use email sign-in</a>
        </div>

        <small class="help">
          After sign-in, paste your Secure or Personal receive code below to fetch and decrypt messages addressed to it.
        </small>
      </div>

      <!-- Content (signed in) -->
      <div id="inbox-content" class="hidden">
        <div class="status" role="status" aria-live="polite">
          <div class="status-title">
            <span class="dot good" id="status-dot"></span>
            <span id="status-title">Signed in</span>
          </div>
          <p class="status-line" id="status-line">
            Paste your Secure/Personal code and press Fetch.
          </p>
        </div>

        <div class="panel" style="margin-top: var(--s-5);">
          <p class="panel-title">Receive code (for decrypting)</p>
          <p class="panel-sub" style="margin-bottom: var(--s-3);">
            This code never leaves your browser as plaintext. We hash it to fetch, and use it locally to decrypt.
          </p>

          <div class="field">
            <label for="inbox-code">Secure or Personal code</label>
            <input id="inbox-code" type="text" inputmode="text" placeholder="Paste a Secure (SFS-…) or Personal (SF-…) code" />
          </div>

          <div class="inbox-actions">
            <span class="pill-quiet" id="whoami">Signed in</span>
            <button class="btn btn-lg btn-primary" id="btn-fetch" type="button" disabled>Fetch</button>
            <button class="btn btn-lg btn-quiet" id="btn-sign-out" type="button">Sign out</button>
          </div>

          <small class="help">
            Delven (2–3 min) messages will only show up precisely if the recipient (or this page) fetches while the envelope is still unconsumed.
          </small>
        </div>

        <h2 style="margin-top: var(--s-6);">Messages</h2>
        <div class="msg-list" id="msg-list"></div>

        <div class="panel" style="margin-top: var(--s-5);">
          <p class="panel-title">Expected behavior</p>
          <ul>
            <li>Explicit fetch only (no surprise network).</li>
            <li>Stable ordering and clear failures.</li>
            <li>Consume is explicit per message.</li>
          </ul>
          <small class="help">
            This web inbox reads from <code>signed_envelopes</code> via callable functions.
          </small>
        </div>
      </div>

      <footer>
        <div>© <span id="y"></span> Setfeed</div>
        <div>
          <a href="./security.html">Security</a>
          <span class="sep">·</span>
          <a href="./privacy.html">Privacy</a>
          <span class="sep">·</span>
          <a href="mailto:security@setfeed.app">security@setfeed.app</a>
        </div>
      </footer>
    </div>
  </div>

  <script>
    document.getElementById("y").textContent = new Date().getFullYear();

    const AUTH_KEY = "sf_signed_authed";

    const elGate = document.getElementById("inbox-gate");
    const elContent = document.getElementById("inbox-content");

    const btnGoogle = document.getElementById("btn-google");
    const btnSignOut = document.getElementById("btn-sign-out");
    const btnFetch = document.getElementById("btn-fetch");

    const statusDot = document.getElementById("status-dot");
    const statusTitle = document.getElementById("status-title");
    const statusLine = document.getElementById("status-line");

    const inboxCode = document.getElementById("inbox-code");
    const whoami = document.getElementById("whoami");
    const msgList = document.getElementById("msg-list");

    function setStatus(kind, title, line) {
      statusDot.className = "dot";
      if (kind === "good") statusDot.classList.add("good");
      if (kind === "warn") statusDot.classList.add("warn");
      statusTitle.textContent = title;
      statusLine.textContent = line;
    }

    function normalizeCodeAndroid(raw) {
      return raw.trim().toUpperCase().replace(/[\s-]/g, "");
    }

    function bytesToB64(bytes) {
      let binary = "";
      const chunk = 0x8000;
      for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode(...bytes.subarray(i, i + chunk));
      }
      return btoa(binary);
    }
    function abToB64(ab) { return bytesToB64(new Uint8Array(ab)); }

    function b64ToBytes(b64) {
      const bin = atob(b64);
      const bytes = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) bytes[i] = bin.charCodeAt(i);
      return bytes;
    }

    async function sha256Hex(str) {
      const data = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function deriveAesKeyFromPassphrase(passphrase, saltBytes) {
      const passBytes = new TextEncoder().encode(passphrase);
      const baseKey = await crypto.subtle.importKey("raw", passBytes, { name: "PBKDF2" }, false, ["deriveKey"]);
      return await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: saltBytes, iterations: 100000, hash: "SHA-256" },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["decrypt"]
      );
    }

    async function decryptBodyForCode(rawCode, ciphertextB64, ivB64, saltB64) {
      const passphrase = normalizeCodeAndroid(rawCode);
      const salt = b64ToBytes(saltB64);
      const iv = b64ToBytes(ivB64);
      const ct = b64ToBytes(ciphertextB64);

      const key = await deriveAesKeyFromPassphrase(passphrase, salt);
      const pt = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
      return new TextDecoder().decode(pt);
    }

    function setSignedAuthedFlag(isAuthed) {
      try { localStorage.setItem(AUTH_KEY, isAuthed ? "true" : "false"); } catch (_) {}
      document.querySelectorAll(".auth-only").forEach(el => el.classList.toggle("hidden", !isAuthed));
    }

    function renderAuthedUI(user) {
      const isAuthed = !!user;

      setSignedAuthedFlag(isAuthed);

      if (elGate) elGate.classList.toggle("hidden", isAuthed);
      if (elContent) elContent.classList.toggle("hidden", !isAuthed);

      if (whoami) {
        whoami.textContent = isAuthed ? (user.email || "Signed in") : "Signed out";
      }

      btnFetch.disabled = !isAuthed || inboxCode.value.trim().length === 0;

      if (!isAuthed) {
        setStatus("warn", "Signed out", "Sign in to view Inbox.");
        msgList.innerHTML = "";
      } else {
        setStatus("good", "Signed in", "Paste your code and press Fetch.");
      }
    }

    auth.onAuthStateChanged((user) => {
      renderAuthedUI(user);
    });

    btnGoogle.addEventListener("click", async () => {
      try {
        setStatus("good", "Signing in…", "Opening Google sign-in…");
        const provider = new firebase.auth.GoogleAuthProvider();
        provider.setCustomParameters({ prompt: "select_account" });
        await auth.signInWithPopup(provider);
        setStatus("good", "Signed in", "Paste your code and press Fetch.");
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t sign in", "Google sign-in failed. Check pop-up blocking and try again.");
      }
    });

    btnSignOut.addEventListener("click", async () => {
      try {
        await auth.signOut();
      } catch (e) {
        console.error(e);
      }
    });

    inboxCode.addEventListener("input", () => {
      btnFetch.disabled = !auth.currentUser || inboxCode.value.trim().length === 0;
    });

    function safeText(s) {
      return (s || "").toString();
    }

    function fmtWhen(isoOrUtc) {
      if (!isoOrUtc) return "—";
      try {
        const d = new Date(isoOrUtc);
        if (Number.isNaN(d.getTime())) return isoOrUtc;
        return d.toLocaleString(undefined, { year:"numeric", month:"short", day:"numeric", hour:"numeric", minute:"2-digit" });
      } catch {
        return isoOrUtc;
      }
    }

    function renderEmpty() {
      msgList.innerHTML = `
        <div class="panel">
          <p class="panel-title">No messages</p>
          <p class="panel-sub">Nothing unconsumed was found for this code hash.</p>
          <small class="help">Try again after a Delven send, or confirm the code is correct.</small>
        </div>
      `;
    }

    function renderError(title, detail) {
      msgList.innerHTML = `
        <div class="panel">
          <p class="panel-title">${safeText(title)}</p>
          <p class="panel-sub">${safeText(detail)}</p>
        </div>
      `;
    }

    function renderMessages(items) {
      if (!items || items.length === 0) {
        renderEmpty();
        return;
      }

      msgList.innerHTML = "";
      for (const it of items) {
        const card = document.createElement("div");
        card.className = "msg-card";

        const when = fmtWhen(it.deliverAtUtc || it.deliverAtLocalIso);
        const sender = it.senderUid ? `Sender: ${it.senderUid}` : "Sender: —";

        card.innerHTML = `
          <div class="msg-top">
            <div class="msg-title">Message</div>
            <div class="msg-meta">
              <span>Deliver: ${safeText(when)}</span>
              <span>${safeText(sender)}</span>
            </div>
          </div>
          <div class="msg-body">${safeText(it.body)}</div>
          <div class="msg-actions">
            <button class="btn btn-secondary" type="button" data-consume="${safeText(it.signedEnvelopeId)}">Consume</button>
          </div>
        `;

        msgList.appendChild(card);
      }

      msgList.querySelectorAll("button[data-consume]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const id = btn.getAttribute("data-consume");
          if (!id) return;

          btn.disabled = true;
          btn.textContent = "Consuming…";

          try {
            const callable = functions.httpsCallable("markSignedEnvelopeConsumed");
            await callable({ signedEnvelopeId: id });

            btn.textContent = "Consumed";
            // remove the card (calm)
            const parent = btn.closest(".msg-card");
            if (parent) parent.remove();

            if (!msgList.querySelector(".msg-card")) renderEmpty();
          } catch (e) {
            console.error(e);
            btn.disabled = false;
            btn.textContent = "Consume";
            setStatus("warn", "Couldn’t consume", "Try again. App Check may be required or session may have expired.");
          }
        });
      });
    }

    btnFetch.addEventListener("click", async () => {
      const user = auth.currentUser;
      if (!user) {
        setStatus("warn", "Sign-in required", "Sign in to fetch inbox messages.");
        return;
      }

      const rawCode = inboxCode.value.trim();
      if (!rawCode) {
        setStatus("warn", "Code needed", "Paste your Secure or Personal code.");
        return;
      }

      try {
        setStatus("good", "Fetching…", "Looking for unconsumed signed envelopes…");
        msgList.innerHTML = "";

        const normalized = normalizeCodeAndroid(rawCode);
        const codeHash = await sha256Hex(normalized);

        const callable = functions.httpsCallable("fetchSignedEnvelopes");
        const res = await callable({ codeHash });

        const payload = res && res.data ? res.data : {};
        const envelopes = (payload.envelopes && Array.isArray(payload.envelopes)) ? payload.envelopes : [];

        if (envelopes.length === 0) {
          setStatus("good", "Fetched", "No unconsumed messages found.");
          renderEmpty();
          return;
        }

        // Decrypt locally
        const decrypted = [];
        for (const env of envelopes) {
          const ciphertext = env.ciphertext || env.ciphertextB64;
          const iv = env.iv || env.ivB64;
          const salt = env.salt || env.saltB64;
          const signedEnvelopeId = env.signedEnvelopeId;

          if (!ciphertext || !iv || !salt || !signedEnvelopeId) continue;

          try {
            const body = await decryptBodyForCode(rawCode, ciphertext, iv, salt);
            decrypted.push({
              signedEnvelopeId,
              body,
              deliverAtUtc: env.deliverAtUtc || null,
              deliverAtLocalIso: env.deliverAtLocalIso || null,
              senderUid: env.senderUid || null
            });
          } catch (e) {
            console.warn("decrypt failed:", e);
          }
        }

        if (decrypted.length === 0) {
          setStatus("warn", "Fetched", "Envelopes found, but none could be decrypted with this code.");
          renderError("Couldn’t decrypt", "Verify you pasted the correct code (including prefix).");
          return;
        }

        setStatus("good", "Fetched", `Decrypted ${decrypted.length} message(s).`);
        renderMessages(decrypted);
      } catch (e) {
        console.error(e);
        const msg = (e && e.message) ? e.message : "Fetch failed. Try again.";
        setStatus("warn", "Couldn’t fetch", msg);
        renderError("Fetch failed", msg);
      }
    });

    // Initial state
    setStatus("good", "Ready", "Sign in to use Inbox.");
  </script>
</body>
</html>
