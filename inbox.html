<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Inbox — Setfeed</title>
  <meta name="description" content="Your Setfeed inbox feed (signed-in view)." />

  <meta name="theme-color" content="#FFFBFE" id="meta-theme-color" />

  <link rel="icon" href="./favicon.ico" sizes="any">
  <link rel="icon" type="image/png" href="./favicon-32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="./favicon-16.png" sizes="16x16">
  <link rel="apple-touch-icon" href="./apple-touch-icon.png" sizes="180x180">

  <link rel="stylesheet" href="./styles.css" />

  <!-- FIREBASE (AUTH + FUNCTIONS) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-functions-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyCECKG-00tijJrt5qvRy3L27ZzE7bocNrU",
      authDomain: "setfeed-fcd7a.firebaseapp.com",
      projectId: "setfeed-fcd7a",
      storageBucket: "setfeed-fcd7a.firebasestorage.app",
      messagingSenderId: "553573263069",
      appId: "1:553573263069:web:e5c9884101ca38eaee1d34"
    };

    if (!firebase.apps || firebase.apps.length === 0) firebase.initializeApp(firebaseConfig);

    const functions = firebase.app().functions("europe-west2");
    const auth = firebase.auth();
  </script>

  <!-- THEME -->
  <script>
    (function(){
      const THEME_KEY = "sf_theme_mode";
      const root = document.documentElement;

      function applyTheme(){
        let stored = "system";
        try { stored = localStorage.getItem(THEME_KEY) || "system"; } catch (_) {}

        if (stored === "light" || stored === "dark") root.setAttribute("data-theme", stored);
        else root.removeAttribute("data-theme");

        const effective =
          root.getAttribute("data-theme") ||
          (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");

        const meta = document.getElementById("meta-theme-color");
        if (meta) meta.content = (effective === "dark") ? "#0F1114" : "#FFFBFE";
      }

      applyTheme();
      window.addEventListener("storage", (e) => { if (e && e.key === THEME_KEY) applyTheme(); });
    })();
  </script>

  <style>
    .hidden{ display:none !important; }

    /* Route container */
    .sf-route { display:none; }
    .sf-route.show { display:block; }

    /* Make inbox content start “at the top” of the card */
    .sf-inbox-top { margin-top: var(--s-3); }

    /* Section header */
    .sf-section-head{
      display:flex;
      align-items:baseline;
      justify-content: space-between;
      gap: 10px;
      margin-top: var(--s-5);
      margin-bottom: var(--s-3);
    }
    .sf-section-head h2{ margin:0; }
    .sf-pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      border-radius: 999px;
      padding: 6px 10px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(233,238,246,0.92);
      font-weight: 650;
      font-size: 12px;
      white-space: nowrap;
    }

    /* Cards */
    .sf-msg-card{
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      padding: 12px;
      margin-bottom: 10px;
      position: relative;
      overflow:hidden;
      touch-action: pan-y;
      user-select:none;
    }
    .sf-msg-top{
      display:flex;
      justify-content: space-between;
      gap:10px;
      align-items:flex-start;
    }
    .sf-msg-title{
      font-weight: 750;
      letter-spacing: -0.01em;
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      min-width: 0;
    }
    .sf-msg-title-text{
      min-width: 0;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 44ch;
    }
    .sf-msg-meta{
      display:flex;
      flex-direction: column;
      gap: 2px;
      text-align:right;
      font-size: 12px;
      color: rgba(233,238,246,0.75);
    }
    .sf-msg-body{
      margin-top: 8px;
      color: rgba(233,238,246,0.90);
      line-height: 1.35;
      font-size: 14px;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .sf-msg-actions{
      margin-top: 10px;
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items:center;
    }

    /* Swipe affordance */
    .sf-swipe-bg{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content: space-between;
      padding: 0 14px;
      pointer-events:none;
      opacity: 0;
      transition: opacity 120ms ease;
    }
    .sf-swipe-bg.show{ opacity: 1; }
    .sf-swipe-left, .sf-swipe-right{
      font-weight: 800;
      font-size: 12px;
      letter-spacing: 0.02em;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(233,238,246,0.92);
    }
    .sf-swipe-right{ border-color: rgba(59,130,246,0.40); box-shadow: 0 0 0 4px rgba(59,130,246,0.10); }
    .sf-swipe-left{ border-color: rgba(255,255,255,0.18); }

    .sf-drag{
      position: relative;
      transform: translateX(0);
      transition: transform 140ms ease;
      will-change: transform;
    }

    /* Context menu modal */
    .sf-modal-backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 9999;
    }
    .sf-modal-backdrop.show{ display:flex; }

    .sf-modal{
      width: min(520px, 100%);
      border-radius: 16px;
      background: var(--card, #14171c);
      color: var(--text, #e9eef6);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      border: 1px solid rgba(255,255,255,0.08);
      overflow: hidden;
    }
    .sf-modal-header{
      padding: 16px 16px 10px 16px;
      font-weight: 750;
      font-size: 16px;
    }
    .sf-modal-body{
      padding: 0 16px 16px 16px;
      color: rgba(233,238,246,0.86);
      line-height: 1.35;
      font-size: 14px;
      word-break: break-word;
    }
    .sf-modal-actions{
      display:flex;
      flex-wrap: wrap;
      justify-content: flex-end;
      gap: 10px;
      padding: 12px 16px 16px 16px;
    }
    .sf-modal-btn{
      border: 0;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 700;
      cursor:pointer;
      background: rgba(255,255,255,0.08);
      color: rgba(233,238,246,0.92);
    }
    .sf-modal-btn-primary{ background:#3b82f6; color:#fff; }
    .sf-modal-btn-danger{ background: rgba(255,85,85,0.18); color: rgba(255,220,220,0.95); border: 1px solid rgba(255,85,85,0.28); }
    .sf-modal-btn-quiet{ background: rgba(255,255,255,0.06); color: rgba(233,238,246,0.85); }

    .sf-mini-row{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content: space-between;
      margin-top: 10px;
    }

    /* ✅ toggles are buttons now (more reliable than div click targets) */
    .sf-toggle{
      appearance: none;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.05);
      color: rgba(233,238,246,0.90);
      border-radius: 14px;
      padding: 8px 10px;
      font-weight: 650;
      font-size: 13px;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:10px;
    }
    .sf-toggle:hover{ background: rgba(255,255,255,0.07); }
    .sf-toggle:active{ transform: translateY(0.5px); }

    /* ✅ message-kind pill */
    .sf-kind{
      display:inline-flex;
      align-items:center;
      gap:6px;
      border-radius: 999px;
      padding: 4px 8px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: rgba(233,238,246,0.92);
      font-weight: 800;
      font-size: 11px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    .sf-kind.delvee{
      border-color: rgba(59,130,246,0.40);
      box-shadow: 0 0 0 4px rgba(59,130,246,0.10);
    }
  </style>
</head>

<body class="page-bg">
  <header class="site-header">
    <div class="header-inner">
      <a class="brand-mark" href="./" aria-label="Setfeed home">
        <img class="logo" src="./logo.png" alt="" aria-hidden="true" />
      </a>

      <a class="brand-title" href="./">Setfeed</a>

      <nav class="nav" aria-label="Primary">
        <a href="./">Home</a>
        <a href="./send.html">Send</a>
        <a href="./receive.html">Receive</a>
        <a class="auth-only hidden" href="./inbox.html" aria-current="page">Inbox</a>
        <!-- ✅ Hidden tab is shown whenever authed (not dependent on hidden-count) -->
        <a class="auth-only hidden" id="nav-hidden" href="./inbox.html#hidden">Hidden</a>
        <a href="./security.html">Security</a>
        <a href="./privacy.html">Privacy</a>
        <a class="nav-cta" href="#" aria-label="Download Setfeed app">Download app</a>
      </nav>
    </div>
  </header>

  <div class="wrap">
    <div class="card">
      <h1>Inbox</h1>

      <div class="sf-inbox-top">
        <div class="status" role="status" aria-live="polite" id="status-bar">
          <div class="status-title">
            <span class="dot" id="status-dot"></span>
            <span id="status-title">Ready</span>
          </div>
          <p class="status-line" id="status-line">Sign in to fetch signed inbox messages.</p>
        </div>

        <!-- ROUTES -->
        <div id="route-inbox" class="sf-route show">
          <div id="inbox-ui" class="hidden">
            <div class="field" style="margin-top: var(--s-4);">
              <label for="code-input">Secure or Personal code</label>
              <input id="code-input" type="text" inputmode="text" placeholder="Paste SF-… or SFS-…" />
            </div>

            <div class="msg-toolbar">
              <div class="left">
                <button class="btn btn-primary" id="btn-fetch" type="button">Fetch</button>
                <button class="btn btn-secondary" id="btn-fetch-summaries" type="button">Fetch summaries</button>
                <button class="btn btn-quiet" id="btn-clear" type="button">Clear</button>
              </div>
              <div class="right">
                <span class="kbd" id="count-pill">0 messages</span>
              </div>
            </div>

            <div class="sf-mini-row">
              <button class="sf-toggle" id="btn-auto" type="button">
                <span id="auto-label">Auto polling: Off</span>
              </button>
              <button class="sf-toggle" id="btn-show-blocked" type="button">
                <span id="blocked-label">Hidden senders: Hidden</span>
              </button>
              <button class="sf-toggle" id="btn-summaries-only" type="button">
                <span id="summaries-label">Show: All</span>
              </button>
            </div>

            <!-- PINNED -->
            <div class="sf-section-head" id="head-pinned" style="display:none;">
              <h2>Pinned</h2>
              <span class="sf-pill" id="pill-pinned">0</span>
            </div>
            <div id="list-pinned"></div>

            <!-- UPCOMING -->
            <div class="sf-section-head">
              <h2>Upcoming</h2>
              <span class="sf-pill" id="pill-upcoming">0</span>
            </div>
            <div id="list-upcoming"></div>

            <!-- AWAITING -->
            <div class="sf-section-head">
              <h2>Awaiting</h2>
              <span class="sf-pill" id="pill-awaiting">0</span>
            </div>
            <div id="list-awaiting"></div>

            <!-- RELEASED -->
            <div class="sf-section-head">
              <h2>Released</h2>
              <span class="sf-pill" id="pill-released">0</span>
            </div>
            <div id="list-released"></div>

            <div class="panel" style="margin-top: var(--s-6);">
              <p class="panel-title">How it works</p>
              <p class="panel-sub">
                Swipe right on <strong>Upcoming</strong> → mark <strong>Awaiting</strong> (best-effort browser notifications).<br/>
                Swipe left on <strong>Upcoming</strong> → hide it until release.<br/>
                Long-press a <strong>Released</strong> message → pin / hide sender / hide message.
              </p>

              <small class="help">
                Signed envelopes require sign-in. Rolling inbox is intentionally not shown here.
              </small>
            </div>
          </div>
        </div>

        <div id="route-hidden" class="sf-route">
          <div id="hidden-ui" class="hidden">
            <h2 style="margin-top: var(--s-4);">Hidden messages</h2>
            <p class="lead">
              Hidden messages don’t show in Inbox. You can restore them here.
            </p>

            <div class="msg-toolbar">
              <div class="left">
                <button class="btn btn-quiet" id="btn-hidden-back" type="button">Back to Inbox</button>
                <button class="btn btn-secondary" id="btn-hidden-clearall" type="button">Clear hidden</button>
              </div>
              <div class="right">
                <span class="kbd" id="pill-hidden">0 hidden</span>
              </div>
            </div>

            <div id="list-hidden" style="margin-top: 10px;"></div>

            <small class="help" style="margin-top: 10px;">
              Hidden items are stored locally in this browser only.
            </small>
          </div>
        </div>
      </div>

      <div class="panel" style="margin-top: var(--s-6);">
        <p class="panel-title">Sign in</p>
        <p class="panel-sub">
          Signed inbox requires sign-in.
        </p>

        <div class="actions">
          <button class="btn btn-lg btn-primary" id="btn-google" type="button">Google</button>
          <button class="btn btn-lg btn-quiet" id="btn-sign-out" type="button" disabled>Sign out</button>
          <span class="kbd" id="auth-pill">Not signed in</span>
        </div>

        <small class="help">
          Fetch is read-only. Consume is explicit.
        </small>
      </div>

      <footer>
        <div>© <span id="y"></span> Setfeed</div>
        <div>
          <a href="./security.html">Security</a>
          <span class="sep">·</span>
          <a href="./privacy.html">Privacy</a>
          <span class="sep">·</span>
          <a href="mailto:security@setfeed.app">security@setfeed.app</a>
        </div>
      </footer>
    </div>
  </div>

  <!-- Delvee opening modal -->
  <div class="delvee-backdrop" id="delvee-modal" role="dialog" aria-modal="true" aria-labelledby="delvee-title">
    <div class="delvee-modal">
      <div class="delvee-head">
        <div class="delvee-title" id="delvee-title">
          <span class="delvee-badge">Delvee</span>
          <span id="delvee-who">Opening…</span>
        </div>
        <button class="btn btn-quiet" id="delvee-close" type="button">Close</button>
      </div>

      <div class="delvee-body">
        <div class="delvee-stage" id="delvee-stage">
          <div class="delvee-bolt" aria-hidden="true">
            <svg viewBox="0 0 64 64" role="img" aria-hidden="true">
              <path class="bolt-fill" d="M36 2L10 36h18l-4 26 30-40H36l4-20z"/>
            </svg>
          </div>

          <div class="delvee-confetti" id="delvee-confetti" aria-hidden="true">
            <i style="left:12%; top:22%"></i>
            <i style="left:22%; top:58%"></i>
            <i style="left:35%; top:18%"></i>
            <i style="left:48%; top:64%"></i>
            <i style="left:62%; top:26%"></i>
            <i style="left:74%; top:56%"></i>
            <i style="left:86%; top:34%"></i>
          </div>

          <div class="delvee-envelope" aria-hidden="true">
            <div class="delvee-flap"></div>
          </div>

          <div class="delvee-reveal" id="delvee-reveal">
            <h3 style="margin-top:0;" id="delvee-heading">Message</h3>
            <p id="delvee-text"></p>
            <small class="help" style="margin-top:10px;">
              Decryption is local in your browser.
            </small>
          </div>
        </div>
      </div>

      <div class="delvee-actions">
        <button class="btn btn-secondary" id="delvee-consume" type="button">Consume</button>
        <button class="btn btn-primary" id="delvee-ok" type="button">Done</button>
      </div>
    </div>
  </div>

  <!-- Context menu modal (Released only) -->
  <div class="sf-modal-backdrop" id="sf-actions-modal" role="dialog" aria-modal="true" aria-labelledby="sf-actions-title" aria-describedby="sf-actions-body">
    <div class="sf-modal">
      <div class="sf-modal-header" id="sf-actions-title">Message options</div>
      <div class="sf-modal-body" id="sf-actions-body">
        <div id="sf-actions-meta" style="font-size:12px; color: rgba(233,238,246,0.72); margin-bottom: 10px;"></div>
        <div id="sf-actions-preview" style="white-space: pre-wrap;"></div>
      </div>
      <div class="sf-modal-actions">
        <button class="sf-modal-btn" id="sf-btn-pin" type="button">Pin</button>
        <button class="sf-modal-btn" id="sf-btn-hide-msg" type="button">Hide message</button>
        <button class="sf-modal-btn" id="sf-btn-block-sender" type="button">Hide sender</button>
        <button class="sf-modal-btn sf-modal-btn-danger" id="sf-btn-consume" type="button">Consume</button>
        <button class="sf-modal-btn sf-modal-btn-primary" id="sf-btn-done" type="button">Done</button>
      </div>
    </div>
  </div>

  <script>
    document.getElementById("y").textContent = new Date().getFullYear();

    // -------------------------
    // Status helper
    // -------------------------
    const statusDot = document.getElementById("status-dot");
    const statusTitle = document.getElementById("status-title");
    const statusLine = document.getElementById("status-line");

    function setStatus(kind, title, line) {
      statusDot.className = "dot";
      if (kind === "good") statusDot.classList.add("good");
      if (kind === "warn") statusDot.classList.add("warn");
      statusTitle.textContent = title;
      statusLine.textContent = line;
    }

    // -------------------------
    // Routes
    // -------------------------
    const routeInbox = document.getElementById("route-inbox");
    const routeHidden = document.getElementById("route-hidden");
    const hiddenUi = document.getElementById("hidden-ui");
    const inboxUi = document.getElementById("inbox-ui");

    function showRoute(which){
      const isHidden = which === "hidden";
      routeInbox.classList.toggle("show", !isHidden);
      routeHidden.classList.toggle("show", isHidden);

      // Only show contents when authed
      hiddenUi.classList.toggle("hidden", !(auth.currentUser));
      inboxUi.classList.toggle("hidden", !(auth.currentUser) || isHidden);
    }

    function currentRoute(){
      return (window.location.hash || "").toLowerCase().includes("hidden") ? "hidden" : "inbox";
    }

    window.addEventListener("hashchange", () => showRoute(currentRoute()));

    // -------------------------
    // Auth
    // -------------------------
    const AUTH_KEY = "sf_signed_authed";

    const btnGoogle = document.getElementById("btn-google");
    const btnSignOut = document.getElementById("btn-sign-out");
    const authPill = document.getElementById("auth-pill");
    const inboxNav = document.querySelectorAll(".auth-only");
    const navHidden = document.getElementById("nav-hidden");

    function setSignedAuthedFlag(isAuthed) {
      try { localStorage.setItem(AUTH_KEY, isAuthed ? "true" : "false"); } catch (_) {}
      inboxNav.forEach(el => el.classList.toggle("hidden", !isAuthed));
    }

    function renderAuthUI(user){
      const isAuthed = !!user;
      setSignedAuthedFlag(isAuthed);

      btnGoogle.classList.toggle("hidden", isAuthed);
      btnSignOut.disabled = !isAuthed;

      inboxUi.classList.toggle("hidden", !isAuthed);
      authPill.textContent = isAuthed ? (user.email || "Signed in") : "Not signed in";

      // ✅ Hidden nav is visible whenever authed (no more count gating)
      if (navHidden) navHidden.classList.toggle("hidden", !isAuthed);

      showRoute(currentRoute());

      if (isAuthed) setStatus("good", "Signed in", "Paste a Secure/Personal code and press Fetch.");
      else setStatus("warn", "Not signed in", "Sign in to fetch signed inbox messages.");
    }

    auth.onAuthStateChanged((user) => renderAuthUI(user));

    btnGoogle.addEventListener("click", async () => {
      try {
        setStatus("good", "Signing in…", "Opening Google sign-in…");
        const provider = new firebase.auth.GoogleAuthProvider();
        provider.setCustomParameters({ prompt: "select_account" });
        await auth.signInWithPopup(provider);
        setStatus("good", "Signed in", "You can fetch signed envelopes now.");
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t sign in", "Google sign-in failed. Check pop-up blocking and try again.");
      }
    });

    btnSignOut.addEventListener("click", async () => {
      try {
        await auth.signOut();
        setStatus("warn", "Signed out", "Sign in again to fetch signed inbox messages.");
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t sign out", "Try again.");
      }
    });

    // -------------------------
    // Local state (device-only)
    // -------------------------
    const LS = {
      awaitingIds: "sf_inbox_awaiting_ids",
      hiddenUpcomingIds: "sf_inbox_hidden_upcoming",
      hiddenReleasedIds: "sf_inbox_hidden_released",
      pinnedIds: "sf_inbox_pinned_ids",
      blockedSenders: "sf_inbox_blocked_senders",
      showBlocked: "sf_inbox_show_blocked",
      autoPolling: "sf_inbox_auto_polling"
    };

    function readJson(key, fallback){
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return fallback;
        return JSON.parse(raw);
      } catch (_) {
        return fallback;
      }
    }
    function writeJson(key, value){
      try { localStorage.setItem(key, JSON.stringify(value)); } catch (_) {}
    }

    function uniq(arr){
      const out = [];
      const seen = new Set();
      for (const x of arr || []) {
        if (!x) continue;
        if (seen.has(x)) continue;
        seen.add(x);
        out.push(x);
      }
      return out;
    }

    function getAwaitingIds(){ return uniq(readJson(LS.awaitingIds, [])); }
    function setAwaitingIds(v){ writeJson(LS.awaitingIds, uniq(v)); }

    function getHiddenUpcomingIds(){ return uniq(readJson(LS.hiddenUpcomingIds, [])); }
    function setHiddenUpcomingIds(v){ writeJson(LS.hiddenUpcomingIds, uniq(v)); }

    function getHiddenReleasedIds(){ return uniq(readJson(LS.hiddenReleasedIds, [])); }
    function setHiddenReleasedIds(v){ writeJson(LS.hiddenReleasedIds, uniq(v)); }

    function getPinnedIds(){ return uniq(readJson(LS.pinnedIds, [])); }
    function setPinnedIds(v){ writeJson(LS.pinnedIds, uniq(v)); }

    function getBlockedSenders(){ return uniq(readJson(LS.blockedSenders, [])); }
    function setBlockedSenders(v){ writeJson(LS.blockedSenders, uniq(v)); }

    // ✅ robust (localStorage can throw in some privacy modes)
    function getShowBlocked(){
      try { return (localStorage.getItem(LS.showBlocked) === "true"); } catch (_) { return false; }
    }
    function setShowBlocked(v){
      try { localStorage.setItem(LS.showBlocked, v ? "true" : "false"); } catch (_) {}
    }

    function getAutoPolling(){
      try { return (localStorage.getItem(LS.autoPolling) === "true"); } catch (_) { return false; }
    }
    function setAutoPolling(v){
      try { localStorage.setItem(LS.autoPolling, v ? "true" : "false"); } catch (_) {}
    }

    function refreshHiddenNav(){
      const hiddenCount = getHiddenReleasedIds().length;
      const pillHidden = document.getElementById("pill-hidden");
      if (pillHidden) pillHidden.textContent = `${hiddenCount} hidden`;
      // navHidden visibility is handled by auth state now
    }

    // -------------------------
    // Message kind detection
    // -------------------------
    function detectKindFromPlaintext(pt){
      const s = (pt || "").trim();
      if (s.startsWith("Delvee — pulse summary")) {
        return { kind: "delvee_summary", label: "Delvee Summary", pillText: "Delvee", pillCls: "delvee" };
      }
      return { kind: "generic", label: "Message", pillText: "", pillCls: "" };
    }

    // -------------------------
    // Crypto helpers (WebCrypto)
    // -------------------------
    function normalizeCodeAndroid(raw) { return raw.trim().toUpperCase().replace(/[\s-]/g, ""); }

    function b64ToBytes(b64) {
      const bin = atob(b64);
      const out = new Uint8Array(bin.length);
      for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
      return out;
    }

    async function sha256Hex(str) {
      const data = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
    }

    async function deriveAesKeyFromPassphrase(passphrase, saltBytes) {
      const passBytes = new TextEncoder().encode(passphrase);
      const baseKey = await crypto.subtle.importKey("raw", passBytes, { name: "PBKDF2" }, false, ["deriveKey"]);
      return await crypto.subtle.deriveKey(
        { name: "PBKDF2", salt: saltBytes, iterations: 100000, hash: "SHA-256" },
        baseKey,
        { name: "AES-GCM", length: 256 },
        false,
        ["decrypt"]
      );
    }

    async function decryptEnvelopeForCode(rawCode, ciphertextB64, ivB64, saltB64) {
      try {
        const passphrase = normalizeCodeAndroid(rawCode);
        const salt = b64ToBytes(saltB64);
        const iv = b64ToBytes(ivB64);
        const ct = b64ToBytes(ciphertextB64);
        const key = await deriveAesKeyFromPassphrase(passphrase, salt);
        const pt = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, ct);
        return new TextDecoder().decode(pt);
      } catch (_) {
        return null;
      }
    }

    // -------------------------
    // Time formatting
    // -------------------------
    function formatLocal(deliverAtUtc, deliverAtLocalIso) {
      const src = deliverAtLocalIso || deliverAtUtc;
      if (!src) return "—";
      try {
        const d = new Date(src);
        if (Number.isNaN(d.getTime())) return "—";
        return d.toLocaleString(undefined, { weekday:"short", month:"short", day:"numeric", hour:"numeric", minute:"2-digit" });
      } catch (_) { return "—"; }
    }

    function parseDeliverMillis(deliverAtUtc, deliverAtLocalIso){
      const src = deliverAtLocalIso || deliverAtUtc;
      if (!src) return null;
      const d = new Date(src);
      const t = d.getTime();
      return Number.isFinite(t) ? t : null;
    }

    function safeText(s) {
      const v = (s == null) ? "" : String(s);
      return v.replace(/[&<>"']/g, (c) => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    }

    // -------------------------
    // UI elements
    // -------------------------
    const codeInput = document.getElementById("code-input");
    const btnFetch = document.getElementById("btn-fetch");
    const btnFetchSummaries = document.getElementById("btn-fetch-summaries");
    const btnClear = document.getElementById("btn-clear");
    const countPill = document.getElementById("count-pill");

    const btnAuto = document.getElementById("btn-auto");
    const autoLabel = document.getElementById("auto-label");

    const btnShowBlocked = document.getElementById("btn-show-blocked");
    const blockedLabel = document.getElementById("blocked-label");

    const btnSummariesOnly = document.getElementById("btn-summaries-only");
    const summariesLabel = document.getElementById("summaries-label");

    const listPinned = document.getElementById("list-pinned");
    const listUpcoming = document.getElementById("list-upcoming");
    const listAwaiting = document.getElementById("list-awaiting");
    const listReleased = document.getElementById("list-released");

    const pillPinned = document.getElementById("pill-pinned");
    const pillUpcoming = document.getElementById("pill-upcoming");
    const pillAwaiting = document.getElementById("pill-awaiting");
    const pillReleased = document.getElementById("pill-released");
    const headPinned = document.getElementById("head-pinned");

    const listHidden = document.getElementById("list-hidden");
    const btnHiddenBack = document.getElementById("btn-hidden-back");
    const btnHiddenClearAll = document.getElementById("btn-hidden-clearall");

    btnHiddenBack.addEventListener("click", () => { window.location.hash = ""; });
    btnHiddenClearAll.addEventListener("click", () => {
      setHiddenReleasedIds([]);
      refreshHiddenNav();
      renderHidden();
      setStatus("warn", "Cleared", "Hidden list cleared on this device.");
    });

    // Prefill code from URL ?code=
    (function prefillFromUrl(){
      try{
        const u = new URL(window.location.href);
        const c = u.searchParams.get("code");
        if (c && codeInput) codeInput.value = c;
      } catch(_) {}
    })();

    // -------------------------
    // Delvee modal hooks
    // -------------------------
    const delveeModal = document.getElementById("delvee-modal");
    const delveeClose = document.getElementById("delvee-close");
    const delveeOk = document.getElementById("delvee-ok");
    const delveeStage = document.getElementById("delvee-stage");
    const delveeText = document.getElementById("delvee-text");
    const delveeWho = document.getElementById("delvee-who");
    const delveeConsume = document.getElementById("delvee-consume");
    const delveeHeading = document.getElementById("delvee-heading");

    let delveeActiveEnvelopeId = null;
    let delveeActiveCardEl = null;

    function delveeHide(){
      delveeModal.classList.remove("show");
      delveeStage.classList.remove("is-playing");
      delveeStage.classList.remove("is-revealed");
      delveeText.textContent = "";
      delveeWho.textContent = "Opening…";
      delveeConsume.disabled = false;
      delveeConsume.textContent = "Consume";
      delveeActiveEnvelopeId = null;
      delveeActiveCardEl = null;
      if (delveeHeading) delveeHeading.textContent = "Message";
    }

    function delveeShow({ envelopeId, body, senderUid, kindLabel }){
      delveeActiveEnvelopeId = envelopeId;
      delveeWho.textContent = senderUid ? `From ${senderUid}` : "A surprise drop";
      delveeText.textContent = "";
      if (delveeHeading) delveeHeading.textContent = kindLabel || "Message";

      delveeModal.classList.add("show");
      delveeStage.classList.remove("is-playing");
      delveeStage.classList.remove("is-revealed");

      requestAnimationFrame(() => {
        delveeStage.classList.add("is-playing");
        setTimeout(() => {
          delveeText.textContent = body || "";
          delveeStage.classList.add("is-revealed");
        }, 920);
      });
    }

    delveeClose.addEventListener("click", delveeHide);
    delveeOk.addEventListener("click", delveeHide);
    delveeModal.addEventListener("click", (e) => { if (e.target === delveeModal) delveeHide(); });
    window.addEventListener("keydown", (e) => { if (e.key === "Escape") { delveeHide(); hideActionsModal(); } });

    // -------------------------
    // Released actions modal
    // -------------------------
    const actionsModal = document.getElementById("sf-actions-modal");
    const actionsMeta = document.getElementById("sf-actions-meta");
    const actionsPreview = document.getElementById("sf-actions-preview");

    const btnActPin = document.getElementById("sf-btn-pin");
    const btnActHideMsg = document.getElementById("sf-btn-hide-msg");
    const btnActBlockSender = document.getElementById("sf-btn-block-sender");
    const btnActConsume = document.getElementById("sf-btn-consume");
    const btnActDone = document.getElementById("sf-btn-done");

    let activeActionItem = null; // { id, senderUid, when, body }

    function showActionsModal(item){
      activeActionItem = item;
      actionsMeta.textContent = `${item.when || "—"}${item.senderUid ? " · " + item.senderUid : ""}`;
      actionsPreview.textContent = item.body ? item.body : "Hidden — press Open to reveal";
      actionsModal.classList.add("show");
    }
    function hideActionsModal(){
      actionsModal.classList.remove("show");
      activeActionItem = null;
    }

    actionsModal.addEventListener("click", (e) => { if (e.target === actionsModal) hideActionsModal(); });
    btnActDone.addEventListener("click", hideActionsModal);

    btnActPin.addEventListener("click", () => {
      if (!activeActionItem) return;
      const pinned = getPinnedIds();
      if (!pinned.includes(activeActionItem.id)) pinned.push(activeActionItem.id);
      setPinnedIds(pinned);
      hideActionsModal();
      renderAll();
      setStatus("good", "Pinned", "Message pinned on this device.");
    });

    btnActHideMsg.addEventListener("click", () => {
      if (!activeActionItem) return;
      const hidden = getHiddenReleasedIds();
      if (!hidden.includes(activeActionItem.id)) hidden.push(activeActionItem.id);
      setHiddenReleasedIds(hidden);
      hideActionsModal();
      refreshHiddenNav();
      renderAll();
      setStatus("warn", "Hidden", "Message hidden on this device.");
    });

    btnActBlockSender.addEventListener("click", () => {
      if (!activeActionItem) return;
      if (!activeActionItem.senderUid) {
        setStatus("warn", "No sender", "This message has no sender id to hide.");
        return;
      }
      const blocked = getBlockedSenders();
      if (!blocked.includes(activeActionItem.senderUid)) blocked.push(activeActionItem.senderUid);
      setBlockedSenders(blocked);
      hideActionsModal();
      renderAll();

      // ✅ immediately reflect in toggle label (and sanity-check storage)
      applyToggleUI();
      setStatus("warn", "Sender hidden", "Messages from this sender are hidden on this device.");
    });

    btnActConsume.addEventListener("click", async () => {
      if (!activeActionItem) return;
      await consumeEnvelope(activeActionItem.id);
      hideActionsModal();
    });

    // -------------------------
    // Notifications (browser)
    // -------------------------
    async function ensureBrowserNotifications(){
      try {
        if (!("Notification" in window)) return false;
        if (Notification.permission === "granted") return true;
        if (Notification.permission === "denied") return false;
        const p = await Notification.requestPermission();
        return p === "granted";
      } catch (_) {
        return false;
      }
    }

    function notifyReleased(title, body){
      try {
        if (!("Notification" in window)) return;
        if (Notification.permission !== "granted") return;
        new Notification(title, { body });
      } catch (_) {}
    }

    // -------------------------
    // Fetch + normalize
    // -------------------------
    async function fetchSignedEnvelopesForCode(rawCode) {
      const normalized = normalizeCodeAndroid(rawCode);
      const codeHash = await sha256Hex(normalized);

      const callable = functions.httpsCallable("fetchSignedEnvelopes");
      const res = await callable({ codeHash });

      const payload = (res && res.data) ? res.data : {};
      const arr = Array.isArray(payload.envelopes) ? payload.envelopes : [];
      return arr;
    }

    let decryptedById = new Map();
    let latestItems = [];

    // UI-only filter (in-memory)
    let summariesOnly = false;

    async function buildLatestItems(rawCode, envelopes){
      decryptedById = new Map();
      const out = [];

      for (const env of envelopes || []) {
        const id = env.signedEnvelopeId;
        const senderUid = env.senderUid || null;
        const deliverAtUtc = env.deliverAtUtc || null;
        const deliverAtLocalIso = env.deliverAtLocalIso || null;
        const when = formatLocal(deliverAtUtc, deliverAtLocalIso);
        const deliverMillis = parseDeliverMillis(deliverAtUtc, deliverAtLocalIso);

        const ciphertext = env.ciphertext || env.ciphertextB64;
        const iv = env.iv || env.ivB64;
        const salt = env.salt || env.saltB64;

        if (!id || !ciphertext || !iv || !salt) continue;

        const pt = await decryptEnvelopeForCode(rawCode, ciphertext, iv, salt);
        if (pt == null) continue;

        const k = detectKindFromPlaintext(pt);

        decryptedById.set(id, pt);
        out.push({
          id,
          senderUid,
          when,
          deliverMillis,
          ciphertext,
          iv,
          salt,
          kind: k.kind,
          kindLabel: k.label,
          kindPillText: k.pillText,
          kindPillCls: k.pillCls
        });
      }

      return out;
    }

    function categorize(items){
      const now = Date.now();

      const awaitingIds = new Set(getAwaitingIds());
      const hiddenUpcomingIds = new Set(getHiddenUpcomingIds());
      const hiddenReleasedIds = new Set(getHiddenReleasedIds());
      const pinnedIds = new Set(getPinnedIds());

      const blockedSenders = new Set(getBlockedSenders());
      const showBlocked = getShowBlocked();

      const pinned = [];
      const upcoming = [];
      const awaiting = [];
      const released = [];

      for (const it of items || []) {
        // ✅ summaries-only filter applies everywhere (but does not affect Hidden route)
        if (summariesOnly && it.kind !== "delvee_summary") continue;

        const deliverMillis = it.deliverMillis;
        const isReleased = (deliverMillis == null) ? true : (deliverMillis <= now);

        const isSenderBlocked = it.senderUid && blockedSenders.has(it.senderUid);

        if (isReleased) {
          if (hiddenReleasedIds.has(it.id)) continue;

          // ✅ hide blocked senders unless explicitly shown
          if (!showBlocked && isSenderBlocked) continue;

          const body = decryptedById.get(it.id) || "";
          const entry = { ...it, body };

          if (pinnedIds.has(it.id)) pinned.push(entry);
          else released.push(entry);
          continue;
        }

        const entry = { ...it, body: "" };

        if (awaitingIds.has(it.id)) awaiting.push(entry);
        else {
          if (hiddenUpcomingIds.has(it.id)) continue;
          upcoming.push(entry);
        }
      }

      const bySoon = (a,b) => (a.deliverMillis ?? 0) - (b.deliverMillis ?? 0);
      const byNew = (a,b) => (b.deliverMillis ?? 0) - (a.deliverMillis ?? 0);

      upcoming.sort(bySoon);
      awaiting.sort(bySoon);
      released.sort(byNew);
      pinned.sort(byNew);

      return { pinned, upcoming, awaiting, released };
    }

    function attachSwipeHandlers(cardEl, opts){
      const dragEl = cardEl.querySelector(".sf-drag");
      const bgEl = cardEl.querySelector(".sf-swipe-bg");

      let startX = 0;
      let startY = 0;
      let dx = 0;
      let active = false;

      let longPressTimer = null;
      let longPressFired = false;

      const SWIPE_THRESHOLD = 72;

      function clearLongPress(){
        if (longPressTimer) clearTimeout(longPressTimer);
        longPressTimer = null;
      }

      function setDrag(x){
        dragEl.style.transition = "none";
        dragEl.style.transform = `translateX(${x}px)`;
        if (bgEl) bgEl.classList.toggle("show", Math.abs(x) > 8);
      }

      function settle(){
        dragEl.style.transition = "transform 140ms ease";
        dragEl.style.transform = "translateX(0px)";
        if (bgEl) bgEl.classList.remove("show");
      }

      function onDown(e){
        if (!dragEl) return;
        active = true;
        startX = e.clientX;
        startY = e.clientY;
        dx = 0;
        longPressFired = false;

        if (opts.enableLongPress) {
          clearLongPress();
          longPressTimer = setTimeout(() => {
            longPressFired = true;
            try { navigator.vibrate && navigator.vibrate(12); } catch (_) {}
            opts.onLongPress && opts.onLongPress();
          }, 520);
        }

        try { cardEl.setPointerCapture && cardEl.setPointerCapture(e.pointerId); } catch (_) {}
      }

      function onMove(e){
        if (!active) return;

        const cx = e.clientX;
        const cy = e.clientY;
        dx = cx - startX;
        const dy = cy - startY;

        if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > 10) {
          clearLongPress();
          settle();
          active = false;
          return;
        }

        if (Math.abs(dx) > 8) clearLongPress();
        if (opts.onSwipeLeft || opts.onSwipeRight) setDrag(dx);
      }

      async function onUp(){
        if (!active) return;
        active = false;
        clearLongPress();

        if (longPressFired) { settle(); return; }

        if (opts.onSwipeLeft || opts.onSwipeRight) {
          const commitRight = dx >= SWIPE_THRESHOLD;
          const commitLeft = dx <= -SWIPE_THRESHOLD;

          if (commitRight && opts.onSwipeRight) {
            dragEl.style.transition = "transform 120ms ease";
            dragEl.style.transform = "translateX(110px)";
            setTimeout(() => opts.onSwipeRight && opts.onSwipeRight(), 90);
            return;
          }

          if (commitLeft && opts.onSwipeLeft) {
            dragEl.style.transition = "transform 120ms ease";
            dragEl.style.transform = "translateX(-110px)";
            setTimeout(() => opts.onSwipeLeft && opts.onSwipeLeft(), 90);
            return;
          }
        }

        settle();
      }

      cardEl.addEventListener("pointerdown", onDown);
      cardEl.addEventListener("pointermove", onMove);
      cardEl.addEventListener("pointerup", onUp);
      cardEl.addEventListener("pointercancel", onUp);
      cardEl.addEventListener("lostpointercapture", onUp);
    }

    function messageCardHTML(item, mode){
      const isAwaiting = mode === "awaiting";
      const isReleased = (mode === "released" || mode === "pinned");
      const isHidden = mode === "hidden";

      const sender = item.senderUid ? `Sender: ${item.senderUid}` : "Sender: —";
      const when = item.when || "—";

      const bodyText =
        isReleased ? "Hidden — press Open" :
        isAwaiting ? "Awaiting — notify me when ready" :
        isHidden ? "Hidden" :
        "Upcoming";

      const leftLabel = mode === "upcoming" ? "Hide" : "";
      const rightLabel = mode === "upcoming" ? "Awaiting" : "";

      const btns = [];
      if (isReleased) {
        btns.push(`<button class="btn btn-secondary" type="button" data-open="${safeText(item.id)}">Open</button>`);
        btns.push(`<button class="btn btn-quiet" type="button" data-consume="${safeText(item.id)}">Consume</button>`);
        btns.push(`<button class="btn btn-quiet" type="button" data-more="${safeText(item.id)}">•••</button>`);
      } else if (isHidden) {
        btns.push(`<button class="btn btn-secondary" type="button" data-restore="${safeText(item.id)}">Restore</button>`);
      } else {
        btns.push(`<button class="btn btn-quiet" type="button" data-hide-upcoming="${safeText(item.id)}">Hide</button>`);
        if (!isAwaiting) btns.push(`<button class="btn btn-secondary" type="button" data-make-awaiting="${safeText(item.id)}">Mark awaiting</button>`);
      }

      const titleText = (item && item.kindLabel) ? item.kindLabel : (mode === "pinned" ? "Pinned message" : "Message");
      const pill =
        (item && item.kind === "delvee_summary")
          ? `<span class="sf-kind delvee">${safeText(item.kindPillText || "Delvee")}</span>`
          : ``;

      return `
        <div class="sf-msg-card" data-id="${safeText(item.id)}" data-mode="${safeText(mode)}">
          <div class="sf-swipe-bg">
            <div class="sf-swipe-left">${safeText(leftLabel)}</div>
            <div class="sf-swipe-right">${safeText(rightLabel)}</div>
          </div>

          <div class="sf-drag">
            <div class="sf-msg-top">
              <div class="sf-msg-title">
                ${pill}
                <span class="sf-msg-title-text">${safeText(titleText)}</span>
              </div>
              <div class="sf-msg-meta">
                <span>${safeText(when)}</span>
                <span>${safeText(sender)}</span>
              </div>
            </div>

            <div class="sf-msg-body">${safeText(bodyText)}</div>

            <div class="sf-msg-actions">
              ${btns.join("")}
            </div>
          </div>
        </div>
      `;
    }

    async function consumeEnvelope(id){
      if (!id) return;

      try {
        setStatus("good", "Consuming…", "Marking envelope consumed…");
        const callable = functions.httpsCallable("markSignedEnvelopeConsumed");
        await callable({ signedEnvelopeId: id });

        setAwaitingIds(getAwaitingIds().filter(x => x !== id));
        setHiddenUpcomingIds(getHiddenUpcomingIds().filter(x => x !== id));
        setHiddenReleasedIds(getHiddenReleasedIds().filter(x => x !== id));
        setPinnedIds(getPinnedIds().filter(x => x !== id));

        decryptedById.delete(id);
        latestItems = latestItems.filter(x => x.id !== id);

        refreshHiddenNav();
        renderAll();
        setStatus("good", "Consumed", "Message consumed.");
      } catch (e) {
        console.error(e);
        setStatus("warn", "Couldn’t consume", "Try again. Session may have expired.");
      }
    }

    function renderEmpty(el, title, subtitle){
      el.innerHTML = `
        <div class="panel">
          <p class="panel-title">${safeText(title)}</p>
          <p class="panel-sub">${safeText(subtitle)}</p>
          <small class="help">Tip: press Fetch after sending a message.</small>
        </div>
      `;
    }

    function renderHidden(){
      const hiddenIds = new Set(getHiddenReleasedIds());
      const hiddenItems = (latestItems || [])
        .filter(it => hiddenIds.has(it.id))
        .map(it => ({ ...it, body: decryptedById.get(it.id) || "" }));

      const pillHidden = document.getElementById("pill-hidden");
      if (pillHidden) pillHidden.textContent = `${hiddenItems.length} hidden`;

      if (hiddenItems.length === 0) {
        renderEmpty(listHidden, "No hidden messages", "Hide a released message to see it here.");
        return;
      }

      listHidden.innerHTML = hiddenItems.map(it => messageCardHTML(it, "hidden")).join("");

      listHidden.querySelectorAll("button[data-restore]").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.getAttribute("data-restore");
          if (!id) return;
          setHiddenReleasedIds(getHiddenReleasedIds().filter(x => x !== id));
          refreshHiddenNav();
          renderAll();
          setStatus("good", "Restored", "Message restored to Released.");
        });
      });
    }

    function renderAll(){
      refreshHiddenNav();

      const { pinned, upcoming, awaiting, released } = categorize(latestItems);

      pillPinned.textContent = String(pinned.length);
      pillUpcoming.textContent = String(upcoming.length);
      pillAwaiting.textContent = String(awaiting.length);
      pillReleased.textContent = String(released.length);

      const total = pinned.length + upcoming.length + awaiting.length + released.length;
      countPill.textContent = `${total} message${total === 1 ? "" : "s"}`;

      if (pinned.length > 0) {
        headPinned.style.display = "flex";
        listPinned.innerHTML = pinned.map(it => messageCardHTML(it, "pinned")).join("");
      } else {
        headPinned.style.display = "none";
        listPinned.innerHTML = "";
      }

      if (upcoming.length === 0) renderEmpty(listUpcoming, summariesOnly ? "No upcoming summaries" : "No upcoming messages", "Upcoming messages appear here until delivery time.");
      else listUpcoming.innerHTML = upcoming.map(it => messageCardHTML(it, "upcoming")).join("");

      if (awaiting.length === 0) renderEmpty(listAwaiting, summariesOnly ? "No awaiting summaries" : "No awaiting messages", "Swipe right on an upcoming message to mark it Awaiting.");
      else listAwaiting.innerHTML = awaiting.map(it => messageCardHTML(it, "awaiting")).join("");

      if (released.length === 0) renderEmpty(listReleased, summariesOnly ? "No released summaries" : "No released messages", "When delivery time arrives, messages appear here.");
      else listReleased.innerHTML = released.map(it => messageCardHTML(it, "released")).join("");

      wireUpcoming(listUpcoming, upcoming);
      wireAwaiting(listAwaiting, awaiting);
      wireReleased(listPinned, pinned);
      wireReleased(listReleased, released);

      if (currentRoute() === "hidden") renderHidden();
    }

    function findItemById(id){
      return (latestItems || []).find(x => x.id === id) || null;
    }

    function wireUpcoming(container, items){
      container.querySelectorAll(".sf-msg-card").forEach(card => {
        const id = card.getAttribute("data-id");
        if (!id) return;

        attachSwipeHandlers(card, {
          onSwipeRight: async () => {
            const awaiting = getAwaitingIds();
            if (!awaiting.includes(id)) awaiting.push(id);
            setAwaitingIds(awaiting);

            const ok = await ensureBrowserNotifications();
            if (ok) setStatus("good", "Awaiting", "Browser notifications enabled for awaiting items.");
            else setStatus("warn", "Awaiting", "Awaiting set. Enable browser notifications if you want alerts.");

            renderAll();
          },
          onSwipeLeft: () => {
            const hidden = getHiddenUpcomingIds();
            if (!hidden.includes(id)) hidden.push(id);
            setHiddenUpcomingIds(hidden);
            setStatus("warn", "Hidden (upcoming)", "Hidden until release time (device-only).");
            renderAll();
          },
          enableLongPress: false
        });

        const btnHide = card.querySelector(`button[data-hide-upcoming="${CSS.escape(id)}"]`);
        if (btnHide) btnHide.addEventListener("click", () => {
          const hidden = getHiddenUpcomingIds();
          if (!hidden.includes(id)) hidden.push(id);
          setHiddenUpcomingIds(hidden);
          setStatus("warn", "Hidden (upcoming)", "Hidden until release time (device-only).");
          renderAll();
        });

        const btnAwait = card.querySelector(`button[data-make-awaiting="${CSS.escape(id)}"]`);
        if (btnAwait) btnAwait.addEventListener("click", async () => {
          const awaiting = getAwaitingIds();
          if (!awaiting.includes(id)) awaiting.push(id);
          setAwaitingIds(awaiting);

          const ok = await ensureBrowserNotifications();
          if (ok) setStatus("good", "Awaiting", "Browser notifications enabled for awaiting items.");
          else setStatus("warn", "Awaiting", "Awaiting set. Enable browser notifications if you want alerts.");

          renderAll();
        });
      });
    }

    function wireAwaiting(container, items){
      container.querySelectorAll(".sf-msg-card").forEach(card => {
        const id = card.getAttribute("data-id");
        if (!id) return;

        attachSwipeHandlers(card, { enableLongPress: false });

        const btnHide = card.querySelector(`button[data-hide-upcoming="${CSS.escape(id)}"]`);
        if (btnHide) btnHide.addEventListener("click", () => {
          const hidden = getHiddenUpcomingIds();
          if (!hidden.includes(id)) hidden.push(id);
          setHiddenUpcomingIds(hidden);

          setAwaitingIds(getAwaitingIds().filter(x => x !== id));

          setStatus("warn", "Hidden (upcoming)", "Hidden until release time (device-only).");
          renderAll();
        });
      });
    }

    function wireReleased(container, items){
      container.querySelectorAll(".sf-msg-card").forEach(card => {
        const id = card.getAttribute("data-id");
        if (!id) return;

        const item = items.find(x => x.id === id) || null;
        if (!item) return;

        attachSwipeHandlers(card, {
          enableLongPress: true,
          onLongPress: () => {
            const full = findItemById(id);
            const body = decryptedById.get(id) || "";
            showActionsModal({ id, senderUid: full ? full.senderUid : null, when: item.when, body });
          }
        });

        const btnOpen = card.querySelector(`button[data-open="${CSS.escape(id)}"]`);
        if (btnOpen) btnOpen.addEventListener("click", () => {
          const full = findItemById(id);
          const body = decryptedById.get(id) || "";
          delveeActiveCardEl = card;
          const kindLabel = full && full.kindLabel ? full.kindLabel : "Message";
          delveeShow({ envelopeId: id, body, senderUid: full ? (full.senderUid || null) : null, kindLabel });
        });

        const btnConsume = card.querySelector(`button[data-consume="${CSS.escape(id)}"]`);
        if (btnConsume) btnConsume.addEventListener("click", async () => {
          btnConsume.disabled = true;
          btnConsume.textContent = "Consuming…";
          await consumeEnvelope(id);
        });

        const btnMore = card.querySelector(`button[data-more="${CSS.escape(id)}"]`);
        if (btnMore) btnMore.addEventListener("click", () => {
          const full = findItemById(id);
          const body = decryptedById.get(id) || "";
          showActionsModal({ id, senderUid: full ? full.senderUid : null, when: item.when, body });
        });
      });
    }

    delveeConsume.addEventListener("click", async () => {
      if (!delveeActiveEnvelopeId) return;
      delveeConsume.disabled = true;
      delveeConsume.textContent = "Consuming…";
      await consumeEnvelope(delveeActiveEnvelopeId);
      delveeHide();
    });

    // -------------------------
    // Auto polling + toggles
    // -------------------------
    let autoTimer = null;

    function applyToggleUI(){
      autoLabel.textContent = `Auto polling: ${getAutoPolling() ? "On" : "Off"}`;
      blockedLabel.textContent = `Hidden senders: ${getShowBlocked() ? "Shown" : "Hidden"}`;
      summariesLabel.textContent = `Show: ${summariesOnly ? "Summaries" : "All"}`;
    }

    function stopAuto(){
      if (autoTimer) clearInterval(autoTimer);
      autoTimer = null;
    }

    function startAuto(){
      stopAuto();
      autoTimer = setInterval(async () => {
        if (!auth.currentUser) return;
        const rawCode = (codeInput && codeInput.value) ? codeInput.value.trim() : "";
        if (!rawCode) return;
        await doFetch(rawCode, { quiet: true });
      }, 15000);
    }

    btnAuto.addEventListener("click", async () => {
      const next = !getAutoPolling();
      setAutoPolling(next);
      applyToggleUI();
      if (next) {
        startAuto();
        setStatus("good", "Auto polling on", "Fetching every ~15s while this tab is open.");
      } else {
        stopAuto();
        setStatus("warn", "Auto polling off", "Manual Fetch only.");
      }
    });

    // ✅ Fix: always re-render after toggling; robust storage already handled
    btnShowBlocked.addEventListener("click", () => {
      const next = !getShowBlocked();
      setShowBlocked(next);
      applyToggleUI();
      renderAll();
      setStatus("good", "Updated", next ? "Hidden senders are now shown." : "Hidden senders are now hidden.");
    });

    btnSummariesOnly.addEventListener("click", () => {
      summariesOnly = !summariesOnly;
      applyToggleUI();
      renderAll();
    });

    // -------------------------
    // Fetch flow
    // -------------------------
    async function doFetch(rawCode, { quiet } = { quiet:false }){
      if (!auth.currentUser) {
        if (!quiet) setStatus("warn", "Sign-in required", "Sign in to fetch signed inbox messages.");
        return;
      }

      const code = (rawCode || "").trim();
      if (!code) {
        if (!quiet) setStatus("warn", "Code needed", "Paste a Secure/Personal code first.");
        return;
      }

      try {
        if (!quiet) setStatus("good", "Fetching…", "Calling fetchSignedEnvelopes…");
        const envelopes = await fetchSignedEnvelopesForCode(code);
        const items = await buildLatestItems(code, envelopes);

        const prev = latestItems;
        latestItems = items;

        const awaitingIds = new Set(getAwaitingIds());
        const now = Date.now();

        for (const it of latestItems) {
          if (!awaitingIds.has(it.id)) continue;
          const t = it.deliverMillis;
          const isReleasedNow = (t == null) ? true : (t <= now);
          if (!isReleasedNow) continue;

          const prevIt = (prev || []).find(x => x.id === it.id) || null;
          const prevT = prevIt ? prevIt.deliverMillis : null;
          const wasReleasedBefore = (prevT == null) ? !!prevIt : (prevT <= now);

          if (!wasReleasedBefore) {
            notifyReleased("Setfeed — message released", it.senderUid ? `From ${it.senderUid}` : "A message is ready.");
          }
        }

        renderAll();

        if (!quiet) {
          if (latestItems.length === 0) setStatus("warn", "No messages", "No decryptable messages for this code (or none unconsumed).");
          else setStatus("good", "Fetched", "Lists updated. Open reveals plaintext with Delvee.");
        }
      } catch (e) {
        console.error(e);
        if (!quiet) setStatus("warn", "Fetch failed", (e && e.message) ? e.message : "Fetch failed. Try again.");
      }
    }

    btnFetch.addEventListener("click", async () => {
      btnFetch.disabled = true;
      const prev = btnFetch.textContent;
      btnFetch.textContent = "Fetching…";
      try {
        await doFetch(codeInput.value, { quiet:false });
      } finally {
        btnFetch.disabled = false;
        btnFetch.textContent = prev;
      }
    });

    // ✅ “Fetch summaries” = fetch, then switch filter to summaries-only
    btnFetchSummaries.addEventListener("click", async () => {
      btnFetchSummaries.disabled = true;
      const prev = btnFetchSummaries.textContent;
      btnFetchSummaries.textContent = "Fetching…";
      try {
        await doFetch(codeInput.value, { quiet:false });
        summariesOnly = true;
        applyToggleUI();
        renderAll();
        setStatus("good", "Summaries", "Showing Delvee Summaries only.");
      } finally {
        btnFetchSummaries.disabled = false;
        btnFetchSummaries.textContent = prev;
      }
    });

    btnClear.addEventListener("click", () => {
      codeInput.value = "";
      setAwaitingIds([]);

      decryptedById = new Map();
      latestItems = [];
      summariesOnly = false;

      applyToggleUI();
      renderAll();
      setStatus("warn", "Cleared", "Inbox cleared. Paste a code and press Fetch.");
    });

    // -------------------------
    // Boot
    // -------------------------
    applyToggleUI();
    refreshHiddenNav();

    if (getAutoPolling()) startAuto();

    showRoute(currentRoute());

    latestItems = [];
    renderAll();
    setStatus("good", "Ready", "Sign in to fetch signed inbox messages.");
  </script>
</body>
</html>
